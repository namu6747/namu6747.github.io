---
title: 자바 - 1 - 자료형
author: namu6747
date: 2022-05-23 00:00:00 +0900
categories: [그 외, deprecated]
tags: [자바]
---

변수: 데이터의 저장과 참조를 위해 '할당된 메모리 공간'에 붙인 이름

0001 의 음수는 1001이 아니다.
1의보수화를 시킨 뒤 1을 더해줘야한다.
1의 보수화는 0과 1을 교환하는 것이다.
1111이 0001의 음수다. 올림 수는 버리므로 값은 0이다.

자바는 정수형 연산을 4바이트 int형으로 진행한다.
연산을 동반하는 상황에서는 변수를 byte, short로 선언해도 생각만큼 메모리가 절약되지 않고
오히려 데이터의 변환 과정만 추가될 뿐이다.

서로 다른 타입의 피연산자가 산술 연산식에 존재한다면, 더 큰 메모리를 할당하는 피연산자의
타입이 연산식의 결과에 부여된다.

(소수점) float은 6자리, double은 15자리의 정밀도를 갖는다.
하나만 보면 그렇지만 실수를 연산한다면 소수점 이하 셋째 자리에서 오차가 발견될 수도 있다.
실수의 계산은 기본적으로 오차가 존재한다고 가정해야 한다.
비교 연산자에서 실수 비교는 자제한다.

char: 하드웨어는 숫자밖에 인식할 수 없어 문자 하나하나에 숫자를 부여하는 수밖에 없다.
"문자 A는 숫자 65로 표시하기로 약속한다."
이러한 '문자의 표현에 대한 약속'을 가리켜 '문자 셋'이라고 한다.
유니코드는 모든 나라의 문자를 수용하여 전 세계적으로 사용하는 문자 셋이다.

자바가 유니코드를 지원하더라도 문자의 출력은 운영체제에 의존적이다.
출력하고자 하는 언어의 폰트가 운영체제에 설치되어 있어야 한다.

String 변수를 선언할 때 문자열 대입과 new 연산자를 통한 인스턴스 생성 두 가지가 있다.
new 연산자를 거치지 않은 문자열은 String Constant Pool에 저장된다.
동일한 문자열이라면 '==' 동등 연산자로 비교할 수 있다.
new 연산자로 생성한 인스턴스는 문자열이 동일하더라도 독립된 heap 영역에 존재하므로
.equals 메소드로 두 인자를 비교해야한다.
new 연산자로 생성자는 그렇다면, 문자열이 갖는 불변성이란 장점을 누리지 못한다고 볼 수 있고
메모리를 효율적으로 사용하기 위해 웬만하면 new 연산자를 거치지 않고 생성하는 것이 좋다.

상수(final)는 값을 딱 한번만 할당할 수 있으며 이후 변경이 불가하다.
상수의 이름은 모두 대문자로 짓는다.

2진수 리터럴 표기 0B111 처럼 0B 삽입
8진수 리터럴 표기 011 022 등 숫자 앞에 0 삽입
16진수 리터럴 표기 0x11 처럼 0x 또는 0X 삽입

long형 정수를 표현할 땐 리터럴에 L표기. 연산에도 마찬가지.
제곱수는 3.4e3 => 3.4 x 10^3 처럼
en을 10의 n승으로 대하면 된다.

숫자 리터럴 사이의 언더바는 컴파일 과정에서 제거 된다.

자동 형변환: 자료형의 크기가 큰 방향으로 형 변환이 일어난다. 
 자료형의 크기에 상관없이 정수 자료형보다 실수 자료형이 우선한다.

정수형 데이터를 실수형으로 변환하면 오차는 존재하겠지만 데이터의 손실은 발생하지 않는다.

복합 대입 연산자는 명시적 형변환을 줄여줄 수 있다. (별 필요없음)

+, - 같은 단항 연산자로 인해서 디폴트 타입이 아닌 자료형에 명시적 형변환을 해줘야할 때가 있다.

비트 연산은 byte 자료형의 연산에서 and, or, xor, ~ 등이 있다.
모든 건 비트 단위로 연산한다.
쉬프트 연산자
int num = A << Z;
위의 문장은 "A의 비트 열을 Z만큼 왼쪽으로 이동시켰을 때의 값을 변수 num에 저장"
00000001 의 경우 왼쪽으로 밀 때마다 오른쪽에선 0이 생성되고 2씩 곱해진다.
오른쪽으로 밀 때마다 왼쪽에선 첫번째 비트와 같은 값이 생성되고 2씩 나눠진다.