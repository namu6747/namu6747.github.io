---
title: 12. about ajax & DTO - Betty
author: namu6747
date: 2022-09-06 09:12:00 +0900
categories: [프로젝트, Betty]
tags: [스프링, 자바, 포트폴리오]
---

<hr/>

# ajax 에 대한 견해

## 약속
ajax 를 통한 데이터 송수신은 엄격한 약속으로 이루어졌다.  
예외 처리의 경우 위 특징이 극명하게 드러났다.   
아직 제대로 구현해보진 않았지만 "C001" 같은 코드를 통해  
분기문을 수행하는 걸 떠올려보면 약간은 두렵다.   

## 비동기
비동기 방식으로 데이터만을 주고 받는다 생각하고 사용했지만  
꼭 여기에 매몰될 필요도 없었다.   
내 경우는 변수를 미리 선언해두고 반환 값을 이용하려 했던 적이 있는데  
비동기 방식으론 정상적인 수행을 기대할 순 없었다.  
이 때는 ajax 를 그대로 사용하되, 동기화 시켰다.   

## 리소스
페이지 전환 없이 데이터만을 주고 받는다는 이점이 있지만,   
또 불필요한 데이터까지 받는 다면 뭔가 이상하다.   
물론 이것만으로도 자원 낭비를 줄일 수 있을 것이다.  
하지만 dto 를 적극 활용하여 이러한 비용 절약을   
극대화 할 때 ajax 의 진가가 나타날 것이라 생각한다.   

## 리다이렉트
전형적인 POST method 를 활용한 통신에서,   
ajax 를 사용했을 땐 javascript 문법으로 location 을 조작하여  
중복 호출이 일어나지 않게 막았다.   

## 사용자 편의
도서 상세 검색을 포함한 다양한 조건 검색에선,   
사용자 편의랍시고 ajax 를 꼭 써야되는 것도 아니였다.   
url 상 쿼리 파라미터로 나타나는 검색 조건에 대해   
숨길 필요가 없었다.   

## 웹앱
모바일앱으로 넘어간다면 이야기는 달라지겠지만   
아직까지 웹앱 밖에 다뤄본 적이 없는 지라   
ajax 는 꼭 필요한 건 아니지만,   
분명 장점이 상당히 많은 기능인 것은 알 수 있었다.  

렌더링을 자바스크립트를 통한 요소 또는 노드 조작으로 진행하여,     
프론트 전반적으로 기본은 할 줄 알아야겠다 싶었고,   
이번 프로젝트에서 나름 제대로 복습하는 시간을 가졌다고 생각된다.   

<br/>


# DTO, Form, VO 그리고 Entity ?

*Form 객체 활용*

Form 은 Dto의 일종임을 인지.
Form 은 특히 클라이언트의 요청이 들어올 때, 
데이터 검증이 필요한 상황에 사용
특정 필드에 값의 제약을 걸어야함.

여기서 끝이 아니라, 이를 스프링에서 검증하라고 지시해야함.
그 지시가 컨트롤러 매개변수의 (@Valid xxxForm form) Valid 어노테이션임.
검증 실패시 파라미터를 바인딩하는 데 실패한 원인을 가지고 핸들링 할 수 있음.

스프링은 파라미터 바인딩 과정에서 발생하는 에러를
BindingResult 객체에 담아줌. 물론 이것도 사용하려면 정의해야함
결론적으로 Form 객체를 활용하기 위해 필요한 작업은,

1. Form 객체 필드에 제약 선언
2. 컨트롤러 매개변수의 Form 객체에 @Valid 어노테이션 선언
3. 컨트롤러 매개변수의 Form 객체 "바로 다음"에 BindingResult 객체 선언

ex) public String freeBoardForm(@Valid FreeBoardForm form, BindingResult bindingResult)

*Dto 객체 활용*

Form 에서 들어온 값은 유저가 영속 계층(데이터베이스)에 값을 삽입하는 성향이 짙음.
그에 비해 Dto는 달리 검증할 필요가 없는, 이미 정해진 데이터들을 송수신하는데 주로 사용.
즉, Dto를 이용하다가 예상치 못한 예외가 발생했을 땐, 개발자의 실수라 볼 수 있음.
"물론 이건 Dto와 Form 을 동시에 사용하는 우리 프로젝트에나 해당하는 얘기이며
Dto만 사용한다면 달라질 수 있음."

컨트롤러는 순수히 view render 관련 로직을 작성하도록 권장
그러므로 우리는 Form, Dto 객체를 바로 service 계층에 넘겨 변환 후 작업할 것임.

영속 계층(Repository)에서 가져온 데이터도 service에서 바로 가공작업이 필요함.
해당하는 Dto 를 또 정의해야하는 과정도 필요하므로 직접 부딪혀보기.

"왜 서버측에서 송신할 때도 변환 과정이 필요한 것인가?"

1.마크업 문서에 적히는 key(name) 값은 데이터베이스 테이블과 다를 수 있음.
2.데이터베이스 테이블 컬럼이 서비스와 무관한 이름으로 지정되어 있을 수도 있음.
3.마크업 문서에 필요한 데이터는 데이터베이스에서 가져온 전체 데이터와 다를 수 있음.

"그렇다면 애초에 영속 계층에서 데이터를 가져올 때 특정 컬럼만 가져오면 되지 않은가?"

그럴 수 있지만 영속 계층의 행위가 매우 비대해질 수 있음.
데이터베이스에 접근하는 행위가 비용이 큰 거지, 
현대의 하드웨어 수준에선 가져올 데이터의 크기를 고려할 필요가 없음. 
(물론 대용량 데이터는 말이 달라짐)

가장 무식하면서도 간단한 처리는, Primary Key 를 이용한 WHERE 탐색을 통해
모든 정보를 가져와 객체를 꺼낸 뒤 필요한 데이터만 가공하여 보내는 것임.
하지만 깊게 생각해봐야 할 게 있음.
데이터베이스에서 가져올 컬럼별 메소드를 작성하는 것과
위의 방식중, 정말 어떤 게 무식한 방법인지를.



## **form, vo, dto, entity**

form 객체는 form 에서 받는 데이터 검증을 위한 객체

저희가 사용하는 vo 의 존재는 dto 와 entity 범주와 겹침.

DDD에서 행위를 갖는 객체가 entity

entity 는 테이블을 모델로한 객체

dto 는 데이터, 즉 값을 전송하기 위한 객체.

dto는 행위를 갖지 않고, 보통 ajax 송수신용으로 사용한다고 생각.

저희 프로젝트에선 vo 겸 entity 인 모델 적용

**결론**

```jsx
form : form 양식에서 전달 받는 객체
dto : 변경이 가능한 ajax 데이터 통신용 객체
vo : 불변성을 갖는 영속 계층(db와 직결된)의 객체
```