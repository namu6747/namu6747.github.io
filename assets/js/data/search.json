[ { "title": "제초 작업", "url": "/posts/grass/", "categories": "그 외, 잡", "tags": "", "date": "2022-09-07 09:02:00 +0900", "snippet": "아까운 잔디를 지웠다.학원을 오가며 집에서도 인강을 듣고 커밋을 자주 했는데깃헙의 목적과 맞지 않다고 느꼈다.1일 1커밋 욕심에 노력했었는데부질없는 것 같다.양심에 찔리기도 하다.막상 정리하고 나니 아쉽긴 하지만 뭐 어쩔 수 없다.이제와서 알았지만 github main 의 readme 텍스트 하나만 수정해도 잔디가 쌓이는데..지우길 잘했다." }, { "title": "HTTP 상태 코드 살펴보기", "url": "/posts/http-status/", "categories": "공부, HTTP", "tags": "HTTP, 상태코드, http status code", "date": "2022-09-07 09:01:00 +0900", "snippet": "학원 최종 프로젝트였던 project-Betty 가 끝났다. 시간에 쫒겨 공통 예외 처리를 구현하지 못했었는데 결과적으로 상태 코드에 대한 학습이 우선이라 생각됐다.정리하려는 이유는 아래와 같다.클라이언트 측의 예외 인지서버에서 Exception 이 발생하면, ajax 문 내부 error 에 정의된 콜백 함수가 실행되길 바랬다.요청에 대한 정상적인 응답이 아님에도 200(OK) 코드로 전송되어 success 내부에서 약속에 의한 코드 또는 메시지로 분기하는 건, ajax 를 정의한 개발자에 대한 예의가 아니라 느꼈다. (애초에 전 지구적 약속인 Http 상태 코드가 존재한다.)확실하진 않으나 서버에서 발생한 Exception 에 상태코드를 따로 붙여주지 않는다면 톰캣이 멋대로 200 코드로 넘긴다고 알고 있다.클라이언트 - 서버 구조에서 좀더 우아하게 Http 프로토콜을 다루려면 상태코드에 대한 학습이 필요하다고 생각한다.아래의 코드는 “org.springframework.http” 패키지의 HttpStatus 클래스에 정의된 목록 중 일부이다.3xx 리다이렉트 MOVED_PERMANENTLY(301, “Moved Permanently”) FOUND(302, “Found”) TEMPORARY_REDIRECT(307, “Temporary Redirect”) PERMANENT_REDIRECT(308, “Permanent Redirect”)    정리요청 경로와 다른 URL로의 이동에 대해 몇 가지 생각나는 게 있다.1. 요청한 페이지가 영구적으로 사라졌다.2. 요청한 페이지가 단기간 다른 페이지로 전환됐다.3. 권한 불충분으로 인해 접근이 거부되었다.4. Rest 방식에서의 URL 은 대게 리소스의 고유 값이 들어가는 데, 이 때의 비정상 접근1,2 번은 정상적인 리다이렉션이지만3,4 번은 비정상 접근에 대한 리다이렉션이므로 4xx 에러에서 다루는 게 맞는 듯하다.[301], [308] : moved permanently, permanent redirect 영구적인 페이지 이동은 301, 308 로 해결할 수 있을 것 같다. 하지만 내 눈엔 동일해보여 둘 중 누구를 선택할 지는 모르겠다. 물론 3xx 코드를 사용하는 경우, Exception 과 연관지을 생각은 없다.[302] : found location.href 등 단순 링크이동, 흔한 response.sendRedirect 의 결과이다. 직접 사용할 일은 없어보인다.[307] : temporary redirect 이벤트 또는 점검 중에 활용할 수 있을 것 같다.전체적으로 Http Header 를 Exception 관련 없이 다룰테니 ResponseEntity 를 사용하는 방법이 떠오른다.4xx 클라이언트 에러 BAD_REQUEST(400, “Bad Request”) UNAUTHORIZED(401, “Unauthorized”) FORBIDDEN(403, “Forbidden”) NOT_FOUND(404, “Not Found”) METHOD_NOT_ALLOWED(405, “Method Not Allowed”) NOT_ACCEPTABLE(406, “Not Acceptable”) REQUEST_TIMEOUT(408, “Request Timeout”) UNSUPPORTED_MEDIA_TYPE(415, “Unsupported Media Type”) I_AM_A_TEAPOT(418, “I’m a teapot”) UNAVAILABLE_FOR_LEGAL_REASONS(451, “Unavailable For Legal Reasons”)    정리클라이언트 에러를 정리해보기 전에, 우선 서버 에러 코드(5xx)를 발생시키지 않는 게 나의 명줄과 직결된 사항이라 생각한다. 가능한 예외는 모두 클라이언트의 몫이어야 된다.그리하여 4xx 에러는 상태 코드를 정리하려는 목적 중 핵심이다.[400] : bad request 잘못된 요청이라하면 어떤 게 있을까? 400번이 4xx 의 부모격이고 나머지는 400을 상속한 코드들로 보인다.[401] : unauthorized 비인가. 권한 불충분일 때, 아마 잘 막아놨다면 이는 악의적인 접근일 확률이 높다.[403] : forbidden 금지됐다하면.. 사실 비슷비슷해보이지만 계정 권환과 상관없이 URL을 조작하여 UI상 나타나지 않은 이벤트(?)를 발생시키려할 때 사용할 수 있을 것 같다. 하지만 서버에서 이를 인지하려면 현재 URL 정보를 인지하고 예외에 대한 핸들링을 해야하는데 구현하기엔 쉽지 않을 듯하다.[404] : not found PAGE NOT FOUND 즉, 매핑된 핸들러가 없는 경로 또는 공통 리소스에 접근했으나 영속 계층에 데이터가 존재하지 않는 상황에 던질 수 있다.[405] : method not allowed 메소드가 허용되지 않은 상황이 어떤 게 있을까. Validation 을 적용하였으나 바인딩 에러가 나타난 상황에 사용할 수 있을 것 같다. 다른 상황은 정말 모르겠다. 굳이 엮자면 IllegalArgumentsException 과 엮어, 결괏값과 무관하게 서비스단 호출부터 비정상적으로 이루어지는 상황에 사용하자.[406] : not acceptable Betty 프로젝트를 진행하며 계정과 권한 관련하여 시큐리티 없이 되게 신경써서 작업했는데 권한 관련 접근 제어는 이 상태 코드를 이용하면 됐을 것 같다. 우린 Rest 방식의 URL 에 회원 id 자체를 넣게 되었는데, 이건 딱히 좋지 않은 것 같다. 데이터베이스에서 기본 키 자체를 id로 지정하여 달리 방법이 없었다. 아무튼 사용자는 다른 계정의 개인 페이지 접근에 대해 호기심을 품을 수 밖에 없을 테다. 세션과 uri 비교로 막긴 했으나, 좀더 깔끔하게 처리하려면 406 코드를 사용했으면 좋았겠다.[408] : request timeout 요청 시간 초과는 서버에서 핸들링 할 수 있을까? 그것도 사용자 문제로 돌릴려면, 문자나 이메일 인증에 대한 시간 초과를 이 코드로 해결할 수 있겠다. 나의 경우는 두 인증에 대한 코드를 세션에 저장하고 세션 유지 시간을 3분으로 잡았다. 클라이언트가 인증 코드를 전송했으나 3분이 지난 경우, 즉 세션이 사라졌을 때, 408 코드를 던질 수 있겠다.[415] : unsupported media type 그대로 사용하면 될 것 같다. 필요한 영역이 확실해보인다.[418] : i am a teapot 이건 궁금해서 놔뒀다. 뭘까?[451] : unavailable for legal reasons 나쁜 이유로 불허? 이건 사실 400이나 다른 코드로 처리하면 될 것 같다. 언젠가 쓸모가 있기에 있는 게 아닐까 싶다. 5xx 서버 에러 INTERNAL_SERVER_ERROR(500, “Internal Server Error”) BAD_GATEWAY(502, “Bad Gateway”) SERVICE_UNAVAILABLE(503, “Service Unavailable”) GATEWAY_TIMEOUT(504, “Gateway Timeout”) INSUFFICIENT_STORAGE(507, “Insufficient Storage”) NETWORK_AUTHENTICATION_REQUIRED(511, “Network Authentication Required”)    정리5xx 코드를 자랑스럽게 반환할 상황이 있을까?이걸 정리하려는 것조차 자존심이 상한다.코드를 잘 짜고 서버는 수평 확장이 가능해야되지 않을까?총정리공통 예외 처리에 대한 고민으로 시작된 상태 코드 정리에 너무 몰입해버렸다. 적는 도중에 스스로 느낀 건데, 상태 코드 = Exception 라는 생각이 어느새 박혀있었다. 내가 상태코드를 정리한 이유는,ajax 에게 예외를 인지시키기 위해 Http 에 얹을 코드를 찾기 위함이고,지금 내게 상태 코드란, 서버에서 어떤 일이 일어났는가, 클라이언트의 요청을 서버는 어떻게 받아들였는가. 여기에 대한 약속이라 여겨진다." }, { "title": "16. 후기", "url": "/posts/project-betty-16-review/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:15:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기한 달 전으로 돌아간다면본격 코드 작업 이전에 팀원들이 기능 이외의불필요한 생각을 덜 하게끔 좀더 명확한 규약을 세운다.내 실력을 더 객관적으로 바라보고 아무 기능이나 다 가능하듯이 말하지 않는다.팀원들의 적극적인 회의 참여를 주도하여 핵심 기능에 대한 명세과정에서 서로 숙지할 수 있도록 이끈다.포트폴리오도 중요하지만 내 공부도 중요하다.학원 수업 시간에 혼자 작업하기보단 수업을 들을 것이다.모든 책임을 내가 지려 하지 말고 팀원을 더 믿는다.스탠다드한 Rest 방식의 데이터 송수신에 나름 익숙해졌기에생산성이 조금은 나아졌을 테니, 복잡한 로직에 욕심내고 싶다.팀장의 고충1차 프로젝트는 3명이서 진행했고 팀원들 실력이 워낙 좋다보니나는 명목상 팀장이지, 서로 의견을 내고 피드백을 하며능동적으로 맡은 파트를 해내고 다른 파트를 지원했다.최종 프로젝트는 인원부터 5명이다보니.팀장 노릇을 확실하게 할 사람이 필요했다.이땐 정말 팀장처럼 대부분의 과정을 지시했다.사람 다루는 일이 정말 힘든 거구나 새삼 또 느껴졌다.프로젝트 환경 구성 등 내 할 일을 하면서업무 지시, 깃헙 등을 함께 공부, 서비스에 대한 명세까지 했다. 몸이 두 개 였으면 하는 생각이 처음 들었다.프로젝트 기간 동안 몇번이나 그냥 그만두고 싶고,내가 왜 이렇게까지 고생해야될까혼자 생각에 잠기기도 했다.하지만 군말없이 잘 따라와주는 팀원들을 돌아봤을 때 그래도 나는 복에 겨운 팀장이구나 싶었다.차츰 팀원들이 스스로의 힘으로 결과를 보여줄 때마다나는 뿌듯했고 내가 시간을 헛되이 보내고 있진 않구나 생각했다.프론트엔드우린 템플릿을 가져와 디자인 작업을 했다.어떻게 보면 이건 실수였다.만들어져 있는 걸 가공하는 건 굉장히 어려웠다.그래도 bootstrap.css, 템플릿의 css 파일을직접 수정 하여, 전체 반영해봄으로써프론트엔드의 고충또한 알게되었다.쉬운 게 없구나 생각했고,프론트는 정말 사용자 편의를 위해서라면 끝이 없다고 느꼈다.백엔드라고 프론트엔드를 등한시할 게 아니라,프론트엔드를 기초적으로나마 이해해야 협업이 가능하다 생각한다.나중에 리액트와 서버 지식도 공부하여사이드 프로젝트로 상용 서비스를 개발해보고 싶다.기획, 요구사항, 명세기획, 설계 단계는 정말 명확해야 했다.적어도 내가 아는 모든 것을 공유해야 하고,상대가 말하는 모든 것 또한 귀담아 들어야 한다.함께 모여 공책에 끄적거리는 걸로 끝내면 절대 안 됐다.공책에 정확히 작성하든 지, 컴퓨터 앞에서 직접 타이핑하며 해야 한다.스스로 고객사라 세뇌하며 최대한 요구사항을 작성하긴 했으나,내면에선 나는 고객사가 아니라며 회피한 순간도 있었다.커뮤니케이션과 기록은 정말 중요하다.api외부 api, 여러 연동 모듈 등알고나면 굉장히 간편한 것들이지만시작이 두려워 손을 못 대는 것 같다.이번엔 시간이 턱없이 부족해서 가져와 쓴 건 별로 없다.템플릿을 가져와 사용하는 것도 어려웠고,캘린더에 간단히 표시를 하는 것조차 막막했다.하지만 하고나면 정말 별 거 아니다.이건 내 실력과 관련없이,애초에 오픈소스나 api 개발자분들이 너무 잘 만들어 놨고,가이드라인도 다 작성되어 있기 때문이다.프로젝트, 포트폴리오대학에 가지 않고 건설 등 노동일만 전전하던 내게,프로젝트라 불리우는 세련된 작업은 처음이다.난 목적, 의도를 중시하며 살기에“프로젝트라는 건 어디에 초점을 맞춰야될까” 고민이 많았다.고민 끝에 나타난 생각은 아래와 같다. 학습 내용에 대한 복습을 통한 성장 협업과 커뮤니케이션 능력 향상 기교부리지 않는 선에서 적합한 api 활용 서비스를 상용화할 지에 대한 여부우리 팀 모두가 성장하길 바랬고,끊임없는 커뮤니케이션, 깃을 활용한 협업,불필요하거나 중요치 않은 api 는 뒤로 미루고,저작권 등의 문제가 생길 수 있으므로기능 외적인 것에 대해 스트레스 받지 않도록상용화는 고려하지 않기로 했다.팀원들에게 바랬던 점대단한 건 아니지만, 그동안 스스로 공부하며 느꼈던개발 철학과 방향을 많이 공유했다.당장 아래와 같은 내용이 기억난다.스택 트레이스만 봐도 대부분의 예외를 잡을 수 있다. 데이터의 흐름을 못 따라간다면 로그를 남겨라. 커뮤니케이션은 말로만 하는 게 아니라 코드로도 해야한다. 남들이 알아볼 수 있는 코드를 작성해야 한다. 그리고 내게 뭔가 물어볼 때면,자신의 손으로 완성할 수 있도록 몇가지 포인트만 짚어줬다.떠먹여 준 것도 아니다.다들 알아서 잘 해냈다.난 그런 걸 원하기도 했다.자기주도 학습따뜻한 학원의 품을 벗어나면 찬 바람이 썡썡 불 게 뻔하다. 나는 팀원들이 스스로 공부하는 법을 배우길 바랬다.팀원의 입장이 된다면프로젝트 매니저가 처음 말 할 때 확실히 들어 둔다.내가 구상한 방향을 스케치하건 상세히 나타내어 의논한다.내 업무에 신경쓰지 않도록 믿음을 주고 싶다.책임을 나눌 수 있는 팀원이 되고 싶다.반성해야될 점암호화암호화는 단방향이어야 된다는 걸 알게 되었다.패스워드를 암호화에 Base64 를 사용했는데, 복호화가 가능하여 무의미하다는 걸 알게 되었다.쿠키에 어쩔 수 없이 회원 정보를 줘야할 때는 괜찮은 것 같다.인덱스 조회많은 도서 데이터를 활용해보고 데이터베이스 인덱스의 중요성을 또다시 느꼈다.검색이 필요할 때 반드시 인덱스 컬럼으로 찾도록 sql 을 짜야된다.예외역시 정상 로직보단 예외에 대한 경우의 수를 철저히 방어하는 게 훨씬 어려운 것 같다.적용하지 못한 기능Security적어도 내가 맡은 계정 관련해선 완벽하게 짜고 싶었지만시간과 역량이 부족했던 것 같다.중복 회원 관련 세션 관리조차 하지 못했다.Batch게시판 글 목록,체크아웃 하지 않고 간 회원두 가지 처리를 배치로 하고 싶었다.Web Socket회원 대여 예약 시, Staff 에게 알림을 보내고 싶었다.돈 계산 로직 어떤 프로젝트를 할 지 결정할 떄부터,돈 계산이 많은 프로젝트를 하고 싶었다. 중고 거래 플랫폼이나 쇼핑몰을 떠올렸는데팀원이 도서관 얘기를 꺼내서 대여료 관련해서 넣자고 생각했다.구현은 했으나 지표를 좀더 다양히 보여주는 건 시간이 부족했다.최근 본 도서 목록쿠키를 통해서 최근 본 도서 목록을 우측 네비게이터에 넣고 싶었다.관리자의 다양한 기능관리자 페이지에서자유게시판 말머리,멤버십 가입비,멤버십 별 혜택 등을 수정할 수 있도록 테이블을 만들었으나이또한 시간이 부족했다.느낀 점다 적고나니 정말 지친다.원래는 원대한 계획을 갖고 있었는데,최종 프로젝트가 끝나면 스프링 부트와 JPA 환경으로 갈아 끼우는 거다.데이터베이스 관련 설정만 좀 건드리면 될 것 같았지만동적 쿼리가 많은 Betty 소스를 단순히 JPA 로 바꾸고 싶다 하여 기능을 구현할 수 없을 것 같다.아마도 QueryDSL 이란 걸 배워야 될 듯하다.부트 환경으로도 섵불리 못하겠는 건,취업 준비와 함께 만지기엔 시간이 많이 소요될 것 같다.스프링 부트 공식 문서도 열심히 들여다보고 있을 게 뻔하기 때문이다.참고한 부분이번 포트폴리오에서 굉장히 큰 도움을 받은 블로그Yun Blog해당 페이지 이외에도 눈여겨 볼 포스트들이 굉장히 많다.모든 도서 관련 자료들은 알라딘 사이트를 참고하였습니다." }, { "title": "15. DTO, Form, VO, Entity", "url": "/posts/project-betty-15-object/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:14:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기 도대체 뭐가 뭔지? 어떻게 사용할까?VO, ENTITY - 뭐가 다르지?처음엔 얘네들을 사용하자 말을 꺼내기 전에 고민이 많았다.우선, 그냥 VO 면 되지 않을까? 였다.Entity 라는 말은 JPA 강의에서 처음 들었는데 이게 VO 와 다른 게 무엇인가 하는 의문이 들었다.검색을 토대로, 테이블을 모델로 한 객체라고 생각 했는데학원 수업에서 다루는 VO 의 역할과 다름이 없었기 때문이다.JPA 를 사용할 땐, 이 VO 에 테이블 관련 어노테이션을 선언하고이를 Entity 라고 부르는 것을 봤었다.이러면 제법 Entity 같긴 하다.그래서 난 Betty 에서 VO 와 Entity 를 구분하지 않았고,뭐 굳이 따지면 Entity 쪽에 손을 들었다.class 명을 단순히 ‘Member’ 와 같이 짓고 @Getter, @Builder 만을 열어놓았다.Entity 얘기가 나와서 하는 말인데 처음엔 도메인 주도 개발을 적용해보고 싶었다. 대여 관련한 로직에서 Entity 에 메소드를 선언하여 신나게 Service 단을 감량시키려 했는데, 대부분 데이터베이스 내부 로직으로 처리된 게 아쉽다. DTO - 왜 사용해야 될까?DTO 는 Model 에 담고 JSP 에 렌더링하는 형태의서버 사이드 렌더링이라면, 사실 필요한 때가 별로 없어 보인다.나름의 이유라면, 굳이 객체를 하나 더 생성하는 것 아닌가?어짜피 문서를 다 그리고 난 뒤 보낼 텐데 별반 차이 없을 것 같다.하지만 ajax 를 사용할 떄, 데이터만 받아클라이언트 측에서 렌더링 한다면 이야기가 달라졌다.애초에 주고 받는 객체도 사실 바이트 코드 아닌가?객체(데이터)를 주고 받는 비용이 든다.여기서 매번 VO에 모든 데이터를 담아 보내고,클라이언트 측에서 이를 수신한다면.. 좀 찝찝하다.개발자라면 상시 사용자 편의를 고려해야된다고 생각한다.이걸 네트워크 비용이라고 하면 될까?데이터를 주고 받는 비용을 줄이는 게 좋지 않을까?이러한 이유로 난 DTO 도입에 대한 합리성을 얻었다.Form - DTO 랑 무슨 차이인가?이제 검증을 위한 Form 객체도 정의하게 되었는데,Form 객체를 굳이 구분한 이유는 아래와 같다.(내 머릿속에서 Form 은 DTO 의 자식 느낌이다.) DTO 는 응답 위주로 사용하고 싶다. DTO 에 Validation 을 적용하고 싶지 않다. html form 태그에서 넘어오는 객체를 명확히 구분 짓고 싶다.그래서 나온 결과는 아래와 같다.Validation 을 거친 뒤 encode, convert 메소드를 호출한다.convert 내부에서 암호화를 수행해도 되지만,정말 혹시나 해서 굳이 분리해두었다.“DTO 에 아무 메소드도 정의되지 않아야 한다.”“DTO 는 행위를 갖지 않는다.”라고 누군가 말하겠지만, 세상에 정해진 일이 어디있는가? 결과적으로 Betty 에서는 이렇게 요약된다.form : form 양식을 전달 받는 객체dto : 변경이 가능한 데이터 응답용 객체entity : 불변성을 갖는 영속 계층(db와 직결된)의 객체DTO 는 언제 생성되야 할까?Entity -&gt; DTO 변환은 어디서 이루어져야 하는가?이건 내 생각엔 단연 Service 계층이다.정확히는 데이터베이스에서 read 되어 반환된 순간이다.DTO 는 렌더링에 필요한 데이터 관련 필드만 정의되어 있을 것이다.이 시점에서 이미 끝난 이야기인 게,이 DTO 의 명칭 또한 제시되어 있을 것이고,데이터 가공 시 클래스 이름을 통해 용도까지 파악할 수 있다.가능한, 빠른 타이밍에 변환하는 게 무조건 이롭다고 여겨진다.애초에 DTO 를 꺼내면 안될까?이런 생각도 든다.데이터베이스에서 꺼낼 때 애초에 DTO 로 꺼내면 안되나?ORM 에 대해선 아직 자세히 모르고, Mapper 는 마이바티스 덕에 좀 안다.위 질문에 대해선, 우선 난 그냥 싫다.원하는 컬럼만을 꺼내는 메소드를 모두 만든다면Repository 클래스의 코드가 매우 길어진다.많아지고 볼품 없다.게다가, 그 각각의 행위를 모두 알고 있어야 될까?난 좀 귀찮더라도 대용량 컬럼이 존재하는 게 아닌 이상,레코드 하나를 꺼내서 가공하는 편이 차라리 속 편하다.Repository 에 적히는 SQL 이야 사실 자바 코드긴 하다만,난 어쨌든 데이터베이스에 의존하는 듯한 그림이 싫다." }, { "title": "14. 지식 공유 - ajax", "url": "/posts/project-betty-14-edu-ajax/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:13:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기 ajax 로 hello world 는 할 줄 알아야지처음 ajax 를 통해 서버와 통신하며 겪은 시행착오에 대한 내용이다.팀원들에게도 알려주려고 여러 경우의 수를 추가하여 작성했다.@RequestBody아무 것도 모를 때일단 편하게, 생각나는대로 해보자.json 객체를 선언하고,key 에는 쌍따옴표를 생략해도 된다고 했고,post 방식. 자주 사용하던 것부터 해봐야지.json 객체를 그대로 보내고,@RequestBody 로 받으면 되겠지?&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : data});&lt;/script&gt;@PostMapping(\"uri\")public void test(@RequestBody String code){\tSystem.out.println(code) \t출력 ==&gt; \"code=text\" // 원하는 결과가 아님}기본 컨텐츠 타입인 “application/x-www-form-urlencoded” 이JSON 객체를 “code=text” 로 변형시켰고,payload 를 그대로 읽는 @RequestBody 는 String 타입의 변수에payload 의 값을 그대로 전달했다.Content-type 이 문제인가?요즘 데이터는 json 으로 주고 받는게 대세라고 했는데,컨텐츠 타입을 지정해주지 않아서 이런 결과가 나왔겠지?&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : data,\tcontentType : \"application/json\",});&lt;/script&gt;@PostMapping(\"uri\")public void test(@RequestBody String code){\tSystem.out.println(code) \t출력 ==&gt; \"code=text\" // 원하는 결과가 아님}\tRequestResponseBodyMethodProcessor \t- Read \"application/json;charset=UTF-8\" to [\"code=text\"]로그엔 이렇게 나타난다.여기에 대해선 나도 의문이 있다.json 타입인걸 명시했는데 왜 기본 타입과 동일한 결과 나타나는 것일까?많은 생각이 드는데,JSON 객체를 전송한 거지, JSON 형태의 문자열을 보낸 게 아니다.“application/json” 은 payload 의 정보를 제공한 건 맞지만,payload 의 변형을 불러일으킨 건 아니다.컨텐츠 타입과 상관없이 JSON 객체는 HTTP 프로토콜로 데이터가 옮겨질 때,이미 “code=text” 형태로 지정된 것 같다.이 구조에서 컨텐츠 타입은 서버에서어떤 메시지 컨버터를 사용하여 요청 데이터를 해석할 지에 대한 힌트인 것 같다.객체가 아닌 문자를 보내야되나?stringify 라는 메소드를 본 것 같은데,,,,&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : JSON.stringify(data),\tcontentType : \"application/json\",});&lt;/script&gt;@PostMapping(\"uri\")public void test(@RequestBody String code){\tSystem.out.println(code) \t출력 ==&gt; {\"code\":\"abc\"} // 원하는 결과가 절대 아님}여기까진 전부 String 타입에 @RequestBody 를 그대로 넣고 있다.“data : “ 에 JSON 객체를 보내냐, JSON 형태의 문자열을 보내냐에 따라등호와 콜론이 스위치 되고 있다.문자열을 보냈으니 컨텐츠 타입을 제거?JSON 형태의 문자열을 보낸 거라 JSON 객체가 아니라서 그럴까?&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : JSON.springify(data)});&lt;/script&gt;@PostMapping(\"uri\")public void test(@RequestBody String code){\tSystem.out.println(code) \t출력 ==&gt; \"%7B%22code%22%3A%22text%22%7D=\"\t// 원하는 결과가 절대 아님}이 결과는 뭔가 여태까지의 실험을 다 부정당하는 느낌이다.이건 진짜 URL 인코딩이다.내 수준이 아직 바닥임을 알 수 있다.어디서 이 인코딩이 적용된 건지,위의 내용들은 어쩄든 모두 json 형태로 해석된 건지.당장 알 수가 없다.계속 문자가 순수하게 출력되네? 그러면 text?&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : \"text\",\tcontentType : \"application/json\",});&lt;/script&gt;@PostMapping(\"uri\")public void test(@RequestBody String code){\tSystem.out.println(code)\t출력 ==&gt; text // 원하는 결과}이건 사실 생각보다 특수한 상황이다.@RequestBody 와 String 타입 매개변수가 하나만 존재하는.그냥 문자열을 그대로 받을 수 있다.쓸모없어보이는데? 이걸 어디쓰지?테스트는 간단하게 하자는 나쁜 습관 때문에,문자열만을 주고 받는 심플한 상황을 연출했지만데이터를 주고 받을 때 json 형식의 문자열을 주고받는 데 익숙해져야 된다.@Setter @Getter\tstatic class Data {\t\tString code;\t}(컨트롤러 클래스 내부에 정적 멤버 클래스를 선언했다)&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : \"text\",\tcontentType : \"application/json\",});&lt;/script&gt;@PostMapping(\"uri\")public Data testData(@RequestBody Data data) HttpMessageNotReadableException: JSON parse error:예외가 터진다.String 일 때는 key 여부 상관 없이 들어갔지만,객체의 필드에 바인딩 시키기 위해선 JSON 형식을 넘겨야 된다.객체에는 객체를 넘겨야 정상이지자 그럼, 객체를 주고 받고, json 타입을 명시해준다면 되지 않을까?&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : data,\tcontentType : \"application/json\",});&lt;/script&gt;@PostMapping(\"uri\")public Data testData(@RequestBody Data data) HttpMessageNotReadableException: JSON parse error…..예외가 터진다.여기까지 봤다면 JSON 객체가 payload 에 실릴 때어떤 형식으로 변환되는 것을 알 수 있다.자바에서 배웠던 ObjectStream 이 생각난다.헤더같은 게 덧붙어서 이런 결과가 일어나는 것 같다.JSON 객체를 문자열로 변환하면?&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : JSON.stringify(data),\tcontentType : \"application/json\",});&lt;/script&gt;@PostMapping(\"uri\")public Data testMulti(@RequestBody Data data) { System.out.println(data.getCode()) 출력 ==&gt; text // 완전 원하던 결과}정리 RequestBody 는 순수한 텍스트를 읽어준다.하지만 다양한 메시지 컨버터들에 치여 예상치 못한 결과가 나타나기도 한다.텍스트 자체를 전달하고 싶다면, 객체를 보낼 게 아니라 값만 전달해야 된다. 객체를 전달하고 싶다면 클라이언트 측에서 stringify 메소드를 사용해야 된다.RequestBody 의 역할은 JSON 타입 자체의 해석이 아닌, JSON 형태의 문자열을 해석해주고Jackson 라이브러리의 힘을 빌려 필드에 바인딩 해주는 것. json 형태의 문자열은 일반 문자열과 구분할 수 없다.클라이언트 측에서 메시지 바디에 들어갈 문자열이 json 타입임을 선언해줘야하는데, 이 바디에 대한 정보를 알려주는 HTTP 프로토콜의 영역이 Header 이다.Header 의 내용 중 하나가 Content-type 인데Content-type 은 HTTP 바디가 어떤 MIME 타입임을 알려준다.그래서 Content-type 이 “application/json” 인 문자열을@RequestBody 와 jackson-databind 가 해석 후 인자에 바인딩한다.(참고로 http message body 는 payload 라고도 불리는 걸로 알고 있다.) @RequestParamajax는 ajax인데,, ajax는 json 통신 아닌가?(@RequestParam 의 경우 생략 가능한 어노테이션이다.)컨텐츠 타입을 명시하지 않았을 때ContentType 명시하지 않을 시 기본 값 : application/x-www-form-urlencoded&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : data,});&lt;/script&gt;@PostMapping(\"uri\")public void test(Data data){\tSystem.out.println(data.getDate()) \t출력 ==&gt; text // 바로 성공}@RequestBody 에서 컨텐츠 타입을 명시하지 않고 JSON 객체를 보냈을 때를 생각해보면“code=text” 라고 나왔다.근데 이건 사실 @RequestParam 이 아닌 @ModelAttribute 다.컨텐츠 타입을 json으로 지정했을 때&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tcontentType: \"application/json\",\tdata : data,});&lt;/script&gt;@PostMapping(\"uri\")public void test(Data data){\tSystem.out.println(data.getCode()) ==&gt; null}컨텐츠 타입이 json 인데 @RequestBody 를 사용하지 않았다.게다가 stringify 함수를 사용하지도 않았다.바인딩 실패.순수 text를 전달했을 때아까처럼 String 타입에 urlEncoded 를 사용하여 text 자체만 보내보자.$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : \"text\",});&lt;/script&gt;@PostMapping(\"uri\")public void requestParam(String code){\tSystem.out.println(code) \t출력 ==&gt; null // 어림도 없다.}드디어 @RequestParam 이 적용되는 부분이다.하지만 ReqeustParam 은 Key=value 형태로 넘겨야 받을 수 있다.다시 JSON 객체를 넘긴다면?&lt;script&gt;let data = { code : \"text\"};$.ajax({\ttype : \"post\",\turl : \"${path}/uri\",\tdata : data,});&lt;/script&gt;@PostMapping(\"uri\")public void requestParam(String code){\tSystem.out.println(code) \t출력 ==&gt; text}간단 요약json 형태의 문자열을 보내고 싶다면@RequestBody 를 이용하라JSON 객체를 보내고 싶다면@RequestBody 를 우선 생략하라JQuery.ajax$.ajax({ url: '${path}/plz', // HTTP Method GET, POST, PUT, PATCH, DELETE type: 'put', // json 객체 let code = { \"code\" : \"code\" }\t// 보내고 싶은 데이터 data: code, // 요청 데이터의 컨텐츠 타입을 지정 // Get 요청의 경우 메시지 바디가 아닌 쿼리 파라미터로 전송 // @RequestBody 가 해석할 수 없음. contentType: \"application/json\", \t// 응답 데이터의 컨텐츠 타입을 지정\t// Accept를 application/json 으로 변경\t// json 일 경우, 서버에서 @ResponseBody 를 사용 dataType: 'json', success: function(result){ $('.bookName').val(result.content); }\t// 상태코드가 4xx, 5xx 일 때 실행됨 error: function(error){ console.log(error);})$.ajax() 는 반환값이 있다.바로 jqXHR 이라는 객체인데,$.ajax().done, .fail, .always 등의 메소드를 사용할수 있다." }, { "title": "13. about ajax", "url": "/posts/project-betty-13-ajax/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:12:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기ajax 에 대한 견해약속ajax 를 통한 데이터 송수신은 엄격한 약속으로 이루어졌다.예외 처리의 경우 위 특징이 극명하게 드러났다. 아직 제대로 구현해보진 않았지만 “C001” 같은 코드를 통해분기문을 수행하는 걸 떠올려보면 약간은 두렵다.비동기비동기 방식으로 데이터만을 주고 받는다 생각하고 사용했지만꼭 여기에 매몰될 필요도 없었다. 내 경우는 변수를 미리 선언해두고 반환 값을 이용하려 했던 적이 있는데비동기 방식으론 정상적인 수행을 기대할 순 없었다.이 때는 ajax 를 그대로 사용하되, 동기화 시켰다.리소스페이지 전환 없이 데이터만을 주고 받는다는 이점이 있지만, 또 불필요한 데이터까지 받는 다면 뭔가 이상하다. 물론 이것만으로도 자원 낭비를 줄일 수 있을 것이다.하지만 dto 를 적극 활용하여 이러한 비용 절약을 극대화 할 때 ajax 의 진가가 나타날 것이라 생각한다.리다이렉트전형적인 POST method 를 활용한 통신에서, ajax 를 사용했을 땐 javascript 문법으로 location 을 조작하여중복 호출이 일어나지 않게 막았다.사용자 편의도서 상세 검색을 포함한 다양한 조건 검색에선, 사용자 편의랍시고 ajax 를 꼭 써야되는 것도 아니였다. url 상 쿼리 파라미터로 나타나는 검색 조건에 대해 숨길 필요가 없었다.웹앱모바일앱으로 넘어간다면 이야기는 달라지겠지만 아직까지 웹앱 밖에 다뤄본 적이 없는 지라 ajax 는 꼭 필요한 건 아니지만, 분명 장점이 상당히 많은 기능인 것은 알 수 있었다.렌더링을 자바스크립트를 통한 요소 또는 노드 조작으로 진행하여, 프론트 전반적으로 기본은 할 줄 알아야겠다 싶었고, 이번 프로젝트에서 나름 제대로 복습하는 시간을 가졌다고 생각된다." }, { "title": "12. 오프라인 관련", "url": "/posts/project-betty-12-offline/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:11:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기나름 뿌듯했던 체크인 좌석 출력파트다.오랜만에 2중 for 문을 사용하여 추억을 환기했던 시간이다.이 파트 하나로템플릿 리터럴, ajax 동기화 처리, js, jquery 에 대한 이해도가 대폭 상승했다.오프라인 화면앞으로 소개할 건 네모 박스 하나에 빨간색 배경을 입히기 위한 작업들이다.체크인과 체크아웃$('#checkInBtn').on('click',function(){\t\t\tlet seat = $(this).data('seat');\t\t\t $.ajax({ type: 'post', url: \"${path}/offline/${user.id}/checkIn\", data: { seat : seat }, success: function(data){ alert(\"클라이언트 요청 \"+ seat + \" 서버 응답 \"+ data); location.reload(); }, error: function(data){ alert(\"요청실패\"); } })})$('#checkOutBtn').on('click', function(){ $.ajax({ type: 'post', url: '${path}/offline/${user.id}/checkOut', success: function(data){ alert('서버 응답 : '+ data); location.reload(); }, error: function(data){ alert('요청 실패' + data); } })})@PostMapping(\"checkIn\")@ResponseBodypublic int checkIn(@PathVariable String id, Integer seat) { int result = os.checkIn(id, seat); return result;}@PostMapping(\"checkOut\")@ResponseBodypublic int checkOut(@User Member user) { int result = os.checkOut(user.getId()); return result;}Restful 방식으로 구성하고 싶었으나 단순 CRUD 이외의 영역엔 머리가 안 따라줬다.체크인 버튼을 누르면 chk_real 테이블에 기입되고체크아웃 버튼을 누르면 chk_real 에서 삭제와 동시에 chk_log 테이블에 추가된다.이는 DB 트리거로 구성되어 있다.Delete 방식의 전송을 사용하면 될 것 같은데,뭔가 애매한 게, 체크인 체크아웃이란 단어에 너무 매몰되어 그런 것 같다.Rest 에 집착하는 내 모습에 대해 생각이 많다.하나의 테이블에서 이루어지는 게 아닌,연관 관계가 이루어진 테이블에 대해 다룰 때 이런 생각이 드나 보다.본격 스터디존(체크인 상황) 출력우선 날코드에 주석을 달아보자&lt;script&gt; $(function(){\t\t // 세션에 저장된 사용자가 체크인 중인 지 판별한다. let checkUserCheckIn = checkReal();\t\t // 1 ~ 16 까지의 table 을 그린다. initRoom(); // 그려진 table 에 전체 체크인 목록을 가져와 빨간색 배경을 칠한다. initSeats();\t\t // 좌석 박스를 클릭했을 때 active 상태로 변경시킨다. $('.seat .able').on('click', function(){ // 현재 사용자가 체크인 중이라면 아무 이벤트를 발생시키지 않고 종료. if(checkUserCheckIn) return; // 빨간색 배경이 칠해졌거나, 이미 체크한 좌석일 때 공석으로 전환 if($(this).hasClass(\"disabled\") || $(this).hasClass(\"active\")){ $(this).removeClass(\"active\"); return; }\t\t\t // 정상적으로 공석을 선택했을 때 active 상태로 전환 $(this).addClass('active'); // 체크인 버튼의 data-seat 속성에 좌석 번호를 넣는다. let seat = this.innerText; $('#checkInBtn').data('seat', seat); }) })\t function initRoom(){ // table let room = \"\"; // tr let row = \"\"; // td let cell = \"\"; // 4개의 행을 그린다. for(let i = 0; i &lt;= 3; i++){ // 행과 셀의 매개 변수다 let k = i * 4; // 셀을 그리는 작업을 4회 반복한다. for(let j = 1+k; j &lt;= 4+k; j++){ // 2, 5번 째 칸을 빈 칸으로 만드는 분기문 if(j==(1+k) || j==(3+k)){ // 템플릿 리터럴 내부에 js 변수를 사용한다. // jsp el 과의 충돌 때문에 escape 작업('\\')이 필요하다. cell =`&lt;td class=\"able\" value=\"\\${j}\"&gt;\\${j}&lt;/td&gt;`; cell +=`&lt;td&gt;&lt;/td&gt;`; } else{ cell =`&lt;td class=\"able\" value=\"\\${j}\"&gt;\\${j}&lt;/td&gt;`; } // 셀을 그릴 때 tr 에 바로바로 추가해준다. append 와 비슷하다. row += cell; } // 하나의 tr 이 완성되면 table 에 append 한다. room = `&lt;tr&gt;\\${row}&lt;/tr&gt;`; $('#room').append(room); // row 를 blank 로 초기화하지 않으면 매 행 누적 된다. row = \"\"; } }\t\tfunction initSeats(){ // 좌석 상황을 불러 온다. $.getJSON(\"${path}/offline/${user.id}/room\", // data 는 체크인 중인 좌석 목록으로, List&lt;Integer&gt; 이다. function(data){ // td 의 value 가 체크인 중인 좌석 번호와 동일하다면, // 공석 상태를 제거하고 빨간색 배경을 칠해준다. $(data).each(function(i,e){ $(`td[value='\\${e}']`).switchClass('able', 'disabled'); }) })\t}\t\tfunction checkReal(){ // 체크인 여부를 return 하기 위한 변수다. let isReal = \"\"; $.ajax({ // isReal 을 정상적으로 반환하기 위한 동기화 설정 async: false, type: \"get\", url: \"${path}/offline/${user.id}/checkReal\", dataType: 'json', success: function(data){ // true or false 를 반환한다. isReal = data; } }) return isReal;\t}&lt;/script&gt;물론 허점은 많다.active 시켰을 때 플래그를 세워 다른 공석을 선택할 수 없게 만들거나,active 된 좌석이 있을 때 다른 공석을 선택한다면 active 상태이던 좌석을 해제시키는그런 귀여운 로직이 더 필요하다.하지만 이건 그저 노동일 뿐이므로 우선 생략했다.오랜만에 이중 for 문을 써보고 템플릿 리터럴 안에 변수를 우겨 넣고 그런 건 중요하지 않다.여기서 제일 큰 소득은 ajax 의 응답 데이터로 하여금 반환값을 전달하려할 때,동기화 설정을 적용했다는 거다.ajax 는 비동기 통신이다. 라는 강박에서 벗어난 계기다." }, { "title": "11. 대여 관련", "url": "/posts/project-betty-11-rental/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:10:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기대여 예약, 수령, 반납에 대한 내용이다.“시간적 여유가 있었으면” 하는 아쉬움이 남아있다.도서 예약$('#reservBtn').on('click', function(){ let isbn = '${book.code}'; let memberId = '${user.id}'; let date = $('#reserv').val(); let data = { \"memberId\" : memberId, \"isbn\" : isbn, \"date\" : date }; if(date == ''){ return; } else { $.ajax({ type: 'post', url: '${path}/rentals/reserve', contentType: 'application/json', data: JSON.stringify(data), dataType: 'json', success: function(data){ alert(data.id+ ' 님의 예약 완료'); }, error: function(request,status,error){ alert(\"fail\"); }\t }) } })@PostMapping(\"reserve\")@ResponseBodypublic ReserveBook reserve(@RequestBody ReserveBookDto reserveBookDto) { Integer num = bs.findExistNum(reserveBookDto.getIsbn()); ReserveBook reserve = reserveBookDto.createReservBook(num); int result = rs.reserveBook(reserve); return reserve;}도서 상세 게시글에서의 대여 예약 장면과이벤트 핸들링이다.필요한 정보를 가져와 post 방식으로 비동기 요청을 보낸다.방법이야 가지각색이지만 json 형태로 시도했다.json 형태를 받기 위해 @RequestBody 와 Dto 객체를 이용했다.(쿼리문은 기본 CRUD 수준이라 설명은 생략) 도서의 재고가 존재하는지 확인 대여 예약 테이블에 Insert반환을 대여 예약 객체로 했는데 딱히 사용하진 않았다.ajax 를 사용하면서 가장 힘들었던 건,무엇을 반환하고 무엇을 출력해줄까에 대한 스트레스였다.. 그냥 숫자 하나를 반환하고 예외 처리만 잘해주는 게 세상 편한 느낌이다.도서 수령&lt;form action=\"${path}/offline/${user.id}/receipt\" method=\"post\"&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th colspan=\"3\"&gt;도서명&lt;/th&gt; &lt;th colspan=\"2\"&gt;예약일&lt;/th&gt; &lt;th&gt;수령&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:choose&gt; &lt;c:when test=\"${!empty reserves}\"&gt; &lt;c:forEach var=\"reserve\" items=\"${reserves}\"&gt; &lt;tr&gt; &lt;td colspan=\"3\"&gt;${reserve.title}&lt;/td&gt; &lt;td colspan=\"2\"&gt;&lt;f:formatDate value=\"${reserve.date}\" pattern=\"yyyy-MM-dd\" /&gt;&lt;/td&gt; &lt;td&gt; &lt;button class=\"btn btn-danger btn-sm\" name=\"code\" value=\"${reserve.code}\"&gt;수령&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;tr&gt; &lt;td colspan=\"6\"&gt;대여 예약된 책이 없습니다.&lt;/td&gt; &lt;/tr&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/form&gt;@PostMapping(\"receipt\")@Transactionalpublic String rentalReceipt(@PathVariable String id, rentalDto rsv) { String code = rsv.getCode(); rs.reserveCancle(id, code); Integer num = bs.findExistNum(code); rs.rentalBook(id, code, num); MemberCard mc = ms.findGradeById(id);\t\t ms.updateLend(id, mc.getPremiumGrade());\t\t return \"redirect:/offline/\"+id;}오프라인 화면은 나름 Betty 의 시그니쳐이다.사용자가 “실제”로 도서관에서 할 수 있는 행위 중 최소한을 화면에 그렸다.수령 버튼 자체에 ISBN 을 담고, 유저 아이디는 경로 변수에 담았다.대여에 필요한 정보는 사실 이게 끝이다.서버 쪽 로직은 미숙한 것 같지만Betty 는 더이상 손 볼 생각이 없기 때문에 이거로 만족해야겠다. 대여 예약 테이블에서 삭제하고, 다시 도서 코드를 통해 실물 재고를 확인하고, 대여 중 테이블로 옮기고, 멤버십 카드를 통해 대여료를 지불한다.이후 다시 오프라인 화면으로 리다이렉트 시킨다.도서 반납대여 예약 후 수령이 완료된 도서는 이렇게 반납 해야될 목록에 나타난다.로직은 도서 수령 쪽과 거진 동일한 수준이다." }, { "title": "10. 도서 관련", "url": "/posts/project-betty-10-book/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:09:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기도서 목록 출력과 상세 검색에 관한 내용이다.코드가 너무 많아졌는데 최대한 줄이려 노력했다…검색했을 때의 url도서 목록 화면에서의 검색도서 목록 페이지에서장르를 지정하지 않고 여행을 검색한 뒤 5페이지로 가서 특정 도서 상세글로 이동하였을 떄의 url 이다.\"http://localhost:8080/betty/books/9791190073158?page=5&amp;perPageNum=8&amp;searchOption=title&amp;searchText=%EC%97%AC%ED%96%89&amp;auth=&amp;pub=&amp;pubDate=&amp;genre=\"Home 화면에서의 상세 검색Home 화면의 상세 검색을 수행하고 특정 도서 상세글로 이동하였을 때의 url 이다.http://localhost:8080/betty/books/9788932916804?page=1&amp;perPageNum=8&amp;searchOption=title&amp;searchText=%EB%8F%88%ED%82%A4%ED%98%B8%ED%85%8C&amp;auth=%EB%AF%B8%EA%B2%94&amp;pub=%EC%97%B4%EB%A6%B0&amp;pubDate=2013-05-29&amp;genre검색 조건은 차이나지만, 검색을 위한 객체는 하나로 사용하기에url 에 불필요한 텍스트가 많이 나타난다. 분리하려면 도서 목록 페이지에 변화가 생기거나,상세 검색을 위한 modal 을 따로 만드는 작업이 필요할 것 같아하나로 놔두기로 했다.도서 목록을 가져오기 위한 객체public class BookCriteria extends Criteria {\t\t{ this.setPerPageNum(8); }\t\tprivate String genre;\tprivate String searchOption;\tprivate String searchText;\tprivate String auth;\tprivate String pub;\tprivate String pubDate;\t\t\tpublic BookCriteria(int page, int perPageNum, \t\t\tString genre, String searchOption, String searchText) {\t\tsuper(page, perPageNum);\t\tthis.genre = genre;\t\tthis.searchOption = searchOption;\t\tthis.searchText = searchText;\t}\tpublic BookCriteria(int page, int perPageNum, \t\t\tString searchOption, String searchText, String pub, String pubDate) {\t\tsuper(page, perPageNum);\t\tthis.searchOption = searchOption;\t\tthis.searchText = searchText;\t\tthis.pub = pub;\t\tthis.pubDate = pubDate;\t\tthis.auth = auth;\t}\t}검색 조건을 필드에 저장하여 동적 쿼리에 쓰이는 객체다.부모 클래스인 “Criteria” 에는 현재 페이지와 페이지 당 출력 개수를 위한 필드가 존재한다.페이지네이션을 위한 객체public class BookPageMaker extends PageMaker{\t\tpublic BookPageMaker(BookCriteria cri, int count) {\t\tsuper(cri,count);\t}\t\t@Override\tpublic String makeQuery(int page) {\t\tBookCriteria bcr = (BookCriteria)super.getCri();\t\tUriComponents uri = UriComponentsBuilder.newInstance()\t\t\t\t.queryParam(\"page\", page)\t\t\t\t.queryParam(\"perPageNum\", bcr.getPerPageNum())\t\t\t\t.queryParam(\"searchOption\",bcr.getSearchOption())\t\t\t\t.queryParam(\"searchText\",bcr.getSearchText())\t\t\t\t.queryParam(\"auth\",bcr.getAuth())\t\t\t\t.queryParam(\"pub\", bcr.getPub())\t\t\t\t.queryParam(\"pubDate\", bcr.getPubDate())\t\t\t\t.queryParam(\"genre\",bcr.getGenre())\t\t\t\t.build();\t\treturn uri.toUriString();\t}}쿼리 파라미터를 만들어주는 메소드이다.부모 클래스인 PageMaker 의 연산 메소드public void calcPaging() {\t\t\t\tendPage = (int)Math.ceil(cri.getPage()/(double)displayPageNum)*displayPageNum;\t\t\t\tstartPage = (endPage - displayPageNum)+1;\t\t\t\tmaxPage = (int)(Math.ceil(totalCount/(double)cri.getPerPageNum()));\t\t\t\tif(endPage &gt; maxPage)endPage = maxPage;\t\t\t\tfirst = startPage &gt; 1 ? true : false;\t\t\t\tlast = (cri.getPage() &lt; maxPage) ? true : false;\t\tprev = (endPage - displayPageNum &lt;= 0) ? false : true;\t\t\t\tnext = (endPage == maxPage) ? false : true;\t\t\t}페이지네이션 연산을 위한 메소드이다.“1 2 3 4 5” 같은 페이지 번호를 출력하는 연산과“6 7 8 9 10” 과 같이 다음 페이지로의 이동 버튼을 출력하는데 사용된다.BookServicepublic class BookService {\t\tpublic void bookList(BookCriteria cri, Model model) {\t\tint totalCount = bookRepository.findAllCount(cri);\t\tBookPageMaker pageMaker = new BookPageMaker(cri, totalCount);\t\tList&lt;Book&gt; list = bookRepository.findAll(cri);\t\tmodel.addAttribute(\"list\", list);\t\tmodel.addAttribute(\"pm\",pageMaker);\t}}검색을위한 BookCriteria 객체를 이용하여,도서 테이블의 총 행 개수를 가져와 페이지네이션을 위한 객체를 생성한다.다시 BookCriteria 객체를 이용하여 도서 목록을 가져온다.model 에 함께 담아 jsp 페이지에서 해석할 수 있도록 만든다.BookProviderpublic class BookProvider {\tpublic String findAll(BookCriteria cri) {\t\tSQL sql = new SQL();\t\tsql.SELECT(\"*\").FROM(BOOK_TBL);\t\tbookListResolver(sql, cri);\t\tif (cri != null) {\t\t\tsql.OFFSET(\"#{startRow}\");\t\t\tsql.LIMIT(\"#{perPageNum}\");\t\t}\t\treturn sql.toString();\t}\tpublic String findAllCount(BookCriteria cri) {\t\tSQL sql = new SQL();\t\tsql.SELECT(\"count(*)\").FROM(BOOK_TBL);\t\tbookListResolver(sql, cri);\t\treturn sql.toString();\t} private void bookListResolver(SQL sql, BookCriteria cri) {\t\tif (cri.getSearchText() != null) {\t\t\tswitch(cri.getSearchOption()) { case \"title\": sql.WHERE(\"title LIKE CONCAT('%',#{searchText},'%')\"); break; case \"auth\": sql.WHERE(\"auth LIKE CONCAT('%',#{searchText},'%')\"); break; case \"intro\": sql.WHERE(\"intro LIKE CONCAT('%',#{searchText},'%')\"); break;\t\t\t\t\t\t\t}\t\t}\t\tif (cri.getGenre() != null &amp;&amp; cri.getGenre() != \"\") {\t\t\tsql.WHERE(\"genre = #{genre}\");\t\t}\t\tif (cri.getAuth() != null &amp;&amp; cri.getAuth() != \"\") {\t\t\tsql.WHERE(\"auth LIKE CONCAT('%',#{auth},'%')\");\t\t}\t\t\t\tif (cri.getPub() != null &amp;&amp; cri.getPub() != \"\") {\t\t\tsql.WHERE(\"pub LIKE CONCAT('%',#{pub},'%')\");\t\t}\t\t\t\t\t\t\tif (cri.getPubDate() != null &amp;&amp; !cri.getPubDate().trim().equals(\"\")) { \t\t\tTimestamp pubDate = Timestamp.valueOf( cri.getPubDate() + \" 00:00:00\" );\t\t\tString date = new SimpleDateFormat(\"yyyy-MM-dd\").format(pubDate);\t\t\tsql.WHERE(\"pub_date &gt;= '\" + date + \"'\");\t\t}\t\t\t}}검색 객체를 사용한 동적 쿼리다.findAll, findAllCount 에 들어갈 조건이 동일하기 떄문에코드 조각을 하나의 메소드로 옮겼다.출판일인 pubDate 는 사실 타임스탬프 변환 과정이 무의미하고문자열 그대로 넣게 해도 상관없다.도서 목록 출력부&lt;c:choose&gt;\t\t\t\t &lt;c:when test=\"${!empty list}\"&gt; &lt;div class=\"row row-cols-md-4\"&gt; &lt;c:forEach var=\"board\" items=\"${list}\"&gt; &lt;div class=\"col mb-3\"&gt; &lt;div class=\"card\"&gt; &lt;img src= \"${path}/resources/img/book/origin/${board.code}.jpg\" onclick= \"location.href= '${path}/books/${board.code}${pm.makeQuery(pm.cri.page)}'\" class=\"card-img-top\"&gt; &lt;div class=\"card-body\"&gt; &lt;h5 class=\"card-title\"&gt;${board.title}&lt;/h5&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/c:forEach&gt; &lt;/div&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;h1 style=\"height: 600px\"&gt;도서가 존재하지 않습니다.&lt;/h1&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt;간단히 이미지와 도서 제목을 부트스트랩을 이용하여 하나의 카드로 만든다.부트스트랩 row 클래스를 사용하여 flex 를 적용하고 4개의 열이 존재하도록 했다.BookCriteria 에서 페이지 당 출력 개수를 8개로 제한 했으니도서 목록은 한 행이 4개씩 두 행 까지만 나타난다.검색 폼&lt;form id=\"searchForm\"&gt; &lt;div class=\"form-row input-group mb-3\"&gt; &lt;input name=\"genre\" id=\"hiddenGenre\" hidden/&gt; &lt;input name=\"page\" id=\"hiddenPage\" hidden/&gt; &lt;div class=\"input-group-prepend\"&gt; &lt;select name=\"searchOption\" id=\"searchOption\" &gt; &lt;option value=\"title\"&gt;제목&lt;/option&gt; &lt;option value=\"auth\"&gt;작성자&lt;/option&gt; &lt;option value=\"intro\"&gt;내용&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;input name=\"searchText\" class=\"form-control\"&gt; &lt;div class=\"input-group-append\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt;검색하기&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;장르와 현재 페이지 정보는 form 에 묶으려면 form 영역이 너무 넓어졌다.hidden 속성을 적용하여 선택된 장르와 페이지를 form 에 함께 넣었다.검색 폼에 장르, 페이지 정보 넣기&lt;script&gt;\tlet genreBtn = $('#hiddenGenre');\tlet hiddenPage = $('#hiddenPage');\t\t$(function(){\t\t\t\tif(hiddenPage.val() == ''){\t\t\thiddenPage.val(1);\t\t}\t\t\t\tif('${cri.genre}' != ''){\t\t\tlet genre = $(\"input:radio[name=genre][value='${cri.genre}']\");\t\t\tgenre.parent().addClass('focus');\t\t\tgenreBtn.val(genre.val());\t\t} else {\t\t\tlet clicked = $(\"input:radio[name=genre][value='']\");\t\t\tclicked.parent().addClass('focus');\t\t}\t})\t\t$('input:radio[name=genre]').on('click', function(ev){\t\tlet genreValue = this.value;\t\tgenreBtn.val(genreValue);\t\tlocation.href=`${path}/books?genre=\\${genreValue}`;\t})&lt;/script&gt;장르와 페이지 정보를 위의 검색 폼에 넣는 과정이다.라디오 버튼 중 name 이 “genre” 일 때, 값을 가져와 hidden input 태그 내부에 값을 전달한다.페이지가 로드 됐을 때 BookCriteria 정보를 이용하여해당 장르를 선택하는 효과를 주고, 다시 hidden input 태그 내부에 값을 전달한다." }, { "title": "9. 권한 인터셉터", "url": "/posts/project-betty-9-interceptor/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:08:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기머나먼 여정을 지나 드디어 권한 인터셉터로 왔다.시큐리티를 등한시한 내게 이 인터셉터는 차선책이었다.public class AuthInterceptor implements HandlerInterceptor{\t@Override\tpublic boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler )\t\t\tthrows Exception {\t\t\t\tString uri = request.getRequestURI();\t\tString path = request.getServletContext().getContextPath();\t\tHttpSession session = request.getSession(false);\t\tMember user = (Member)session.getAttribute(SessionConst.USER);\t\t\t\t\t\tif(session == null || user == null) {\t\t\tresponse.sendRedirect(path+\"/sign/in?redirectURL=\"+uri);\t\t\treturn false;\t\t}\t\t\t\tint right = user.getRights();\t\tString area = uri.substring(path.length());\t\t\t\t\t\tboolean memberPath = area.startsWith(PathConst.MEMBERS); \t\tboolean staffPath = area.startsWith(PathConst.STAFF);\t\tboolean adminPath = area.startsWith(PathConst.ADMIN); \t\tboolean offlinePath = area.startsWith(PathConst.OFFLINE);\t\tboolean isMember = (right == 0);\t\tboolean isStaff = (right == 2);\t\tboolean isAdmin = (right == 3);\t\t\t\tif(offlinePath || memberPath &amp;&amp; isMember) {\t\t\tString pathVariable = uri.split(\"/\")[3];\t\t\tif(!user.equalsId(pathVariable)) {\t\t\t\trequest.setAttribute(\"message\", \"요청 실패\");\t\t\t\tresponse.sendRedirect(path);\t\t\t\treturn false;\t\t\t}\t\t}\t\t\t\tif(memberPath &amp;&amp; !isMember) {\t\t\trequest.setAttribute(\"message\", \"일반회원만 접근할 수 있습니다.\");\t\t\tresponse.sendRedirect(path);\t\t\treturn false;\t\t} else if (staffPath &amp;&amp; !isStaff) {\t\t\trequest.setAttribute(\"message\", \"직원회원만 접근할 수 있습니다.\");\t\t\tresponse.sendRedirect(path);\t\t\treturn false;\t\t} else if(offlinePath &amp;&amp; !isMember) {\t\t\trequest.setAttribute(\"message\", \"일반회원만 접근할 수 있습니다.\");\t\t\tresponse.sendRedirect(path);\t\t\treturn false;\t\t} else if(adminPath &amp;&amp; !isAdmin) {\t\t\trequest.setAttribute(\"message\", \"관리자만 접근할 수 있습니다.\");\t\t\tresponse.sendRedirect(path);\t\t\treturn false;\t\t}\t\t\t\t\trequest.setAttribute(\"nav\", uri.split(\"/\")[2]);\t\treturn true;\t}}경로에 따라, 권한에 따라 boolean 을 많이도 생성했다.분명 훨씬 나은 방법이 존재하겠지만 현재까지도 떠오르지 않는다.권한에 따른 접근을 제어하기 위한 인터셉터다. 만드는 데 큰 어려움은 없었다.애초에 경로를 나눠 놓을 때 권한 별 제어를 할 수 있도록 구성했었다.uri 와 contextPath 를 활용하는 부분은JSP &amp; 서블릿 구조에서 프론트 컨트롤러의 작업과 비슷하다.우선 권한 별 접근 제한이기에 세션 자체가 없거나 (로그인을 안 했거나)세션이 존재하더라도 세션 Member 객체가 null 일 때 로그인 화면으로 보낸다.이때 이전의 요청 경로를 쿼리파라미터에 함께 넘겨서로그인 성공했을 때 돌아갈 수 있도록 지정했다.이 부분에서 한 가지 궁금증이 생길 수 있는데,악의적으로 admin 경로로 진입한 뒤 일반 회원으로 로그인 한다면?걱정하지말자.“권한에 따른 접근 제어” 이게 본질이다.접근 제어가 필요한 경로엔 이 인터셉터가 매번 적용되어위와 같은 상황은 로그인 성공 시 Home 화면으로 이동된다.Betty 의 member 영역에 대한 경로는 아래와 같다.\"http://localhost:8080/betty/members\"members, staff, admin, offline 중 해당하는 경로가 있을 때 검증이 시작된다.맨 마지막에 있는 “nav”는 좌측 네비게이터를 동적으로 구성하기 위한 장치다.인증, 인가 검사를 거치고 나면request 영역 객체에 해당 카테고리의 nav 정보를 담는다.jsp:include 태그를 이용하여 contextPath 와 Session Member 객체를 넘긴다.동적 include 를 사용할 때 변수를 그대로 이용할 수 없어 param 태그로 넘겨줘야 된다.include file 은 동일한 Servlet 내에서 렌더링되지만경로 내에 el 을 사용할 수 없다.jsp include 는 각자 독립된 Servlet 에서 렌더링된 뒤 포함되는 형식이고, el 을 사용할 수 있다." }, { "title": "8. 계정 관련", "url": "/posts/project-betty-8-sign/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:07:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기내 딴에 심혈을 기울인 로직이라고 하면 계정과 그 권한에 대한 내용이다.나름 최선을 다해 세심하게 만들었지만, 이것 밖에 안되나 싶을 수도 있다.아쉬운 점은 ajax 를 적용하지 못했다.로그인 화면Betty 로그인 화면이다.로그인 시 쿠키 저장 체크박스를 만들어놓았다.form object로그인에서도 검증용 폼 객체를 이용했다.아주 심플하다.컨트롤러에서 바로 패스워드 암호화를 위해 폼 객체에 encode 메소드를 정의했다.객체가 생성되자마자 encode 됐으면 해서 클래스 내부에인스턴스 블록 스코프를 놔두고 encode 를 바로 수행해봤는데전체 생성자를 통해 생성되지 않아 실패했다.결국 컨트롤러에서 바로 호출시키는 걸로 만족했다.dto 의 일종인 form 객체를 바로 Member Entity 로 변환 시키는 메소드도 있다.변환은 Service 계층에서 이루어진다.컨트롤러 검증 에러가 있을 시 로그인 화면으로 리다이렉트 form 객체 패스워드 인코딩 ID &amp; PW 로 Select 후 Member 반환 반한된 Member 객체가 null 일 때 로그인 화면으로 리다이렉트 null 이 아니라면 세션에 저장(상수 사용) 폼 객체의 로그인 쿠키가 체크되었다면 쿠키에 저장(SignHelper) 권한이 필요한 페이지에 접근했다가 거부되어 로그인 화면으로 왔을 시 해당 URL 로 리다이렉트 아무 조건 없이 정상 수행 시 Home 화면으로 리다이렉트쿠키에 아이디를 저장할 때도 인코딩을 적용했다.다른 방법도 있겠지만 당장 간편하게 할 방법이 떠오르지 않았다.쿠키에 아이디를 평문으로 줬을 땐 너무 쉽게 악용할 수 있어서 차마 인코딩을 하지 않을 수 없었다.Sign Helper난 static method 를 자주 쓴다.이것은 그저 나만 편한 방법이긴 하다.공통으로 사용될만한 로직이나 거슬리는 로직을 빼버린다.나름의 기준이 있는데, 불필요하게 많은 인자를 받게 될 것 같으면 안 한다.그거 적는 게 더 귀찮다.Base64UtilBase64 암호화 클래스다.이상하게 String 을 넣고 String 을 반환하는 게 없었다.매번 바이트 코드를 만들고 빼고 다시 넣고 하기 귀찮았다.바이트코드로 하면 될 것 같기도 한데,인코딩은 파면 팔수록 복잡한 영역이다.사실 패스워드를 반환할 일은 대개 없으니,String 을 DB 에 넣는 건 잘못된 선택이었을까?이 부분은 나중에 다시 생각해볼 필요가 있겠다.Cookie Interceptor로그인 쿠키가 존재할 때 세션에 Member 객체를 넣는 인터셉터다.로그인 시 쿠키 저장에 체크한 회원이 성공적으로 로그인 했을 때,아이디 정보가 담긴 쿠키를 Response Header 를 통해 전달 받았을 텐데클라이언트가 브라우저를 종료한 이후, 이 쿠키를 통해 다시 로그인 시키는 과정이다.클라이언트는 암호화된 자신의 아이디가 저장된 쿠키를 받는다.당연히 서버에선 해당 쿠키의 값을 디코딩하여 DB 에서 꺼내온다." }, { "title": "7. 검증", "url": "/posts/project-betty-7-validation/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:06:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기검증은 회원가입 검증에 대한 이야기를 할 생각이다.javax 와 hibernate 를 활용한 서버 검증수업 때 배운 JQuery.validate 를 활용한 클라이언트 검증두 가지 이야기다.클라이언트 검증 (프론트)html아이디&lt;div class=\"input__item\"&gt; &lt;span&gt;&lt;i class=\"bi bi-person-circle\"&gt;&lt;/i&gt;&lt;/span&gt; &lt;input type=\"text\" name=\"id\" id=\"id\" placeholder=\"아이디를 입력 하세요\" /&gt; &lt;div class=\"result\"&gt;&lt;/div&gt;&lt;/div&gt;간단한 html 태그 그룹이고 특이한 점은자식 요소 중 마지막에 result class 의 div 태그가 존재한다.이 곳은 JQuery.validate 의 결괏값이 들어갈 장소다.jsconst regexID = /^[0-9a-zA-Z]{3,10}$/;$(\"#signUpForm\").validate({ onkeyup : function(el){ $(el).valid(); }, rules : {\t id : { required : true, remote : { type : \"GET\", url : \"${path}/sign/up/idCheck\" }, regex : regexID } }, messages : { id : { required : \"아이디를 작성하세요.\", remote : \"이미 존재하는 아이디입니다.\", regex : \"영어와 숫자로 3~10글자 이내로 작성하세요.\" } }, errorClass : \"text-danger\", errorElement : \"div\", errorPlacement : function(error, element){ error.insertAfter(element); }});아주 간단히 요약하면 이런 식이다.이메일, 문자 인증도 포함되어 있어서submit 이전에 마저 검증이 필요한 부분을submitHandler 설정을 통해 수행할 수도 있다.keyup event 가 발생했을 때, 제약에 따라 error 문구를 발생시킨다.나도 읽히는 그대로만 알고 있어서 자세히 설명할 수준은 안되는 것 같다.서버 검증 (백)form objectvalidation 을 활용하기 위해 나름 성의를 갖췄다.@NotBlank, @NotNull, @NotEmpty 가 존재하는데@NotBlank 가 가장 꼼꼼하므로 선택했다.null 과 “” 를 모두 불허한다.생년월일은 @DateTimeFormat 을 이용했다.문자열을 보고 Date 객체로 변환한다.Betty 에선 아찔한 순간이 하나 있다.데이터베이스에서 생년월일 컬럼을 Timestamp 타입으로 지정했던 것이다.바로 Date -&gt; Timestamp 변환 과정이었다.자세힌 모르지만 Timestamp 객체를 생성할 떄 1970년도 이전 날짜는 받지 않았다.이는 협정 세계시(UTC)와 관련된 것일 텐데,당장 자세히 알아볼 거리는 아니라서 인정했다.그냥 데이터베이스 컬럼 타입을 바꾸면 되지 않나?이 말도 틀린 건 아니다.하지만 난 DB 설계를 팀원에게 믿고 맡겼다.기능상 큰 문제가 없다면 지적하고 싶지 않기도 했고,그럼에도 Timestamp 를 선택한 이유가 있을거라 생각했기 때문이다.BindingResult열심히 form 객체에 제약을 걸어놨더라도매개변수에 @Valid(or @Validated) 를 선언하지 않으면 말짱도루묵이다.검증이 필요한 객체 바로 다음에 BindingResult 객체를 명시하면검증 부적합 판별 내용에 관한 에러 내용을 받을 수 있다.여기선 간단히 에러가 있다면 회원가입 화면으로 리다이렉트시키는 걸로 마무리했다.아무래도 검증 처리는 나름 배워야할 게 많기 때문에 이 이상은 후순위로 미뤘었다.두 번의 검증서버에선 항상 클라이언트에서 날아온 데이터를 의심하라고 배웠다.나는 앞으로도 두 번의 검증 절차를 수행할 것이다.서버 검증은 여태까진 사실 대충한 수준이지만 다른 예시를 많이 찾아볼 생각이다." }, { "title": "6. 예외 다루기", "url": "/posts/project-betty-6-exception/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:05:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기내가 꿈꿔왔던 공통 예외 처리부이다.하지만 !.. 예외를 아름답게 처리해두기엔 시간이 부족했다.프로젝트 기간 동안 ajax 를 뼈저리게 익히는 시간조차 부족했기 때문이다.아무튼 적용했다 치고 적어볼 것이다.package공통 영역인 global 패키지 하위에 있는 error 패키지다.RequestMappingHandler 상위로 예외가 전파되는 타이밍에 ControllerAdvice 가 낚아채어 작업한다.일반 컨트롤러에선 ModelAndView 객체를 반환하면 되고,Rest 컨트롤러에선 응답용 객체나 ResponseEntity 등을 반환하면 된다.물론 예외에 대한 Handling 이므로 신중해야 한다.이 패키지엔 직접 정의한 비즈니스 예외, 컨트롤러 어드바이스, 응답용 객체 모두 존재한다.컨트롤러 어드바이스는 특정 컨트롤러만 담당시킬 수 있으므로글로벌하게 적용되는 게 아니라면 해당 도메인에 위치하는 게 맞을 것 같다.그러므로 비즈니스 예외 또한 이곳에 몽땅 있으면 안 된다.하지만 이렇게 놔두고 리뷰하자.GlobalControllerAdvice가장 간단하게 직접 적용해봤던 컨트롤러 어드바이스다.엉뚱한 경로를 요청했을 때 아래 페이지를 반환하도록 했다.ErrorResultapi 예외에서 에러를 응답할 객체이다.웬만하면 ResponseEntity 에 반환하는 편이 나은 것 같다.new ResponseEntity&lt;ErrorResult&gt;(errorResult, HttpStatus.XXX)ResponseEntity 는 Http status code 를 간편히 함께 전달할 수 있기 때문이다.상태 코드를 적는 이유는내가 알기로 “서버에서 예외가 발생하더라도 클라이언트에서는 알 수 없다” 라는 이유다.(절대 정확하지 않다.)(아마 DefaultHandlerExcpetionResolver 가 어느정도 처리해줄 것 같다.)서버의 예외를 인지하고 프론트 단에서 처리해야되는 거야 많겠지만,당장 나는 ajax 를 위해 이를 공부했다.ajax 에서 error 로 인식시키려면 서버에서 예외 처리 후 상태 코드를 함께 던져야 했다.이 객체는 코드와 메시지를 담는 게 주 역할이다.코드는 “B001” 과 같이 약속된 코드이고,메시지는 사용자에게 출력하게 될 내용이다.커스텀 예외에 대한 생각비즈니스 관련 예외를 직접 정의해야될까에 대한 고민을 많이 했다.(물론 적용은 못했지만, 추후 사이드 프로젝트에는 반드시 적용할 것이다.)그리고 직접 정의하는 편이 낫다고 생각했다.왜 그렇게 생각했냐면, 사전에 제공되는 Exception 종류가 상당하다. 이걸 언제 다 보고 있을까 사전에 제공되는 Exception 을 비즈니스 예외로 어떻게 적절히 끼워넣나 일관성 있는 예외 처리를 바랬으나 커스텀하지 않으면 다른 의도의 예외까지 처리하지 않을까이 정도다.나는 비즈니스 예외를 최대한 직접 정의하는 게 나은 것 같다.ExceptionHandler 에 대한 생각처음 ExceptionHandler 를 사용했을 때HandlerExceptionResolver 를 상속하여 만드는 예외 핸들러와 굉장히 헷갈렸다.잘 생각해보면 ExceptionHandler, ResponseStatusHandler,DefaultExceptionHandler 는 이미 존재하는 객체들이다.얘네가 HandlerExceptionResolver 이므로 내가 직접 커스텀할 필요가 없었다.당연해보이지만 HandlerExceptionResolver 를 상속하여 Servlet에 추가하여 사용한다 생각했을때,커스텀과 기본 제공 Handler의 범주가 같다는 걸 이해해야 내게 필요없다는 걸 이해할 수 있다.뇌에 힘 빼고 @ExceptionHandler 와 @ControllerAdvice 만적절히 잘 사용하면 된다." }, { "title": "5. 메시지와 국제화", "url": "/posts/project-betty-5-message/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:04:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기국제화는 이번 프로젝트에서 꽤 귀여운 기능 아닐까?메시지와 국제화에 대하여 알아보자.틀린 내용이 있을 수 있지만, 내 머릿속에선 거의 맞다고 생각되는 내용들이다.메시지, 국제화를 위한 준비properties내가 원하는 code 에 대한 keyword 를 key = value 형식으로 나열한다.“en”, “ko” 와 같은 국가 코드를 적지 않는다면,Default message 로 인식 된다.예를 들어, Locale 이 “en” 으로 되어 있다면 “en” 의 keyword 를 사용하지만“en” 이 아니라면, 아무 국가 코드도 없는 messages.properties 가 적용 된다.즉, 원하는 국가의 keyword 를 손수 작성해줘야 된다.적어도 스프링 레거시 프로젝트에서는 이렇게 사용했다.messageSource메시지와 국제화 properties 파일 작성이 완료되었다면,이를 인식시켜주기 위해 MessageSource 객체로 읽어줘야 된다.사진처럼 간단히 Basename 을 파일 이름까지 적어주면 된다.ReloadableResourceBundleMessageSource 에 대한 설명이다.딱히 모르겠다.“WEB-INF” 같이, classpath 이외의 경로에 있는 파일도 읽어주는 것 같다. 스프링을 사용한다면, 그냥 권장하는 걸 쓰면 된다고 생각한다.message tag레거시 프로젝트에서 국제화를 적용하려면,message 태그라는 것을 사용해야 한다.이게 무슨 말이냐면~&lt;%@ taglib prefix=\"s\" uri=\"http://www.springframework.org/tags\" %&gt;jsp 파일 상단에 이렇게 태그 라이브러리를 추가하고,아까 정리했던 properties 파일의 코드들을 위와 같이 적재적소에 기입해주는 것이다.아마 눈치 빠르신 분들은 알겠지만 화면 상에 보이는 모든 텍스트들은 이미지 파일에 합쳐진 게 아니여야 된다.하나라도 다른 언어가 있다면, 안하니만 못하는 화면을 보게 된다.LocaleChangeInterceptor이 인터셉터는 빈을 등록할 때 설정한 paramName 으로,요청 시 “lang” 파라미터를 확인하고 LocaleResolver 를 통해클라이언트 Locale 을 지정한다.CookieLocaleResolver내부에 선언된 메소드 중 몇 가지이다.쿠키를 통한 클라이언트 Locale 지정을 담당한다.버튼 하나로 국제화 하기ENG 버튼을 누르는 상황을 연출했다.간단 요약 ENG 버튼을 클릭 ajax 를 사용하여 root 경로로 쿼리파라미터 “lang=en” 을 함께 요청 인터셉터가 인지 후 “en” 쿠키 반환 페이지를 reload 하면 새 요청시 CookielocaleResolver 를 통해 en 으로 인식 message 태그의 value 를 “en” 에 해당하는 값으로 렌더링자바스크립트KOR 또는 ENG 버튼을 눌렀을 때ajax 로 root 경로에 쿼리 파라미터를 함께 요청한다.바로 현재 location 으로 reload 하여국제화가 적용된 화면을 렌더링 시킨다.Response HeaderENG 를 눌렀을 때의 Response Headernew Cookie(\"lang\",\"en\") 가 응답된다.위 ajax 요청에 대한 응답이다." }, { "title": "4. 프로젝트 환경", "url": "/posts/project-betty-4-config/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:03:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기이번 프로젝트에서 내 핵심 역할은 프로젝트 환경을 구성계정 관련 로직 처리잡다한 프론트, 비즈니스 로직 등이 있는데가장 소개하고 싶은 게 바로xml 을 모두 제거하고 java config 로 돌린 것과스프링이 제공하는 여러 기능을 활용한 것이다.아래는 스프링 공식 문서에 나타난 내용이다.“스프링 환경 설정에서 어노테이션 기반이 XML 기반 설정보다 나은가?”어노테이션 기반의 설정 소개는, 'XML 보다 더 나은 가' 에 대한 의문을 일으켰다.간단한 답변으로는, 그냥 따르라 ? ?긴 답변으로는, 찬반이 있는데, 대개 개발자의 전략에 달려 있다.어노테이션은 짧고 간결한 설정을 따르는 걸로 많은 context(정보)를 제공한다.XML은 소스 코드를 건드리지 않고 리컴파일링이 가능하다.몇몇 개발자는 ~~ 하지만 몇몇 개발자는 어노테이션 클래스는더이상 POJO가 아니고 분산되어 제어 하기가 힘들다고 한다.(죄송합니다. 영어를 잘 못해요..)내가 해석하기엔 이런 느낌이었다. “그냥 익숙한 거 써라”난 POJO 의미 자체를 좋아하긴 한다만,어노테이션 기반 설정이 XML 을 무너뜨릴 수 있다면어노테이션 쪽 손을 들어주고 싶다.XML 을 쓰는 건 일단 구식인 것 같아서 싫었다.인프런 강의에선 모두 스프링 부트를 사용 했었고,서블릿을 다루긴 했지만 레거시 프로젝트에서 진행되진 않았다.결국 난 내 손으로 A to Z 를 다 해냈어야 했는데,아무튼 성공했다.굉장히 힘들게.WebConfig처음엔 Web.xml 을 대체할 때, 이상한 클래스를 상속 받길래 읽기도 싫었다.가만 보면, 어노테이션 설정 디스패쳐 서블릿 이니셜라이저 완전 어노테이션 기반 설정을 위한 톰캣으로 느껴진다.서블릿은 굳이 여러 개 사용해야될까 싶어 하나만 사용했다.(서블릿을 여러 개 사용하는 것과 MSA 는 관련 없겠지?)여기서 볼만한 것은 필터와 그 아래의 것인데.- FilterUTF-8 변환을 위핸 인코딩 필터는 무조건 필요했고,FormContentFilter 는 읽어본 결과서블릿 스펙에선 html form data 를 POST 형태로만 받는 게 기본인데,PUT, PATCH, DELETE Method 로도 받게 해준다.이정도로 해석했다. 사실 Betty 에서는 form 태그를 전부 POST 형태로 정의 했기에 쓸모 없는 것 같다.HiddenHttpMethodFilter 는 약간의 꼼수로 서버 내에서 POST 를 Put 과 같은 Method 로 변형하여 Mapping 시키는 걸로 안다. 이또한 사실 필요 없었다.근데 사실 FormContent 와 HiddenHttpMethod 는 함께 사용되어야 하는 게 아닐까 싶다.- customizeRegistrationthrowExceptionIfNoHandlerFound 를 true 로 설정했다.단순히 핸들러를 찾지 못했을 때 Exception 을 발생시키겠다는 것.좀더 파고들면, 요청 경로에 대한 Mapping 메소드가 존재하지 않는다면,예외를 발생시켜, 직접 제작한 404 Page 를 띄워주기 위한 설정이다.그냥 xml 을 사용했다면, 간단히 &lt;error-code&gt; 를 사용하면 됐을 일이긴 하다.DBConfig- HikariCP데이터소스와 마이바티스 관련 설정도 고비가 많았다.HiKariCP 를 사용했는데, 단순히 url, name, pw 등 익숙한 것만 하려니 안 됐었다.아마 내가 못한 거겠지만, Hikari github 에 가서 찾아보니MySQL 추천 설정이 나타나 있어 그걸 그대로 썼다.일단 모든 설정을 properties 로 바꾸려니 익숙치 않고 어려웠는데,key 가 지칭하는 게 field 의 식별자인 것을 알고 나선 그리 어렵지 않았다.- SqlSessionFactory다음은 마이바티스를 위한 세션 팩토리이다.이건 딱히 설정이랄 건 없다.공식 사이트에서 보니 기본 설정이 굉장히 깔끔하게 되어있었고,under_score 를 underScore 로 바꿔 매핑하도록 하는 설정만 지정해줬다.이 설정은 DB 에서 흔히 사용하는 전통 언더스코어 명칭 규약을자바의 변수 명에 사용되는 카멜 케이스와 매핑시키기 위해 존재한다.- DatabaseConfiguration클래스 어노테이션으로 @DatabaseConfiguration 이 있는데,세션 팩토리 내부에 마이바티스 Configuration 객체를 생성할 때Configuration 이 겹치기에 어노테이션을 차라리 새로 만들기로 하였다.구성은 단순하다. 상속 느낌으로 이해하면 된다.- TransactionManager트랜잭션 매니저로는 공식 문서에 DataSourceTransactionManager 를 권장했다.그래서 사용했다. 깊은 뜻이 있지 않을까?- MapperScanServlet 의 ComponentScan 도 그렇고 스캔 경로는 최대한 간결하길 바랬다.처음엔 root 경로부터 돌렸으나, 불필요하게 많은 것들을 스캔하기에 좀더 상세하게 바꿨다.RootConfig- Import열심히 설정한 데이터베이스 설정은 RootConfig 에 포함시켰다.이상하게 import 는 한 클래스 밖에 안됐다.하나라도 되는 게 어디인가 싶다.- EnableTransactionManagement@Transactional 을 인식하고 트랜잭션 매니저를 사용하여커넥션을 관리하도록 만드는 걸 허용하는 어노테이션으로 알고 있다.- PropertySourceproperties 파일을 해당 클래스에서 인식시킬 수 있다.@Value 와 EL 을 사용하여 값을 가져올 수 있다.- MessageSourceReloadableResourceBundleMessageSource 에 대해선 정확히 뭔진 모르겠다.공식 문서에서도 이 객체를 사용하기에 나도 썼다.메시지, 국제화에 사용하는 properties 를 이 객체가 가져온다.그리고 사용한다.- CommonsMultipartResolver파일업로드에 사용하는 객체이다.좀더 나아가면 form encoding type 이 multipart 일 때이 객체가 번역에 힘쓰는 걸로 알고 있다.그것보단 Servlet 3.0 부터 지원하는 Standard~~resolver 도 있는데검색해보니 인코딩 관련 문제를 마주했었고, 수업 때 Commons 를 사용하기도 해서 Commons 를 적용했다.- PropertySourcesPlaceholderConfigurerPropertySource 가 아마 테스트 환경에선 동작하지 않았을 거다.이 객체를 static 으로 등록하고 나서부턴 테스트 환경에서도 properties 를정상적으로 읽어왔다. - DefaultMessageService문자 인증 관련 객체AppConfig - 1AppConfig 는 단 하나 뿐인 소중한 Servlet 이다.수동 Bean 과 각종 커스텀 기능이 추가되어 있어 두 사진으로 나눴다.- Enable@EnableScheduling : Batch 기능 이용 @EnableAspectJAutoProxy : AOP 기능 이용@EnableWebMvc : 아마 스프링 프레임워크의 Web Servlet api 를 이용할 수 있게 해주는 어노테이션 - ComponentScan베이스 패키지를 root 부터 잡는데,@Configuration 은 다시 읽지 않도록 설정 - addArgumentResolver어디서 설명할까 했는데 간단하게 여기서 설명해야겠다.어노테이션을 정의하고 해당 어노테이션이 선언된 인자의 데이터를 처리할 때, Member 클래스가 맞는지 확인한 뒤 세션에 있는 Member 객체를 주입 시키는 객체다.내가 정의한 어노테이션은 @User 이고,위와 같이 매개변수 앞에 @User 어노테이션을 선언하면,현재 세션에 담긴 Member 객체를 꺼내온다.참고로 Betty 에선 로그인 회원을 “user” 라는 key 값으로 세션에 담아둔다.- interceptor인터셉터는 3가지가 있다.LocaleChangeInterceptor : Locale 쿠키 기반으로 클라이언트 Locale 조작 CookieInterceptor : 쿠키를 통해 로그인 정보 저장AuthInterceptor : 인증 - 인가 관련하여 페이지 접근 제어쿠키 인터셉터가 좀 특이한데, 생성자에 memberService 를 받는다.인터셉터 등록은 bean 등록이 아니기 때문에,내부에서 memberService 를 @AutoWired 로 주입받을 수 없어 하는 수 없이 생성자로 받게 되었다.AppConfig - 2- addResourceHandlers정적 자원에 대한 경로와 uri 설정이다.핵심은 cacheControl 이다.- CacheControl잘 모르지만 적어보겠습니다. 정말 잘 모릅니다..Betty 프로젝트는 도서 사진이 굉장히 많다.이 사진을 매 요청시마다 전달하는 건 굉장히 큰 부담이라 생각했고방법을 찾아야 했었는데.. (근데 아마 브라우저 자체적으로 알아서 캐싱을 하는 걸로 알고 있긴 하다.) 바로 클라이언트의 캐시 저장소를 이용하는 것이다.공식 문서를 보다가 주워온 거라 우선 365일로 지정하긴 했는데실제 서비스라면 상당히 무책임한 행동이라 생각되긴 하다..내가 알기로 원리는 이렇다. 최초 페이지 요청 시 날아오는 Resource 를 브라우저 캐시 저장소에 저장한다. 이후 동일한 Resource 를 요청할 상황이 나타났을 떄,캐시 저장소에 Resource 가 있다면 HTTP 프로토콜에 이미지 이름과 수정 날짜 등의 정보를 이용하여 새로 받을 필요가 없다면 안 줘도 된다는 메시지를 Http Header 에 함께 보내는 것.하드웨어가 발달하고 더불어 메모리도 발달한 현대에는클라이언트에게 부담을 떠넘기는 게 마냥 나쁘지도 않은 것 같긴 하다.- configureViewResolversViewResolver 객체야 일반 Controller Handler 반환 페이지를 결정할 때 필요하다만JstlView 의 역할이 너무 궁금하다.우선 정보가 별로 없고, 주석을 읽어보면 messageSource 와 관련됐기도 하던데 너무 궁금하지만 다음에 다시 사용할 때에 찾아보려 한다.- LocaleResolver, LocaleChangeInterceptor전자는 “lang” 쿠키를 통해 쿠키 기반으로 클라이언트 국가를 결정하는 객체이고,후자는 “lang” key 값으로 파라미터를 받아 “lang” 쿠키를 응답하는 객체로 알고 있다.둘다 국제화 관련된 객체이다.EmailConfigproperties 를 적극 활용한 이메일 설정이다." }, { "title": "3. 패키지 트리", "url": "/posts/project-betty-3-package-tree/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:02:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기패키지 트리를 어떻게 분류할 지는 다양한 방법이 있을 것이다.1. 도메인을 기준으로 분리+ root + member + controller - MemberController - SignController + service - MemberService - SignService + repository - MemberRepo . . . + common + controller - HomeController + interceptor - LocaleInterceptor . . . + util - FileUpload . . .2. 컴포넌트를 기준으로 분리+ root + controller - MemberController - BookController + service - MemberService . . . + repository - MemberRepo . . .내가 채택한 방법3. 도메인, 글로벌, 인프라 분리 후 도메인 기준으로 분리+ root + domain + member + controller + service . . . + global + config + error + interceptor . . . + infra + email + sms전체 패키지 트리[ domain, global, infra ] 세 영역으로 분리했다.domain아직 도메인을 어떤 기준으로 분리해야될 지는 감이 없다.다른 건 객체가 명확히 존재한다고 인정할 수 있지만rental 의 경우 일단 분리는 했으니 로직을 어느 영역에서 처리할 지 애매했다. rental table 의 경우 명확히 존재하므로entity, repository 의 정의는 필요하다 싶었고service 의 경우 다른 영역에서 참조하여 사용하였다.globalglobal 패키지엔 @Configuration 클래스와인터셉터, 홈 컨트롤러, 공통 예외인 error 패키지가 존재한다. 각 도메인에만 해당하는 클래스들도 있지만 비즈니스 예외를 정의하다보니 분류가 애매해져 한 데 모아버렸다.infraemail 과 sms 를 뒀다.정확히는 송신 객체이다.Composite 형태로, 내부에서 객체를 주입받아 사용한다.(JavaMailSender, DefaultMessageService) 정말 “api” 느낌이 진할 때 infra 영역에 넣으면 될 것 같다.domain비즈니스 로직에 관여할 상황이 그리 많지 않았다.DB 를 담당했던 팀원이 대부분의 로직을 DB 에서 처리해줬다.아마 트리거로는 어디가서 무시받지 않을 것 같다.난 그나마 좀 중요하다 싶은 계정 관련 작업을 나서서 했다. 물론 이외에도 내 손길이 간 부분은 많다.domain 영역은 내 애정이 담긴 member 패키지로 살펴보자.각 컴포넌트 또는 기능 별로 분리했다.controller, dao(repository), dto, provider, service, util, vo보면 member 내부에 Sign 도 있고 다른 권한인 staff, admin 도 존재한다.Service 의 경우 인터페이스를 두지 않았다.그냥 왜 필요한 지도 모르겠다.dao 도 비슷한 수준이다.마이바티스를 사용하는 순간 변경에 닫힌 느낌이다.근데 매퍼는 인터페이스로 두라 하니 인터페이스를 사용했을 뿐이다.나머지는 단순해서 달리 설명할 부분이 없는 것 같다.규모가 작아 이 구조에 큰 문제는 없었는데정답은 없겠지만 더 나은 방향이 무엇일까에 대한 의견을 얻고 싶다.model이게 우리가 원하는 model 이 맞는 진 정말 모른다.domain 영역에서만 공통적으로 사용하는 ‘무언가’ 를 놔뒀다.테이블 명, 세션 이름, 쿠키 이름 등등 다양한 상수의 집합이다.협업할 때 일관성, 통일성에 집착했는데, 상수의 존재는 내게 몹시 중요했다.예를 들어, 우린 마이바티스를 사용했고, 이왕 할 거라면 모든 쿼리문을 provider 로 사용하자고 제시했다.이 부분에서 상수의 존재는 큰힘을 발휘한다.이런식으로 정적 import 와 활용한다면,적어도 테이블 명이 틀려서 나타나는 trace 는 절대 마주칠 수 없을 것이다.뿐만 아니라 세션과 쿠키의 key 역시 마찬가지다.global앞서 얘기했듯, 설정 정보와 다양한 공통 영역이다.이 또한 작은 규모라서 가능했을 것이고,어서 영역에 맞게 잘 분리된 프로젝트를 보거나, 직접 참여해보고 싶다." }, { "title": "2. 기획 및 명세화", "url": "/posts/project-betty-2-concept/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:01:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기컨셉, 기획“도서관 설립자는 이윤을 추구하지 않는다. 서적을 사랑하며 철저한 유료 시스템을 통해 책임을 증명할 수 있는 사람들을 타겟으로한 사립 도서관이다”핵심 프로세스 도서 입고 - 직원은 도서를 등록하고 재고를 수정할 수 있음 도서 폐기 - 직원은 도서를 폐기할 수 있음 대여 - 회원은 도서관에 등록된 도서를 대여할 수 있음 독서존 - 도서관 내 1인 독서실과 같이 운영 애플리케이션 기능 검색 - 다양한 조건으로 도서 및 게시글을 검색할 수 있음 포인트 - 회원의 대여료 지불과 멤버십 가입 및 변경에 사용됨 오프라인 - 회원은 오프라인 화면에서 대여 예약 도서 수령 및 반납, 독서존 체크인, 체크아웃을 할 수 있음 게시판 - 자유, 건의사항, 공지사항 게시판이 존재함 다양한 현황 - 도서, 대여, 회원 등 이력과 현황에 대해 조건 검색할 수 있음 블랙리스트 - 관리자는 특정 회원에게 벌점을 부과하여 블랙리스트에 등록시킬 수 있음 회원 공간 - 대시보드에서 자신의 정보, 대여, 상담, 출석률 등을 확인할 수 있음 도서 상세 글 - 도서 상세 정보와 회원 후기를 작성할 수 있음 멤버십, 권한, 이미지 명세화 회원 체계 : 일반 회원, 직원, 총괄 관리자 멤버십 체계 : 브론즈, 실버, VIP 멤버십 총 대여 가능 수 기간 대여비 독서존 시간 연체료 할인률 bronze 1 1주 1000 0 0 silver 2 2주 500 4 10 VIP 3 4주 무료 무제한 20 권한 자유게시판 건의사항 공지사항 고객문의 일반 유저 O O   O 직원 O O O   관리자 O O O   이미지사이즈 small medium 프로필 50x50 300x300 책 68x100 272x400 WEB APP 명세유저 (온라인) 웹사이트를 통해 회원가입할 수 있다. 포인트를 충전하고 멤버십에 가입할 수 있다. 가입 즉시 브론즈 회원으로 멤버십 카드가 등록된다. 자유게시판과 건의사항 게시판에 게시글을 작성할 수 있다. 자유게시판에 계층형 댓글을 작성 및 삭제할 수 있다. 회원정보를 수정할 수 있다. 프로필 이미지를 등록할 수 있다. 도서 상세 게시글에서 대여 예약을 할 수 있다. 도서 상세 게시글에 후기를 작성할 수 있다. 회원 공간의 대시보드에서 볼 수 있는 내용 간략한 회원 정보 체크인 이력에 따른 캘린더 출석 현황 대여 이력 이메일 상담 유저 (오프라인) 대여 예약했던 도서를 수령할 수 있다. 대여 중인 도서를 반납할 수 있다. 독서존에 현재 사용중인 좌석을 구분하여 확인할 수 있다. 독서존에 체크인, 체크아웃할 수 있다.오프라인 화면 예시직원 (온라인) 웹사이트를 통해 회원가입할 수 있다. 회원가입 시 관리자의 승인을 통해 직원 공간 페이지를 사용할 수 있다. 로그인한 직원은 반드시 도서관에 있음을 전제한다. 도서 정보를 등록하고 재고를 수정할 수 있다. 도서 현황을 확인할 수 있다. 대여 현황을 확인할 수 있다. 대여 예약 정보를 알 수 있다. 자유게시판을 이용할 수 있다. 건의사항에 답글을 달 수 있다.관리자 (온라인) 도서관의 총 수익을 알 수 있다. 자유게시판과 건의사항에 답글을 달 수 있다. 일반회원과 직원 상세 정보를 알 수 있다. 금칙 사항에 따라 회원을 블랙리스트에 등록할 수 있다." }, { "title": "1. 서론", "url": "/posts/project-betty-1/", "categories": "프로젝트, Betty", "tags": "스프링, 자바, 포트폴리오", "date": "2022-09-06 09:00:00 +0900", "snippet": "    index 서론 기획 및 명세 패키지 트리 프로젝트 환경 메시지와 국제화 예외 다루기 검증 계정 관련 권한 인터셉터 도서 관련 대여 관련 오프라인 관련 about ajax 지식 공유 - ajax DTO, Form, VO, Entity 후기기능 시연 연상Youtube 에서 보기기분이 좋다. 저번 프로젝트는 프로젝트가 끝나고 수업에 또 치여서 후기를 적을 시간이 없어 한참을 지난 뒤 적었는데, 이번 프로젝트는 머릿속에 포트폴리오에 관한 모든 내용이 살아 있는 채로 작성할 수 있다.평범한 국비생은 스프링 프로젝트를 어떻게 진행했는가에 대해 흥미롭게 볼 수 있을 것이다.기능만 보면 굉장히 단순하다. 회원 관리, 대여, 체크인 시스템, 다양한 상세 검색 등 정~말 별 거 없지만 프론트부터 백엔드까지 전 영역을 돌아다니고 팀원 교육, 업무 분배 등 생각보다 많이 힘들었다.이번 프로젝트의 핵심은 단순하다.도서관과 독서실이 결합한 유료 시스템이것이 우리의 핵심이자 Betty 그 자체이다.간단히 maven 의존성부터 살펴보자변경 사항에 대하여 최대한 알아보기 쉽게 작성했다.AOP 는 아직 정확히 뭘 해야 어노테이션식 적용을 할 수 있는 지 모르겠다.@EnableAspectJAutoProxy 내부에 들어가보면, 아래처럼 적혀있긴 하다.Servlet 쪽은 프로젝트 생성시 나타나는 servlet-api, jsp-api 를 지우고 아래 것들을 추가했다.이건 그냥 수업 때 하던 걸 그냥 따라했다.데이터베이스 의존성은 필요한 것만 했다.연동 모듈이 별도로 존재한다는 건 흥미롭다. mybatis-spring 이런 것.테스트는 assertj-core 를 추가했다.Assertions 클래스를 사용했을 때 테스트시 좀더 확실한 느낌이 있어서 좋았었다.junit 버전을 낮추는 건 수업 때 들었는데, 레거시 프로젝트와 연관됐던 것 같다.validation 에선 버전 설정에서 애먹었었는데이 또한 레거시 프로젝트의 영향이었던 것 같다.hibernate, jakarta 둘 다 버전을 낮춰서 다행히 해결됐었다.mail &amp;&amp; sms 에는 javax.mail 이 있는데 이건 안 썼던 것 같다.아마 내가 착각하고 추가했던 것 같다.Other 에는 그 유명한 롬복과 jackson-databind 가 있다.jakarta-el 은 테스트 환경에서 아마 @PropertySource, @Value 에서 el 과 관련된 에러 떄문에 추가했던 걸로 기억한다.selenium 은 도서 자료 크롤링을 위한 의존성이다." }, { "title": "여태 공부한 것들", "url": "/posts/study-review/", "categories": "그 외, 도서", "tags": "리뷰", "date": "2022-08-08 09:00:00 +0900", "snippet": "====================================간단 리뷰====================================인프런 인프런 김영한 강사님의 스프링 로드맵과 JPA 로드맵을 구매했다. 책으로 공부해도 되지만 실무자, 그것도 높은 직위에 있는분의 강의를 들어보니 어떤 게 중요한 지 감을 잡기 좋았다. 기술적인 얘기는 당연히 내 눈엔 흠잡을 데가 전혀 없었다. 학원 수료 후엔 본격적으로 JPA, 스프링 데이터 JPA, querydsl을 공부할 예정이다.반응형 웹 실전 프로젝트 가이드 적어도 백엔드 개발자한텐 모자람 없게 느껴졌다. 포지션도 그렇고 핵심적인 내용은 다 있었던 것 같다.이것이 MySQL이다 어렵지 않은 내용으로 구성되어 입문자에게 정말 좋다고 생각한다. 인덱스에 대한 이해, 쿼리문, 내장 기능들에 대해 잡고갈 수 있다.혼자 공부하는 자바 정말 제목 그대로다. 입문자에게 정말 좋은 책이다. 아쉬운 게 있다면 모던 API 내용이 없다. 전체적으로 내용을 깊이 있게 다루진 않는다.열혈 자바 프로그래밍 혼자 공부하는 자바를 보고 읽기에 진짜 최적이다. 깊게 파고 든다. 저자님의 생각이 다 적혀있다. 모던 API 에 대한 내용도 다 포함되었다. 개인적으론 자바의 정석보다 나은 것 같다. 대충 봤지만 정석은 그냥 백과사전 느낌이었다.이펙티브 자바 자바 언어 공부가 흥미로웠다면 이 책의 목차는 슬쩍보고 넘어갈 수 없다. 목차를 보자마자 책을 펴게 되어 있다. 자바 언어 공부가 대강 마무리 됐다면 어떻게 활용할지에 대한 방향성을 잡아준다.이것이 자바다 JavaFX 에 대한 내용이 자세히 수록되어 있다. 프로젝트를 할 때 많은 도움이 됐다. 국내에서 FX 공부를 하려면 이 책이 나은 듯 하다.쉽게 배우는 JSP 웹 프로그래밍 처음엔 스프링으로 바로 넘어가도 되지 않을까 했지만 착각이었다. 스프링을 모르고 부트를 하는 것과 다름 없다. 서블릿에 대한 이해를 기반으로 삼고 스프링을 공부해야한다. 이 책엔 스프링으로 가기전 핵심 개념이 다 들어있다.토비의 스프링 이펙티브 자바의 목차를 처음 봤을 때 그 느낌이다. 목차를 보면 군침이 돈다. 전체 내용은 모르지만 스프링의 본질, TDD의 중요성을 익히기 굉장히 좋다. 취업 후에 꼭 공부할 책 중 하나이다.코드로 배우는 스프링 웹 프로젝트 스프링 레거시 프로젝트를 통해 작업한다면 이 책도 좋다. 좋긴 한데, 예제가 많다. 정말 프로젝트를 하나 진행하는 거다. ajax를 활용한 Rest 방식의 웹 프로젝트에 관심이 있다면 읽어 보기 좋다.잔디 개인적으로 한 건 거의 없는 수준이다. 집과 학원을 오가며 인강을 들을 때 사용하다보니 채워졌다. 1일 1커밋은 욕심 났지만 내 성향에 맞지 않다. 최근엔 개인 공부보단 포트폴리오와 이력서 준비 때문에 구멍이 났다.." }, { "title": "1차 프로젝트 병원 시스템", "url": "/posts/first-hospital/", "categories": "프로젝트, 병원시스템", "tags": "프로젝트", "date": "2022-08-06 09:00:00 +0900", "snippet": "영남병원, 병원 시스템들어서며 국비학원 1차 프로젝트이며 3인조로 진행했습니다. 실제 프로젝트 기간은 5월 3일 ~ 5월 13일이며, 3월 21일 학원 개강 이후 1달반이 지난 시기입니다. 문서를 작성중인 현재 날짜는 3개월이 지난 8월 7일이며, 복기를 위주로 작성했습니다. 기술 수준은 JSP 를 배우기 전 단계에 진행했으며, Java, DB, Jdbc, JavaFX를 활용했습니다. 개요양산된 병원 웹사이트에서 진료 예약이나 채팅 시스템은 흔치 않다.현대의 시계는 너무나 빠르고 엄격하며,인간은 힘겹게 얻어낸 소중한 시간을 딱딱한 병원 의자에 소비하고 싶지 않다.소규모 병원이더라도 원격으로 간단한 의료 상담을 해줄 수 있는 의료진이 존재하고 원하는 시간에 바로 진료가 시작되길 바란다.비로소 우리는 시곗바늘에게 자비를 구할 수 있다.담당 분야 SW Architecture GUI(View) Bussiness logic구현 기능 회원 시스템 병원 정보 진료 예약 실시간 상담기타 수업 내용이었던 소켓, 스레드, Jdbc 기술 활용에 초점을 뒀으며 복습을 중시한 프로젝트유저와 관리자 화면 및 기능 페이스북 같은 싱글 페이지 구성을 시도 ajax를 공부하고나니 페이스북은 스크롤 형식의 철저한 비동기 통신의 집합으로 보인다. 회원 시스템과 핵심 프로세스 중 하나인 진료 예약 정규식과 사용자 편의를 위한 keypress event 적용 이전 날짜는 선택 불가능하며 이미 예약된 시간은 리스트에 나타나지 않도록 구현 인공지능 사진 만들기 사이트에서 저작권 문제 없는 가상의 얼굴을 가져와 활용 오시는 길 화면에선 ‘큰 지도로 보기’ 버튼을 클릭할 시 브라우저를 열어 네이버 지도 페이지가 나타나도록 구현 소켓을 활용한 실시간 채팅 구현, 채팅은 영속계층이 아닌, 메모리성으로 Collection 에 저장 각 카테고리에 맞는 목록이 출력됨. 모두 영속계층 데이터프로젝트 타임라인 소프트웨어 공학에서 사용되는 프로젝트 기획서를 참고하여 제작 실제론 기획 및 설계 기간을 길게 가져가는데 규모가 작아 차질 없이 진행MVC 적용과 레이아웃 수업시간에 DAO, VO 라는 단어가 궁금해서 찾아보다가 MVC 패턴에대해 알게 됐었고 fxml 페이지와 컨트롤러를 어떻게 구성해야될까, 패키지를 분리하고 fxml 을 View 로 생각해보니 MVC 패턴에 대입하여 구성할 수 있었음 설계도 처음이고 프로젝트도 처음이라 일관성을 어떻게 지키고 전달해야될지 고민이 듦 협업 툴 중 하나인 노션을 이용하여 명칭을 명세 지금 생각해보면 고객사 요구사항을 작업 당시에 디테일하게 파고들었지만, 최종 포트폴리오에선 기획 단계에서 요구사항을 확실히 잡고 가야겠음. 명세 과정은 비용이 꽤나 컸지만, 식별자 통일에 도움이 됐으므로 포트폴리오에도 고려 소프트웨어 아키텍쳐에 패키지 트리 구성과 레이아웃 구성이 포함되는지는 모르나 설계 당시엔 굉장히 어려웠던 작업 계층형 레이아웃에서 뷰 페이지의 호출 시점, 생명 주기에 대한 공부를 전부 다시 할 정도로 애로사항이 많았음. 상위 컨트롤러에서 하위 계층이 완전히 Load 되기 전, 하위 계층 컨트롤러에 접근하려하면 Exception이 발생 호출 순서에 대한 정확한 이해가 필요했었음 불필요한 리소스 낭비를 막는 계층형 레이아웃의 이점과 생산 비용이라는 단점을 동시에 알게 됨. 다양한 API 도입 이펙티브 자바를 공부하며 Enum 에 대한 환상이 있었는데, 정적 임포트와 활용하여 초기화와 함께 전역에서 불변을 보장하며 다룸 제네릭과 타입 제한을 활용해 컴파일 단계에서 귀찮은 형변환 과정을 제거하고 유연성을 통해 소중함을 느낌 모든 컨트롤러를 정적으로 다루다보니 화면의 데이터가 남아있는 현상이 나타남 화면 전환 메소드 내부에 이전 화면의 데이터를 모두 제거하는 역할의 메소드를 정의하여 해결 화면 전환 메소드가 static 형태로 선언되어 있는데, 컴포지션 형태를 공부했던 게 생각나 연습 겸 적용 학원 수업에선 컬렉션 스트림과 옵셔널 등 모던 API 를 거의 다루지 않았음 같은 수강생들에게 알려주고 싶기도 했고, 연습삼아 기존 for 문을 stream 형태로 변환해서 소개했음 프로젝트 목표 거창하게 작성했었지만 지금 보면 html 을 배우고 코딩에 소질이 있다고 생각하는 어린 아이를 보는 것 같음 enum 을 활용한 컨트롤러는 분명 메모리 효율적 모던 방식 지향은 했지만 사실 쓰인 곳이 적음 상용화된 앱은 정말 훨씬 많은 기능이 있음 복습에 초점은 잘 맞춰진 것 같음후기디자인 패턴의 중요성평소 궁금증이 많아 용어조차도 많이 검색하는 편인데, 스프링이 궁금해 MVC 패턴에 대해 알아봤던 게 프로젝트에 많은 도움이 되었다.알려진 패턴을 참고하여 과감하게 패키지를 나눈 게, 이 프로젝트의 생사를 정하는 결정적인 사항이었다.프레젠테이션 계층고객사와 프론트엔드 담당자가 없다.요구사항의 명확함과 프레젠테이션 명세의 중요성을 느꼈다.어렴풋한 기획 후 즉시 작업을 들어갔으나 실무 신입의 발끝에도 못미치는 실력과 경험으론 어림도 없었다.우선 프레젠테이션 계층을 해결하면 두 문제를 바로 잡을 수 있다고 생각하여 내가 직접 진행했다.'화면 구성이야 별거 아니겠지' 라는 안일한 생각으로처음엔 팀원에게 부탁할까 하다가 직접 해보니 애로사항이 많았다.결과적으로 View 단에 내가 직접 투입해서 뼈대를 마련한 건개발 생산성에 엄청난 도움이 됐다고 자부할 수 있는 경험이었다.생명 주기라이프 사이클에 대한 내용은 정말 지루한 이야기였다.레이아웃을 구성하고 호출 시점을 고려하다보니 생명 주기와 호출 시점에 대한 이해는 선택이 아니라 필수였다.이후 학습에선 예를 들어, Jsp 가 번역되고 컴파일 되는 과정과 같이 호출 시점에 대한 공부를 게을리하지 않았고괜히 스프링 로그를 debug 로 잡고 호출 순서를 분석해보기도 했다.그 과정에서 다양한 기본 제공 api 들과 친숙해질 수 있었다.정보 검색 능력자바FX 관련 내용을 검색해봐야 국내 문서엔 기초 수준 밖에 없었다.웹을 벗어난 GUI 활용에 대한 거라곤 간단한 프로그램일 텐데C언어라는 강력한 대안이 있는 이상, 당연한 결과였다.어쩔 수 없이 영어로 된 문서를 읽기 시작했는데스택 오버 플로우를 특히 자주 봤었다.수능 공부할 때 했던 영어 공부가 빛을 발하던 시기다.레이아웃에 대한 문제 해결 몇몇은 스택 오버 플로우의 힘을 빌렸고이전 화면의 내용을 지우는 Sweeper 메소드 보강에도 도움이 됐다.이때 영어와 친숙해지면서 요즘은 Spring docs 를 직접 보고권장하는 api, 최신 방식에 대한 내용을 직접 찾아볼 수 있게 됐다.언어에 대한 심화학습난 자바 언어관련 책을 3권, 디자인 패턴 책을 1권 봤다.혼자 공부하는 자바는 기본기를 쌓는데 도움이 됐지만모던 api 관련 내용은 없었다. 그래서 열혈 자바 프로그래밍이라는 책을 봤는데제네릭에 대한 상세한 설명과 모던 api 내용이 다 수록되어 있었다.작가 주관을 통해 api 선택에 대한 합리성과 도입된 이유,활용 방안 등 정말 많은 도움이 됐었다.이후 이펙티브 자바를 접했는데, 당시엔 정말 새롭고 흥미로운 주제가 많았다. 복잡한 컬렉션 스트림 예제, 이외에도 정말 어려운 예제가 많았지만 언어 이해도가 수직 상승하던 시기다.관련 없을 수도 있지만 스프링이 주장하는 POJO 를 받아들일 때,이펙티브 자바에서의 언어 수준 향상은 내게 주장에 대한 타당성을 심어줬었다.기본이 제일 중요하기 때문이다.리더란프로젝트 팀장의 무게는, 꼭 IT 뿐만아니라 어디서든.그저 권리만 가진 자리가 아닌, 책임을 가진 자리임을 알게 됐다.팀원의 실수는 내 실수다.리더란 팀원이 실수하지 않는 환경을 조성하는 데 책임이 있다.최종 포트폴리오를 진행할 땐, 팀원들이 자유롭게 자신의코딩 실력을 발휘할 수 있도록 좀더 세련된 환경을 조성할 것이다." }, { "title": "Git", "url": "/posts/git/", "categories": "공부, Git", "tags": "git", "date": "2022-08-02 09:00:00 +0900", "snippet": "gitgit 기본리눅스 코발트가 만듬 CVCS 는 remote 에만 히스토리가 저장됨 DVCS(git) 은 Local 에도 히스토리가 저장됨 최근 Master - Slave 구조를 없애는 운동의 일환으로 default branch 가 main 으로 변경됨 git 은 commit 이전에 staging area 또는 index 라 불리는 상태를 가진다repositoryLocal Working directory로컬 작업 디레토리, git add 수행 시 Staging Area(index)에 저장 Staging Area(index)커밋 시 반영되는 파일 보관, 로컬 저장소에 저장 Local Repository원격 저장소와 교류하는 영역, fetch 했을 때 저장되는 영역, Origin Respository 로 push Remote Upstream Repository개발자들이 공유하는 저장소, 깃헙 같은 곳 Origin Respositoryfork 했을 때 생기는 저장소, Upstream 으로 Pull Requestbranch 개별 독립 작업 영역 분리된 작업 영역에서 자유롭게 소스 코드 변경, 개별 작업Git Flow브랜칭 기법 프로젝트 상황에 맞게 커스텀해서 사용하면 됨 feature branch를 이용하기 때문에 기능 개발과 책임 소재를 명확히 할 수 있음 개발 버전과 제품 버전을 개별 관리할 수 있음 Pull Request를 이용하기 때문에 코드 리뷰가 간편함 feature branch와 hotfix branch의 commit message를 취합하게 되면 이전 버전과의 변경점 쉽게 파악 가능하다git flow 의 5가지 브랜치master : 제품으로 출시될 수 있는 브랜치develop : 다음 출시 버전을 개발하는 브랜치feature : 기능을 개발하는 브랜치release : 이번 출시 버전을 준비하는 브랜치hotfix : 출시 버전에서 발생한 버그를 수정하는 브랜치 develop과 master는 중심이 되는 브랜치이다 따라서, git flow에서 두 브랜치는 반드시 존재해야 한다 (develop 브랜치는 master에서부터 시작된 브랜치)master는 실제 배포되는 영역release는 master되기 직전 최종 검증영역hotfix는 master의 버그를 수정하므로 사실 포트폴리오에서 출시라고 하면 핵심 컨텐츠를 분기로 나눌 수 있는데 브랜치가 너무 많아지면 그것도 힘들 것 같다 단독으로 버그를 수정,,흠feature에서 말하는 기능의 규모는 흠..Git Ignore 제외 후보자동으로 생성되는 로그 파일프로젝트 설정 파일중요 정보가 담긴 파일https vs ssh원격 저장소의 주소를 설정할 때,https 와 ssh 를 선택할 수 있다.https 는 id/pw 방식, ssh 는 private/personal key 방식git 명령어 필수git config git config –global user.name “&lt;github name&gt;” git config –global user.email “&lt;github email&gt;” git은 커밋할 때마다 이 정보를 사용한다. 하나의 커밋에서 계정 정보를 변경할 수 없다 현재 계정 정보 확인 : 제어판 &gt; 사용자 계정 &gt; 자격 증명 관리자git init local git repository 를 설정한다 workspace(작업 영역) 로 지정하는 명령어 git 은 작업 영역에서의 변경을 감지한다git add 감지된 변경 사항은 클라이언트가 인덱스 영역에 보관할 지 결정할 수 있다 인덱스 영역은 tree 와 BLOB 로 구성됨 인덱스 영역 내부는 참조 개념이 적용됨git commit 인덱스에 추가된 변경 사항을 이력에 추가한다(상태를 저장) 인덱스 영역의 내용은 헤더 영역에 영구히 저장시킬 수 있다 헤더 영역은 트리의 참조를 저장한다 트리를 날려도 어딘가에 복제되고 있다 git commit –amend -m “&lt;message&gt;” : 최종 로그 메시지 변경git remote add origin &lt;remote&gt; : 원격지와 로컬 연결 git ls-remote, git remote -v : 연결된 원격지 검색git push 원격지에 없는 branch 명으로 push 했을 때 원격지에 해당 branch 생성 현재 원격 저장소 생성 과정에서 README 추가 설정하면 main branch 가 default git push –tags origin &lt;branch&gt; : 태그와 함께 push, 개발 단계를 알 수 있음 git push –all : 팀장은 최초에 환경 설정 하고 브랜치 상관없이 다 push 할 수 있다 git push - f origin &lt;branch&gt; : 강제로 push 하면 현재 log 남음git clone 생성 directory 의 이름도 지정할 수 있다 git init, git remote add, git pull 이 동시에 수행됨 remote branch엔 모든 브랜치가 저장된다 « remote branch 가 뭘까 사실상 fetch 까지 진행git pull 원격지와 로컬의 차이가 커지면 충돌이 많이 발생하기 때문에 자주 수행하기 git pull origin master : origin 원격지의 master branch 의 버전을 가져옴 download 와 merger 가 동시에 수행됨git 명령어 나머지git checkout branch 변경시 local 형상에 따라 작업 영역도 변경됨 HEAD 포인터가 달라지니깐 참조 tree 가 변경되는 거 git checkout -b &lt;branch&gt; origin/&lt;branch&gt; : branch 생성과 동시에 변경 및 mergegit fetch git fetch origin : 원격지의 모든 branch 의 모든 이력을 가져옴git merge fast-forward형상이 같을 때 브랜치 포인터만 이동함 3 way merge형상이 다를 때, merge 충돌이 생기는 상황, 동일 파일을 수정 git 은 동일한 파일을 수정하지 않으면 자동으로 merge 같은 파일을 수정했더라도 서로 다른 행을 수정하면 자동으로 merge 충돌이 발생하면 양쪽 브랜치에서 동시에 변경된 사항을 표시해주며 이중 개발자가 스스로 판단하고 결정해야함 git merge origin/&lt;branch&gt; : 해당 branch 의 이력을 현재 branch 에 merge git merge –squash : 커밋 안 된 상태로 가져옴. 이력 정리하기 좋음git rebase 이력을 합치고 싶을 때, 커밋 이력을 정리할 떄 git rebase -i HEAD~3 : 이력 순서가 v1 v2 v3 v4 일때 v2 까지의 커밋 이력을 합침 vi editor 가 실행됨 squash(찌그러트림, 압축, 로그 통합)는 과거로 찌그러트려짐 과거 이력으로 코드가 모아짐 « rebase 도 그럼 충돌 위험이 있지 않은가 코드가 모아지는 게 아니라 이력만 모아지는 거 아닌가git reflog reset 으로 커밋 이력을 제거 했을 때 한번이라도 커밋 했던 이력을 다 확인할 수 있다 참고하여 git reset –hard &lt;version&gt; 하면 된다 헤더 영역이 참조 형태로 기록되기 때문에 이러한 버전 관리가 가능하다git reset « reset 강의 다시 듣기 git reset –soft &lt;version&gt; 이전 상태로 (이력 제거) hardv2 를 reset 대상으로 지정하면 v2 로 복구시킨다 -&gt; 이후 이력이 삭제됨삭제된 이력은 reflog 를 이용하면 다시 돌아갈 수 있다 mixedv2 를 대상으로 시행하면 v2 commit 이력과 index 영역을 지우고 작업물은 그대로 놔둔다즉 변경 감지 상태로 돌아간다차라리 새로운 버전을 만드는 게 나을 수도 있다 softv2 를 대상으로 시행하면 커밋 이력만 지우고 인덱스 영역은 유지 git revert 이전 상태로 (이력 유지) 일반적으로 특정 버전을 배포했는데 문제가 생기면 문제가 생긴 commit 을 revert 한다 v3를 revert 대상으로 하면 v2로 되돌려짐git status 현재 작업 중인 파일의 상태를 확인git switch git switch -c feature/5 : bracnh 생성과 전환을 한번에 수행 새 브랜치 생성시, 현재 브랜치의 상태를 기준으로 만드니까 현재 브랜치에 대해 알아야함 여기서 말하는 상태는 인덱스 영역인지 커밋에대한 건지 이해 필요git tag git tag &lt;message&gt; git tag -n : 어느 시점에 tag 를 남겼는지 검색 push 했을 때 원격지에서 태그를 확인할 수 있다terminal 명령어touch 빈 파일 생성echo 파일 내용 작성최초 다운로드하기원격지에 연결해서 다운로드 받을 때 최초에 아무 브랜치도 없는 상황에서 다운로드 방법 git clone 하면 default branch 를 다운로드 git checkout -b &lt;branch&gt; origin/&lt;branch&gt; : 원격지가 등록 됐으니 다른 브랜치 다운로드혼자서 개발하기setting_feature 브랜치에서 환경설정 작업1. 필요한 라이브러리 다운2. 패키지 구조 설계3. 인터페이스 구조 설계dev 로 돌아가서 merge 또는 pull1. git checkout -b dev origin/main2. git merge --no-ff setting_feature : merge option(log) 남기며 merge feature 에선 커밋을 막 해도 된다 이때 rebase 를 쓴다 git rebase -i HEAD~&lt;number&gt; - ‘i’ - ‘pick’ - ‘s’ - ‘esc’ - ‘:wq’ This is the 1st comiit message &lt;&lt; commit message 삭제 의미 없는 커밋 이력은 지워라 이제 main으로 dev를 merge 할 때 이력이 넘쳐난다 main 을 push 하기 전에 tag 를 남기자 git tag blog1.0.0소규모 협업하기(팀장) 단기 소규모 프로젝트니깐 main - dev - feat 활용 Remote Repository 생성 및 README.md 추가 git clone git checkout -b dev 프로젝트 세팅 git ignore 작성 git push -all 브랜치 보호 : settings - branches - branch name pattern - require a pull reqeust merging 알림 설정 : notifications - address - email or Webhooks (실시간 알림) Collaborators - Manage access - Add people Pull Request 대응 commits - review changes 1. comment : 초안에 대한 답변2. approve : 승인 -&gt; 팀원도 merge 할 수 있게 되지만 소규모에선 팀장이 하기3. request changes : 거절 merge 방식1. create a merge commit : 그냥 이거하자2. squash and merge : 애초에 squash 교육하고 지시3. rebase and merge : 애초에 rebase 교육하고 지시실수했다고 뭐라하지 말고 실수하지 않는 환경을 구성하기주의 main, dev branch 보호하고 팀원들은 이 브랜치들에서 rebase 하지마라고 지시 실수로 dev 에서 작업한 팀원이 있다면 feat 으로 넘기고 rebase 해서 push 하도록 교육소규모 협업하기(팀원)최초1. git clone2. git checkout -b dev origin/dev반복 github issue 작성 자신이 구현할 기능을 작성하고 issue 번호를 feat 번호로 지정 여기선 issue #3 으로 예시를 듦 feat/3 branch 생성 git checkout -b feat/3 기능 구현 git commit &amp; git push origin feat/3 자신의 local branch 이름과 동일한 원격지의 branch 이름에 push pull request base branch 를 dev branch 로 변경하고 우측엔 feat/3 branch 지정 이때 draft pull request 는 단순히 코드 리뷰를 요청 5-1 요청 승인시1. git push --delete origin feat/3- 원격지의 feat/3 branch 를 삭제2. git checkout dev- merge 된 dev branch 를 local 에 동기화 해야함- local branch 를 dev 로 변경3. git pull origin dev- 원격지 dev branch 의 형상을 현재 branch 로 가져옴5-2 요청 거절시- request rebase, code error, merge conflict 등 - 상의 후 결정- 거절 후 rebase 하고 다시 올리면 error 가 발생할 텐데- git push -f origin feat/3 실행하면 강제로 local 형상을 원격지에 적용함- 이전의 pull request 의 형상이 자동으로 바뀌므로수정 완료 comment 를 작성하면 팀장에게 알림이 가서 인지할 수 있다&lt;hr/&gt;소규모 협업 프로젝트 배포 git checkout dev git pull origin dev git checkout main git merge –no–ff dev git tag {version} git push –tags origin maingithub actionsCI 도구 대신 github actionsDocker를 활용하여 AWS 엘라스틱 빈스톡 사용하지만 바로 이런식으로 넘어가면 기반이 없다배포 자동화 도구(CI Tool)github 에서 push 하거나 github 으로 request 하거나해서 github origin/main 의 코드를 넘겨주고배포 스크립트 작성 후 AWS, Azure 같은 클라우드 저장소로 넘긴 뒤에 jar(또는 war) 실행jenkins, travis 같은 CI 도구에서 배포 스크립트를 작성할 수 있다1. jar 파일을 webapp 폴더로 이동2. java -jar &lt;jar-file&gt;하지만 바로 이런식으로 넘어가면 기반이 없다그럼 어떻게 클라우드 저장소를 직접 공부하고 CI 없이 해보며 기초부터 접근해야함 최신 기술 탐내면서 바로 배포 자동화 같은 걸 공부하지 말자&lt;hr/&gt;" }, { "title": "자바 기타", "url": "/posts/new-others/", "categories": "공부, 자바", "tags": "자바, 기타", "date": "2022-07-30 09:08:00 +0900", "snippet": "String 변수의 생성 방식 두 가지생성자 매개변수를 통한 생성String str = new String(args) 인스턴스 생성이므로 독립된 heap 영역에 존재하여 동등 연산자로 비교 불가 문자열이 가지는 불변성 논리에 모순이 생김생성자를 호출하지 않는 생성String str = \"args\" heap 영역의 문자열 상수 풀에 저장됨 동등 연산자로 비교할 수 있음 참조를 잃으면 GC에 의해 제거 된다메모리를 효율적으로 사용하기 위해 인스턴스 생성을 피하자명칭 규약 상수의 이름은 모두 대문자로 기능을 위한 인터페이스의 이름은 형용사로자바에서의 API 자바 시스템을 제어하기 위해 자바에서 제공하는 명령어들을 의미 SE(JDK)를 설치하면 기본 API를 제공 패키지 내의 클래스들도 자바에서 제공하는 API 중 하나clone직접 작성한 클래스에 clone 메소드를 정의하고 싶다면Cloneable 인터페이스를 상속해야 한다이 메소드는 인스턴스의 복사본을 만들어 참조 값을 반환한다(얕은 복사)깊은 복사를 위핸 clone 메소드를 오버라이딩하고인스턴스 내부의 참조 변수에까지 clone 메소드를 사용해준다clone 오버라이딩 과정메소드 내부에 인스턴스 복사본 생성필드 복사인스턴스 반환Comparable &amp; Comparator두 개 모두 인터페이스이므로 추상 메소드의 실체화가 필요하며,리터럴에 포함되지 않는 자료형인 객체를 비교할 수 있는 수단이다.Comparable : compareTo (T o) : 자신과 매개 변수 객체를 비교 : 익명 구현 객체 의미없음. : 구현 클래스 오버라이딩Comparator : compare(T o1, T o2) : 두 매개 변수 객체를 비교 : main문에 람다식 정의 가능Comparable은 lang 패키지에 존재하기에 import 해줄 필요가 없지만Comparator는 util 패키지에 존재한다. Comparable 은 구현 클래스에 직접 오버라이딩.Comparator 는 람다식을 이용한 익명 구현 객체 생성 후 정렬 메소드의 인자로 전달.이러한 특성으로 Comparator는 다중 생성 가능하지만 Comparable의 경우 단 하나의 방식 밖에 못 쓴다.flow를 주의하여 사용하자.시각과 날짜 관련 코드의 작성java.util.Date(자바0) 구식 SimpleDateFormat 클래스로 형식 변환 java.util.Calendar(자바1) 구식(자바8) + DateTimeFormatter(Instant는 포맷 적용이 까다롭다)java.time.Instant 1970 - 01 - 01 00:00:00 부터 현재까지 흐르는 시간 중 특정 지점을 인스턴스로 생성 (UTC 기준 시간)java.time.Duration 소요 시간을 계산하는 데 이용java.time.LocalDate 시각 정보가 생략된 날짜 정보를 표현java.time.LocalTime 시각 정보를 표현java.time.period 날짜 기간을 계산하는 데 이용java.time.LocalDateTime java.time.ZoneId 협정 세계시에 따른 시각 계산을 위해 지역 지정java.time.ZonedDateTime 지역에 따른 시각을 표현할 수 있음 대부분 메소드를 사용하면 인스턴스를 수정하는 게 아니라 수정한 정보를 토대로 새로운 인스턴스를 반환한다 한국의 시간대는 UTC+9 : 협정 세계시보다 9시간이 빠름을 의미한다 Local, Zone의 기본 값은 사용자 컴퓨터에 맞춰져있다[참고] https://jaimemin.tistory.com/1537해시코드 해시 코드는 알고리즘과 데이터 구조가 객체를 구획에 넣을 수 있도록 한다 이 간단한 시스템을 사용하면 분류되지 않은 서랍에서 검색하는 것보다 훨씬 빠르게 유형을 찾을 수 있다계약동일한 객체는 실행 중인 프로세스 내에서 동일한 해시코드를 가져야 한다아래와 같은 일반적인 오해를 의미하진 않는다. 동일하지 않은 객체는 다른 해시 코드를 가져야 한다 : false 동일한 해시코드를 가진 객체는 동일하다 : false 계약에서는 동일하지 않은 객체가 동일한 해시코드를 공유하는 것을 허용한다 구별 가능한 객체의 수가 해시코드의 수(4byte)보다 많기 때문에 명백하다재정의 이로써 equals를 구현할 때마다 hashcode도 재정의해야함을 알 수 있다 그렇지 않다면 깨진 물건으로 끝날 것이다. equals 메소드를 재정의하여 일부 객체를 다른 객체와 동일하게 선언하지만 원래 해시코드는 모든 객체를 다른 것으로 취급한다 따라서 해시코드가 다른 동일한 객체를 갖게 된다 특정할 수 있는 필드 값에 대한 연산을 이용하여 재정의충돌 두 개의 서로 다른 객체가 동일한 해시코드를 가질 때, 이를 충돌이라 한다 충돌은 중요하지 않으며, 단일 버킷에 둘 이상의 객체가 있음을 의미한다 해시코드를 객체에 대한 고유 핸들로 착각하면, 예를 들어 Map의 Key로 사용할 때, 때때로 잘못된 결과를 얻게 된다 충돌은 드물지만 피할 수 없기 때문이다(System 클래스의 hashcode 메소드를 사용하여 얻은 정수를16진수로 표현한 게 Object 클래스의 메소드)etc 지역 변수는 스코프를 벗어나면 메모리에서 소멸된다. 정보 은닉 : 자바에서 말하는 ‘정보’는 클래스의 ‘인스턴스 변수’를 의미한다 따라서 정보를 은닉한다는 것은 위 변수를 숨긴다는 뜻 (private 선언) 캡슐화 : 하나의 목적을 이루기 위해 관련된 사항을 하나의 클래스에 담음 참조를 목적으로 정적 멤버를 선언할 때, final 선언에 대한 여부를 고민 main 메소드의 호출이 이뤄지는 영역은 클래스 외부. 당연히 public 선언해야함 콘솔 : 컴퓨터를 대상으로 데이터 입출력을 담당하는 장치를 총칭 toString, equals, hashcode 오버라이딩 권장 어노테이션은 컴파일러에게 메시지를 전달하는 목적의 메모 자바5부터 오버라이딩 과정에서 반환 타입의 수정을 허용한다. 단 클래스 이름과 관련한 조건이 있다 다른 프로젝트에 있는 클래스는 ‘jar’ 추출 후 라이브러리로 추가하자 값은 웬만하면 변수에 대입하자. 협업에 유리하다 소스코드에 데이터를 직접 기입하면 유지보수에 애로사항이 생길 것이다 가변 인자를 전달하면 컴파일러가 배열로 해석한다 터미널 컴파일시 -Xlint(enable recommended warnings)로 경고 확인 가능 버퍼란 동작 속도가 크게 다른 두 장치 사이에 접속되어 속도 차를 조정하기 위하여 이용되는 일시적인 저장 장치 메소드는 단 한가지의 기능만 수행하도록 작성하자 도트 연산자는 한 줄에 하나만 쓰도록 하자 인터페이스와 컴포지션으로 기능을 분리하여 OCP 원칙을 지키자 컴포지션에 매몰되면 상속의 이점을 놓친다 메소드 매개변수와 반환 타입은 최대한 인터페이스로 정의하자 instanceof 를 이용한 분기문보단 다형성을 이용하자 불변식은 Thread-safe를 보증한다는 말도 된다 클라이언트로부터 데이터를 보호하기 위해 방어적 복사를 지향하자 동등성을 판별하는 필드로 최적화된 건 Primary Key 재귀보단 반복문을 사용하자. 순환 참조(Stack overflow) 위험이 있다 Optional과 Collection Stream은 가독성을 챙기기 좋은 수단 상태를 가지는 객체를 정의했다면 제대로 된 역할을 하도록 구현하자 객체가 로직을 구현하도록 해야하며 데이터를 꺼내지 않고 객체에 메시지를 보내 일을 하도록 리팩토링해야 한다 비즈니스 로직은 DB가 아닌 앱에 넣자. 일반적으로 app 서버 리소스가 DB 서버 리소스보다 확장하기 훨씬 더 쉽기 때문에 대용량 데이터 중 소수만 가져오는 로직이 아닌 이상 DB 리소스 사용을 최소화하자 인스턴스 필드의 개수가 많아 초기화할 매개 변수의 양이 늘어났을 때 빌더 패턴을 고려하자. 계층 구조에서 활용할 수 있으며 현재 필드가 적더라도 늘어날 가능성이 있다면 비용은 뒤로하고 고려해보자 향상된 for문은 iterable 구현 클래스와 일반 배열만 사용 가능하다 for(Iterator&lt;String&gt; str = strings.iterator(); str.hasNext()) 로 표현 가능 또는 선언은 외부에 하고 while 문에 hasNext 를 등록할 시 동일한 표현 향상된 for문 내부에서 해당 컬렉션의 수정은 자제하자Q Comparator 인터페이스 구현 클래스는 꼭 따로 작성해줘야 되나? 병렬 스트림 활용 사례 I/O 스트림 모델 I/O 스트림은 반드시 1바이트를 int형으로 전환하는 과정이 필요한가 JVM이 문자를 메모리에 저장할 때 UTF-16 방식을 사용하는가 JVM의 인코딩 방식을 직접 설정할 수 있는가 요청이 올 때마다 스레드가 생성되는데 서버에는 얼마나 많은 코어가 존재하는가 컴포지션과 상속의 장단점 빌더 패턴에서 말하는 계층 구조 활용 printf 와 format 메소드 관계 Enum 상수의 수가 많아질 때 익명 자식 객체의 필요성" }, { "title": "자바 문자열 인코딩", "url": "/posts/new-java-charset/", "categories": "공부, 자바", "tags": "자바, 인코딩", "date": "2022-07-30 09:07:00 +0900", "snippet": "문자 인코딩 하드웨어는 숫자 밖에 인식할 수 없어 문자에 개별 숫자를 부여해야한다. “문자 A는 숫자 65로 표시하기로 약속한다.” 이러한 문자 표현에 대한 약속을 가리켜 ‘문자 셋’이라고 한다. 유니코드는 모든 나라의 문자를 수용하여 전 세계적으로 사용하는 문자 셋이다. 자바가 유니코드를 지원하더라도 문자의 출력은 운영체제에 의존적이다. 출력하고자 하는 언어의 폰트가 운영체제에 설치되어 있어야 한다. 자바 char 타입은 2byte로 유니코드를 표현한다UTF-8 UTF-8은 UTF-16이 7bit로 표현 가능한 아스키코드 문자를 16bit를 표현하자, 메모리 낭비를 막기 위해 탄생한 인코딩 방식이다 UTF-8은 16bit 유니코드 문자를 지원함에도 아스키코드 문자를 7bit로 표현한다 한글은 유니코드에 속하므로 1byte로 표현할 수 없다유니코드 처리- 7bit만으로 아스키코드의 문자를 표현하다보니 유니코드 문자가 들어오면 문자를 인식하는 과정에서 오류가 발생할 수 있다- UTF-8은 이러한 오류를 피하고자 헤더가 추가되어 3byte를 차지하게 되었다 아스키코드가 주로 사용되는 환경에서는 UTF-8이 유리하지만 다양한 문자가 사용되는 공간이라면 메모리와 임의 접근 효율에서 떨어진다 그러므로 JVM은 문자를 메모리에 저장할 때 UTF-16를 사용하여 저장한다 (JVM 외부와 데이터를 주고 받을 때 다양한 언어를 접하므로 합리적임) 요즘은 UTF-8로 통일되어있어 실제로 JVM이 UTF-16을 사용하는지 검색UTF-16 -&gt; UTF-8 전환 과정1110 xxxx, 10xx xxxx, 10xx xxxx헤더와 함께 16bit 이진수 데이터가 순차적으로 삽입됨[참고] https://st-lab.tistory.com/41" }, { "title": "자바 추상 클래스와 인터페이스", "url": "/posts/new-java-abstract-interface/", "categories": "공부, 자바", "tags": "자바, 추상클래스, 인터페이스", "date": "2022-07-30 09:06:00 +0900", "snippet": "추상클래스와 인터페이스추상클래스- 객체 생성이 불가능하고 추상 메소드를 선언할 수 있는 점을 제외하면 일반 클래스가 하는 대부분의 기능을 수행할 수 있다- 일반 클래스와 같이 단일 상속만 가능하다- 관련성이 높은 클래스 간 코드를 공유하고 싶은 경우- 관련성이 높기 때문에 상속 받는 클래스가 필수로 가질 행동을 지정- 클래스 스스로 기능을 수행한다면 추상 클래스는 필요 없다- 주 목적은, 상속받은 자식 클래스의 기능 확장에 있다##인터페이스- 자바 버전이 올라가면서, 기존엔 상수 필드와 추상 메소드만 제공했지만디폴트 메소드와 정적 메소드를 추가할 수 있게 되었다- 일반 클래스와 달리 다중 상속이 가능하다- 인터페이스도 결국 클래스의 일종이다- 관련성이 없는 클래스들이 기능만을 구현하여 사용- 특정 객체의 행동을 명시하고 싶은데, 내부 구현에 대해 신경쓰지 않고 싶을때- 결합도를 느슨하게 만들어주는 좋은 도구다 물론 인터페이스가 더 중요하고 자주 쓰이지만 그렇다고 모든 것을 인터페이스로 처리하려 한다면, 공통적으로 필요한 기능도 모든 클래스에서 재정의해야하는 번거로움이 생길 수 있다참고 is a kind of (추상 클래스)같은 종류의 하위 클래스를 만든다 be able to (인터페이스)사용 방법이 동일한 클래스를 만든다" }, { "title": "자바 스레드", "url": "/posts/new-java-thread/", "categories": "공부, 자바", "tags": "자바, 스레드", "date": "2022-07-30 09:05:00 +0900", "snippet": "스레드 멀티 코어 CPU가 대중화되어 자바는 언어 차원에서 병렬 처리를 지원한다 스레드 하나에 CPU의 코어 하나가 할당된다동기화 처리임계 영역 : 멀티 스레드 환경에서 단 하나의 스레드만 실행할 수 있는 코드 영역임계 영역은 곧, 동기화가 적용된 구역이다 Synchronized ReentrantLock volatile atomic스레드 풀 스레드 생성과 소멸은 그 자체로 시스템에 부담을 주는 일 이러한 성능 저하를 피하기 위해 미리 제한된 수의 쓰레드를 생성해두고 이를 재활용하는 스레드 풀을 사용한다자바가 제공하는 스레드 풀 “ExecutorService”- submit 메소드의 인자로 들어가는 구현 객체에 따라 반환값 여부 결정 Runnable, Callable (+Future) 작업 종료와 관련된 내용이 많다. 궁금하면 찾아보자## 운영체제에서는 실행중인 하나의 앱을 프로세스라고 부른다 사용자가 앱을 실행하면 운영체제로부터 실행에 필요한 메모리를 할당받아 앱의 코드를 실행하는데, 이것이 프로세스다멀티 프로세스- 하나의 앱은 멀티 프로세스를 만들기도 한다- 예를 들어 메모장 앱을 2개 실행했다면 2개의 프로세스가 생성된 것이다- 운영체제는 두 가지 이상의 작업을 동시에 처리하는 멀티태스킹을 할 수 있도록 CPU 및 메모리 자원을 프로세스마다 적절히 할당해주고, 병렬로 실행시킨다 예를 들어, 워드로 문서 작업을 하면서 메신저도 이용할 수 있다- 멀티 태스킹이 꼭 멀티 프로세스를 뜻하는 것은 아니다- 한 프로세스 내에서 멀티 태스킹을 할 수 있도록 만들어진 앱도 있다 대표적인 예로, 미디어 플레이어와 메신저가 있다 멀티 프로세스는 자신의 메모리를 가지고 실행하므로 서로 독립적이지만, 멀티 스레드는 하나의 프로세스 내부에 생성되므로 스레드하나가 예외를 발생시키면 다른 스레드도 영향을 받는다멀티 스레드- 하나의 프로세스에서 두 가지 이상의 작업을 처리할 수 있음- 멀티 스레드로 동작하는 메신저의 경우 파일을 전송하는 스레드에서 예외가 발생하면 메신저 프로세스 자체가 종료되므로 채팅 스레드도 같이 종료된다 그렇기 때문에 멀티 스레드에서는 예외 처리에 만전을 기해야 한다데몬 스레드- 스레드의 작업을 돕는 보조 역할을 함- 예를 들어, 워드프로세서의 자동 저장, 미디어 플레이어의 동영상 및 음악 재생 등이 있다 자바의 모든 앱은 메인 스레드가 메인 메소드를 실행하면서 시작한다 이때 메인 스레드는 필요에따라 작업 스레드들을 만들어서 병렬로 코드를 실행할 수 있다 즉 멀티 스레드를 생성해서 멀티 태스킹을 수행하는 것이다 멀티 스레드 앱에서는 실행중인 스레드가 하나라도 있다면 메인 스레드가 종료되더라도 프로세스가 종료되지 않는다" }, { "title": "자바 I/O 스트림", "url": "/posts/new-java-IOstream/", "categories": "공부, 자바", "tags": "자바, I/O스트림", "date": "2022-07-30 09:04:00 +0900", "snippet": "I/O 스트림 스트림이란 ‘데이터의 흐름’을 의미한다 여기선 데이터의 이동 통로로 받아들이면 편하다 컬렉션 스트림과 달리 데이터 입출력에 대한 내용이다 (I/O 스트림은 java.io, 컬렉션 스트림은 java.util.stream 소속) 입출력 대상은 파일, 하드웨어, 서버 또는 클라이언트 등 다양하다 입출력 대상이 달라지면 코드상 입출력 방법도 달라지는 것이 일반적인데 자바에서는 I/O 스트림 모델이라는 것을 정의하여 이를 해결하였다 할당된 메모리 자원은 스트림을 소멸시켜 다시 사용할 수 있도록 반환해야 된다기본적인 데이터의 입출력 단위는 바이트- 데이터 입력시 1바이트의 유효한 데이터에 3바이트의 0을 채워넣어 int형 데이터로 반환한다 즉, 반환하는 값의 정상 범위는 1바이트 크기에 해당하는 0~255이다- 반대로 데이터 출력시 int형 데이터를 보내지만 첫 번째 바이트만 입력받는다- 이와 같이 파일의 크기에 상관없이 1바이트씩 통신하면 제법 골치 아픈 일이다 바이트 스트림에 byte 타입 배열을 주고 받는 것도 가능하다버퍼 스트림- 다양한 필터 스트림 중 버퍼 스트림은 특히 사용 빈도가 높다- 버퍼 스트림은 내부에 메모리 공간을 가진다- 파일에 빈번히 접근하는 행위를 줄이는 게 핵심- 버퍼 스트림에 필터 스트림을 조합하여 효율적으로 스트림을 구성할 수 있다객체 직렬화- 객체를 입출력 함- 객체 입출력의 대상이 되는 클래스는 Serializable 인터페이스를 상속- 인스턴스 자체를 입출력하므로 참조 인스턴스까지 함께 저장된다 하지만 이 과정에선 참조 인스턴스의 클래스도 마커 인터페이스를 상속해야한다- 참조까진 저장하고 싶지 않다면 transient 선언을 추가한다 이는 기본 자료형 변수에도 해당된다NIO- new I/O 라 말할 수 있으며 기존 I/O 패키지의 보완 api- 자바4 : java.nio, 자바7 : java.nio.file- 입출력 스트림을 이용할 일이 생기면 참고해볼 것" }, { "title": "자바 컬렉션 프레임워크", "url": "/posts/new-java-collection/", "categories": "공부, 자바", "tags": "자바, 컬렉션프레임워크", "date": "2022-07-30 09:03:00 +0900", "snippet": "컬렉션 프레임워크java.util.concurrent 동기화된 컬렉션은 멀티 스레드 환경에서 하나의 스레드가 요소를 안전하게 처리하도록 도와주지만, 전체 요소를 빠르게 처리하진 못한다 스레드가 작업할 때 락이 발생하기 때문에 병렬 처리가 불가능 자바에서는 이 문제를 해결하기 위해 concurrent 라이브러리를 제공 이 구현체들은 부분(segment) 잠금을 사용하기 때문에 병렬 작업 수행 가능hashcode signature 에 Hash 가 붙어있을 때 hashcode 를 구현하면 접근 성능이 좋아진다ListArrayList 동적 가변 배열 비동기 방식. 스레드 안전하지 못함 멀티 스레드 환경에서는 Collecion.sychronizedList 사용 특정 인덱스에 객체 삽입 시 전체 인덱스가 밀리므로 인덱스 변경이 빈번하다면 LinkedList 를 사용LinkedList 각 노드가 데이터와 포인터를 가지고 연결된 구조 노드의 포인터가 이전 이후 노드와의 연결을 담당 인덱스 구조가 아니므로 삽입 삭제에 유리함Vector Collecion.sychronizedList 로 대체Stack Deque 로 대체QueueQueue interface 인터페이스이므로 구현체가 필요하며 주로 LinkedList 를 이용함 노드 연결인지 오브젝트 배열인지의 여부에따라 LinkedList or ArrayDequePriority Queue FIFO가 아닌 특정 우선 순위에 따라 우선 순위가 높은 요소가 먼저 삭제 Default로 낮은 숫자가 높은 우선 순위를 가진다 참조 타입일 경우 Comparator 또는 Comparable 을 통해 정렬 방식을 구현 null 을 허용하지 않는다Deque interface Queue 의 삽입 삭제가 한 쪽에서만 가능하다면 Deque 는 양쪽에서 삽입 삭제가 가능하다 사용 방식에 따라 Stack 이 될 수 있고 Queue 가 될 수 있다ArrayDeque 사이즈 제한이 없는 가변 배열이며 null 비허용, 비동기 원형 Queue 방식 성능상 Stack, LinkedList 를 대체할 수 있다. 기존 Queue 대신 사용하면 된다SetSet 집합. 중복 저장 불가, 데이터의 순서를 보장하지 않음 equals 를 이용한 중복 검사LinkedHashSet 입력 순서를 보장함 LinkedHashMap 을 통해 구현되어 있다HashSet hash 알고리즘을 사용하여 검색 속도가 빠르다 HashMap 을 통해 구현되어 있다TreeSet 정렬을 적용할 수 있어 특정 구간의 집합 요소를 탐색할 때 유용하다 Tree 자체가 일정 순서에 의해 정렬된 자료구조 TreeMap 을 통해 구현되어 있다MapMap 값을 키애 매핑하는 객체다 key 중복 저장 불가, 데이터의 순서를 보장하지 않음 equals 를 이용한 key 중복 검사HashMap 정렬되지 않은 Map 제공 하나의 null key 와 다수의 null value 를 허용 멀티 스레드 환경에서는 ConcurrentHashMap 사용HashTable ConcurrentHashMap 으로 대체LinkedHashMap 입력 순서를 보장함 변경은 느리지만 HashMap 보다 빠른 조회 성능TreeMap 정렬 된 Map Red Black Tree 로 구현되어 있다 Default로 낮은 숫자가 높은 우선 순위를 가진다 참조 타입일 경우 Comparator 또는 Comparable 을 통해 정렬 방식을 구현" }, { "title": "자바 제네릭", "url": "/posts/new-java-generic/", "categories": "공부, 자바", "tags": "자바, 제네릭", "date": "2022-07-30 09:02:00 +0900", "snippet": "제네릭제네릭 타입이 없다면 Object 객체를 생성하여 이용할 수 있지만이땐 명시적 형변환을 요하는 상황이 반드시 나타난다결국 반드시 실수하는 경우가 생길 것이다 =&gt; RuntimeException제네릭이 등장하면서 자료형에 의존적이지 않은 클래스를 정의할 수 있다하지만 단순히 제네릭이 타입 의존성에서 벗어난다는 건 착각이다컴파일 환경에서 raw타입과 달리 타입에 대한 제약이 생긴다이 때문에 타입 검사가 엄격히 이루어져 컴파일 단계에서Runtime Exception을 방지할 수 있다이는 자바스크립트의 var와 비교해서 생각해보면 된다런타임 환경에서의 제네릭 타입은 호환을 위해 타입 소거가 발생한다(와일드 카드는 런타임 환경에서 타입이 실체화됨)인스턴스 생성 시 타입 인자를 통해 자료형을 결정하는 것이 제네릭이다보편적으로 사용하는 타입 매개변수 E : Elements K : Key N : Number T : Type V : Value매개변수화 타입도 타입 인자로 줄 수 있다 타입 인자를 제한했을 때 클래스 내부에서 동일한 타입 매개변수로 선언된 필드에제한의 기준이 되는 클래스의 메소드를 사용하여 접근할 수 있다 하나의 클래스와 하나 이상의 인터페이스에 대해 동시에 제한할 수 있다정적 메소드의 제네릭은 직접 선언해줘야 한다(제네릭 메소드 = 제네릭 정적 메소드)제네릭 클래스는 인스턴스 생성 시 자료형이 결정되는 반면에,제네릭 메소드는 메소드 호출시에 자료형이 결정된다 제네릭 메소드를 이용할 때 컴파일러는 전달되는 인자를 보고 타입 유추이러한 자료형의 유추는 오토 박싱까지 감안하여 이뤄진다제네릭 메소드도 타입 인자의 제한과 메소드 활용이 똑같이 이루어진다자바7부터 컴파일러의 자료형 유추 범위가 넓어져서 제네릭 메소드의 인자가 없더라도 메소드 부분의 제네릭 선언은 생략할 수 있다와일드 카드제네릭 선언된 정적 메소드의 기본형과선언 없이 인자에 &lt;?&gt;를 작성하는 것은 상호 대체 가능한 동일한 메소드이다Box를 매개변수로 작성하면 Box도 받을 수 있을 것 같지만Object와 Integer가 상속 관계라 할 지 언정 Box와 Box는 상속 관계가 아니다.Box&lt;? extends Number&gt;Number 클래스와 그를 상속한 클래스만 가능한 와일드 카드의 선언extends: 상한 제한, super: 하한 제한매개변수화 타입에서 (Box box) T의 범위를 제한한다.제한이 없을 때의 안정성을 생각해보면, 와일드카드는 어렵지만 절대 필요없진 않다.필요한 만큼만 기능을 허용하여, 코드의 오류가 컴파일 과정에서 최대한 발견되도록 한다제네릭 메소드의 매개변수화 타입에 와일드 카드의 상한 제한을 선언하면매개변수화 타입을 참조하는 변수를 대상으로 저장하는 기능(Setter)의메소드 호출은 불가능하다Box&lt;? extend Toy&gt; 의 경우 Toy 클래스를 상속하는 다른 클래스의 인스턴스가 형 변환 되어 저장되었을 수도 있다. 그러므로 컴파일러는 사전에 setter 메소드를 막아버렸다컴파일 에러는 자바에서 막아버리는 것이다반대의 겨우인 하한 제한에서는 getter 후 특정 클래스 타입의 참조 변수에 대입하는 것을 막는다.따라서 와일드 카드에서의 타입 제한은 box가 참조하는 인스턴스를 대상으로 꺼내거나 저장하는 기능의 메소드 호출을 불가능하게 만든다.public static void outBox(Box&lt;? extend Toy&gt; box) {};public static void outBox(Box&lt;? extend Robot&gt; box) {};제네릭 메소드의 정의로 Type Erasure를 피해간다.제네릭 클래스를 상속할 때 슈퍼 클래스의 타입 인자에 대한 지정을 서브 클래스에서 해줘야한다.하지만 extends Class 과 같이 상속과 동시에 지정해주면서브 클래스를 제네릭으로 정의할 필요 없다.인터페이스를 상속할 때도 모든 게 동일하게 적용된다Comparable 분석Collections.sort 를 사용하기 위해선 아래 메소드의 문장을 설명할 수 있어야 한다.public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list){};Comparable 인터페이스를 구현한 Car 클래스를 상속한 SubCar 클래스를 생각해보면 List가 대입 됐을때```&lt;SubCar extends Comparable&gt; void sort(List list)```위와 같이 변경되어 Super 클래스가 Comparable을 구현한 상태일 때 SubCar로도 이 메소드를 사용할 수 있다." }, { "title": "자바 JVM", "url": "/posts/new-java-jvm/", "categories": "공부, 자바", "tags": "자바, JVM", "date": "2022-07-30 09:01:00 +0900", "snippet": "JVM 운영체제마다 JVM 종류가 다름 프로그램 실행에 필요한 메모리 공간을 가리켜 메인 메모리라 하며, 이는 물리적으로 램을 의미한다 메모리의 효율적인 사용을 위해서 운영체제가 메모리를 관리한다 JVM은 운영체제에서 메모리를 할당 받고 효율적으로 사용한다메모리 영역메모리 공간은 크게 메소드, 스택, 힙 영역으로 나뉜다메소드 영역메소드의 바이트 코드(class 확장자), 정적 변수스택 영역지역 변수, 매개 변수지역 변수 : 특정 스코프 내에서만 유효한 변수스코프 내에 할당된 이후 스코프가 종료되면 바로 소멸되는 특성의 데이터 저장힙 영역인스턴스, 메모리 크기의 제한이 없고 스택에 비해 느림메모리 관리를 직접하며 GC의 활동 영역##인스턴스를 스택 영역이 아닌 힙 영역에 분리-보관하는 건 지역 변수와의 생명 주기가 달라서이다스택 영역에 보관되는 참조 변수에 힙 영역 인스턴스의 주소를 저장하여 교류하는데인스턴스의 소멸은 JVM에서 직접 결정하므로인스턴스와 연결된 참조 변수에 null을 대입함으로써스택 영역의 참조 변수 소멸 판단에 도움을 줄 수 있다해당 인스턴스의 주소를 참조하는 변수가 없기 때문이다사실상 인스턴스에 더이상 접근할 수도 없기 때문이다(인스턴스를 참조하는 변수가 1개인 상황으로 전제)" }, { "title": "자바 기본", "url": "/posts/new-java/", "categories": "공부, 자바", "tags": "자바", "date": "2022-07-30 09:00:00 +0900", "snippet": "변수와 타입변수 데이터의 저장과 참조를 위해 ‘할당된 메모리 공간’에 붙인 이름 기본 타입 이진수의 음수화 : 1의 보수화 후 1을 더함. 올림 수는 버림 소수점 기준, float, double은 각각 6, 15자리의 정밀도를 갖는다 long 타입 정수를 표현할 때 리터럴 끝에 ‘L’ 문자 추가 숫자 표현, 리터럴 표현 - 2진수 : 0B   8진수 : 0   16진수 : 0x 숫자 리터럴 표현 시 ‘100_000’ 처럼 언더바 사용 가능. 컴파일 과정에서 제거됨 제곱수의 표현 - 3.4e3 == 3.4 x 10^3 타입 변환 자동 형변환 : 자료형의 크기가 큰 방향으로 형 변환이 일어남 자료형의 크기에 상관없이 정수 자료형보다 실수 자료형이 우선함 정수형 -&gt; 실수형 변환시 오차는 존재하겠지만 데이터의 손실은 발생하지 않음CHAPTER 3 연산자연산자와 연산식 정수형 연산을 4byte int형으로 진행 연산을 동반하는 상황에선 byte, short 타입으로 선언하더라도 생각만큼 메모리가 절약되지 않고, 오히려 타입 변환 과정만 추가됨 서로 다른 타입의 피연산자가 산술 연산식에 존재한다면, 더 큰 메모리를 할당하는 피연산자의 타입이 연산식의 결과에 부여된다. 실수 연산은 기본적으로 오차가 존재한다고 가정해야 한다. 연산 시 소수점 이하 셋째 자리에서 오차가 발견될 수도 있다. 연산자의 종류 비교 연산자에서 실수 비교는 자제한다. 쉬프트 연산자 예시 int num = A &lt;&lt; Z : A의 비트 열을 Z만큼 왼쪽으로 이동 0000_0001의 경우 ‘«’ 하면 2씩 곱해지는 거와 마찬가지조건문과 반복문조건문: if문, switch문 삼항 연산자로 간단한 if-else 처리참조 타입참조 타입과 참조 변수 상수(final)는 값을 단 한번만 할당할 수 있으며 변경 불가하다 배열 fill 메소드를 통해 특정 인자를 받아 한번에 초기화할 수 있다 배열 복사 관련 메소드가 존재하므로 검색 활용 sort 메소드는 compareTo 메소드를 이용하여 정렬 기준을 설정 열거 타입 enum 등장으로 정수 열거형을 별도 타입으로 빼낼 수 있게 됨 구식 방법인 정수형 열거의 대안이다 싱글턴, enumMap, enumSet 그리고 방어적 복사를 생략할 수 있는 강력한 불변객체로 활용할 수 있다클래스필드 필드는 필드 답게, 객체의 속성과 관련 없는 변수는 최대한 지역 변수로인스턴스 멤버와 정적 멤버 JVM에서 클래스 로드가 완료돼야 인스턴스 생성이 가능한데 클래스가 로드되는 시점에 정적 멤버는 이미 메모리 영역에 할당되어 있다 클래스 내부에 블록 스코프를 활용하여 정적 메소드를 클래스 로드 시점에 호출할 수 있다 정적 멤버는 인스턴스 없이 사용할 수 있고 불필요한 메모리 할당을 방지할 수 있지만 이 때문에 오히려 불필요한 메모리를 할당하는 걸로 볼 수도 있다 정적 멤버는 공유되고 반복되는 상황에서 효율적이다상속과 추상클래스상속 연관된 일련의 클래스들에 대해 공통 규약을 정의 자식 클래스 인스턴스 생성시 부모 클래스 생성자가 먼저, 함께 호출된다 private 멤버는 자식 클래스에서 직접 접근할 수 없다. 상속 관계에서의 필드 선언 시 동일한 변수를 사용하지 않도록 주의 정적 클래스는 오버라이딩의 대상이 아니다 부모 타입의 구현 객체를 자식 객체로 했을 때 부모 타입의 멤버에만 접근 가능하고, 재정의된 메소드가 있다면 자식 메소드가 호출됨 is-a 관계과 명확할 때 추상 클래스 일반 클래스의 상속과 달리 추상 클래스는 객체 생성이 불가능하다 추상 클래스는 하나의 규격이라 보면 되고 인터페이스가 좀더 추상적이다 실체 클래스가 공통적으로 가져야할 멤버를 정의해놓으며 멤버 통일에 목적인터페이스인터페이스 이미 형성된 계층 트리에서 인터페이스에 새로운 추상 메소드를 추가하긴 힘들다 이런 상황에서는 실체화가 필요 없는 디폴트 메소드를 활용하자 정적 메소드를 활용하여 인터페이스만으로 메소드 사용이 가능하다 주로 정적 멤버 인터페이스를 많이 사용하는데, UI 프로그래밍에서 이벤트를 처리할 목적으로 많이 활용된다 주로 has-a 관계 타입 변환과 다형성 자식 instanceof 부모는 참이다중첩 클래스와 중첩 인터페이스중첩 클래스와 중첩 인터페이스 소개 정적 중첩 클래스나 인스턴스 중첩 클래스에서 바깥 클래스의 필드가 private이어도 참조 가능 중첩 클래스는 해당 클래스 정의를 감추어야할 때 유용하게 사용 된다 컬렉션 프레임워크의 iterator 메소드도 Iterator 인터페이스를 구현한 중첩 클래스를 이용하는 것이다 일반적으로 바깥 클래스 외부에서 해당 클래스의 중첩 클래스 객체를 생성하는 일은 거의 없다 메소드 소속 중첩 클래스의 경우 메소드 내에서 객체를 생성하고 사용한다 주로 비동기 처리를 위해 스레드 객체를 만들 때 사용된다 중첩 인터페이스의 경우 주로 정적 중첩 인터페이스로만 선언하며 UI 프로그래밍에서 이벤트를 처리할 목적으로 자주 활용되며 필드 멤버로만 선언된다 익명 객체 익명 객체의 가장 단순한 형태new Printable()&lt;익명&gt;{ 실체 메소드 (...) {...}; } 생성자에 바로 스코프와 함께 메소드 정의가 이루어진다 인터페이스는 본래 자신이 구현 객체가 될 수 없지만 이러한 방식으로는 가능하다 자식 클래스 또는 구현 클래스가 재사용되지 않고 오로지 특정 위치에서 사용할 경우라면 명시적으로 선언하는 것이 귀찮은 작업이므로 익명 클래스를 고려해볼만 하다 ex) comparator예외 처리예외 클래스 에러 : 하드웨어 오동작으로 발생 예외 : 프로그램 자체 오류 Exception 클래스를 상속하는 예외 중 RuntimeException을 제외한 예외에 대해선 예외 처리가 필수적 직접 Exception을 상속하여 정의할 수도 있다 예외 처리 main 메소드로 예외를 넘기면, 이 예외는 호출 주체인 가상머신에게 넘어감 즉, 프로그램이 종료됨 과도한 예외 처리는 성능 저하로 이어진다 종료해야될 리소스가 존재한다면 finally 스코프에 기입한다 유효성 부적합 판정을 받았을 때 return이 아닌 비검사 예외를 명시하되 표준 예외를 사용하자 try/catch를 남발하면 오류가 발생했을 때 제어 흐름이 중단되지 않아 부차적 문제를 발생시킬 수 있고 stack trace를 보존하지 않는 로깅은 디버깅을 어렵게 만드는 일이다. 책임지지 못할 오류는 잡지 않는다 그래야 JVM이든 어딘가에서 로그를 남길 수 있기 떄문이다기본 API 클래스java.lang 패키지Wrapper toString 오버라이딩 되어있어 출력시 주소가 아닌 값이 나온다 자동 박싱, 언박싱이 지원된다 모든 Wrapper 클래스는 Number 클래스를 상속한다Big 생성자 매개변수로 문자열 형태의 숫자를 대입함 BigInteger : long 범위를 벗어난 정수를 표현 BigDecimal : double 범위를 벗어난 실수를 표현 java.util 패키지 StringBuilder : 내부에 문자열 관리를 위한 메모리 공간이 존재하여 메소드 체인으로 참조 변수의 데이터를 변환하는 형식 기존 String concat 메소드와 비교하여 메모리에 유리함 StringBuffer의 대안. 스레드 안전하진 않지만 싱글 스레드상 속도 우위 Scanner : 생성자로 전달되는 대상으로부터 데이터를 추출하는 기능을 제공 StringTokenizer : 특정 기준을 가지고 문자열을 작게 나누어야할 때 사용 토큰 : 구분자를 기준으로 나뉜 문자열 조각 parsing이 필요하고 짧은 입력 값이면 Scanner 단순히 한 줄씩 읽거나 입력 값이 많다면 BufferReader컬렉션 프레임워크컬렉션 프레임워크 인스턴스의 저장을 목적으로 하는 자료구조 중 정형화된 것 배열보다 컬렉션을 지향하는 이유는 제네릭 타입과 데이터 조작 시 다양한 api가 주는 편리함 때문이다 중복 판단과 정렬 등에 equals, hashcode, compare 등을 이용함 버킷의 개수가 예상된다면 생성자의 인자로 넣어 버킷의 개수를 늘리는 과정을 최대한 배제시키자 동기화된 클래스로 Vector, Stack, HashTable 등이 있지만 보완품이 있다 Tree는 자체적으로 인스턴스를 정렬한다 이진 탐색을 하려면 올바르게 정렬해야 한다 Arrays.asList의 반환 타입은 update 관련 메소드를 사용할 수 없다 수정이 필요하다면 new 연산자를 통한 ArrayList를 이용하면 된다 둘다 stream은 이용할 수 있다 Map은 Iterable 인터페이스를 구현하지 않으므로 직접 반복문을 활용할 수 없다 메소드를 활용하여 타입 변환한 뒤 순차적 접근이 가능하다 Stack 대신 Deque-ArrayDeque 를 사용하자 (Spec 권장) ArrayDeque는 스레드 안전하지 않기 때문에 멀티 스레드 환경에서는 LinkedBlockingDeque, ConcurrentLinkedDeque 를 이용하자 전자는 멀티 스레드 환경의 단일 스레드, 후자는 멀티 스레드 권장네트워크소켓 멀티 스레드 환경에서 서버 소켓은 클라이언트 소켓이 connect 하였을 때 connection 에 대한 listener 인 accept 메소드로 인지한 뒤 클라이언트 소켓과 1대1로 연결된 소켓을 반환한다 이 소켓은 서버 소켓과 동일한 포트를 갖는다.모던 자바람다 익명 클래스와 내부 동작 원리는 다르다 Predicate, Supplier, Consumer, Function&lt;T, R&gt; 추상 메소드가 단 하나만 존재하는 함수형 인터페이스일 때 람다 사용 가능 람다식을 더 줄인 게 메소드 참조 (System.out::println) () -&gt; obj.method 같은 건 Object::method 로 변환하자 옵셔널 NullPointerException의 if 로직 대응 코드를 대체할 수 있음 NPE 방어 로직은 가독성과 유지 보수성이 떨어진다 컬렉션 스트림 컬렉션 데이터를 추상화하고 순차적으로 처리하는 데 쓰인다 기존 반복문으로 처리하던 게 내부에서 동작할 뿐이다 지연 처리 방식 적용으로 최종 연산 메소드를 호출해야 실행 된다Parallel Stream 병렬 처리의 경우 CPU 코어 개수가 그에 맞게 필요하다 병렬 처리는 연산의 횟수를 줄이는데 있지 않고 연산의 단계를 줄이는데 있다 스레드와 같이 병렬 처리를 남용하면 성능 저하만 초래한다[참고] https://sejoung.github.io/2019/01/2019-01-31-java8_stream_tutorial_examples/" }, { "title": "HTTP - 7 - header - caching & conditional request", "url": "/posts/http-7-header-cache-conditional-request/", "categories": "공부, HTTP", "tags": "HTTP, 자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "## 인프런 김영한님의 강의 내용 기록 ## HTTP 헤더2 (캐시와 조건부 요청) - - - - 캐시가 없을 때 -데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다.인터넷 네트워크는 매우 느리고 비싸다.브라우저 로딩 속도가 느리다.느린 사용자 경험. 캐시 적용 -헤더에 cache-control : max-age = ~~sec웹 브라우저에는 캐시 저장소가 있다.다음 요청에선 브라우저 캐시를 먼저 탐색하고 가져온다. 캐시 시간 초과 -유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다이때 다시 네트워크 다운로드가 발생한다.검증 헤더 : 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터 검증 헤더와 조건부 요청 1 - - 응답 Last-Modified : ~~ UTC웹 브라우저가 요청을 보낼때 아래의 헤더를 함께 보낸다.요청 if-modified-since : ~~ UTC 수정이 안 됐을 때 304 Nod Modified 상태 코드를 보낸다.핵심은 이때 message body가 없다. F12에서 status 부분 색깔이 회색인 게 캐시에서 불러온 거다. (불확실) 단점 - 1초 미만 단위로 캐시 조정이 불가능날짜 기반의 로직 사용시간을 기준으로 삼기 때문에 데이터가 같아도 갱신되었다면 다시 다운로드 검증 헤더와 조건부 요청 2 - -ETag (Entity Tag)캐시용 데이터에 임의의 고유한 버전 이름을 달아둠ETag 헤더 교류만으로 검증If-None-Match false일 시 304 Not Modified 응답캐시 제어 로직을 서버에서 완전히 관리한다.클라이언트는 캐시 메커니즘을 전혀 몰라도 된다. 캐시 제어 헤더 - -Cache-Control : 캐시 제어 max-age : 캐시 유효시간 no-cache : 데이터는 캐시해도 되지만, 항상 origin 서버에 검증하고 사용 no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨메모리에서 사용하고 최대한 빨리 삭제 현재 Pragma와 Expires 없이 Cache-Control로 다 할 수 있다.Pragma : 캐시 제어 (하위 호환)Expires : 캐시 유효 기간 (하위 호환) 프록시 캐시 도입 (CDN) - - - origin 서버와 웹 브라우저 사이에 캐싱이 가능한 프록시 서버가 존재함 캐시 지시어 (directives) - -Cache-Control : public= 응답이 public 캐시에 저장되어도 됨Cache-Control : private (default)= 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함Cache-Control : s-maxage= 프록시 캐시에만 적용되는 max-age 이런 게 있다Age : 60 (HTTP 헤더)= origin 서버에서 응답 후 프록시 캐시 내에 머문 시간이런 게 있다 캐시 무효화 - - -캐시 헤더를 추가 안하면 캐시가 안되니깐 필요 없다고 생각할 수 있지만웹 브라우저가 GET 요청의 경우 임의로 cache를 해버릴 때도 있다. Cache-Control : no-cache, no-store, must-revalidate &lt; 한번에 넣기must-revalidate origin 서버에 접근할 수 없는 경우, 항상 오류가 발생 해야함504 Gatewaty Timeoutno-cacheorigin 서버에 접근할 수 없는 경우 프록시 서버에서 대신 처리할 수도 있음.200 등.★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★text/html vs application/json 의 차이query는 정확히 뭘 하는 건가 정말 질의 그자체?프록시서버란?트래킹? 트래픽?domain/path?querypackit = package + buckethttp 스펙 : https://tools.ietf.org/html/rfc7230" }, { "title": "HTTP - 6 - header", "url": "/posts/http-6-header/", "categories": "공부, HTTP", "tags": "HTTP, 자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "## 인프런 김영한님의 강의 내용 기록 ## -HTTP 헤더 1 (일반 헤더) - - - - 과거의 Entity라는 단어는 사라지고Representaion이 등장여기서 R이 바로 Restful의 R이다.HTTPmessage body - RFC7230 기준메시지 본문(message body)을 통해 표현(Representation) 데이터 전달message body = payload (실제 데이터부)표현은 요청이나 응답에서 전달할 실제 데이터표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공 데이터 유형(html, json), 데이터 길이, 압축 정보 등등 참고 : 표현 헤더는 표현 메타데이터와, 페이로드 메시지를 구분해야하지만 힘듬 표현 (Representation) - - “Resource를 html이란 표현으로 전달할 것인가 json이란 데이터 형태로 전달할 것인가 . . .”Content-Type : 표현 데이터의 형식= application/json 기본 문자 인코딩 방식이 UTF-8 {“data”:”hello”}Content-Encoding : 표현 데이터의 압축 방식= 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가= gzip, identity(압축안한 기본데이터) 등Content-Language : 표현 데이터의 자연 언어= ko, en 등Content-Length : 표현 데이터의 길이 (byte)= 표현이랑 딱히 상관은 없다. payload 헤더라고 말하는 게 더 어울린다.= Transfer-Encoding 을 사용하면 Content-Length를 사용하지 않는다.표현 헤더는 전송, 응답 둘다 사용 협상 (Content-negotiation) - - &gt; 클라이언트가 선호하는 표현 요청 Quality Values(q) 우선 순위 q = 0 ~ 1 구체적인 것이 우선한다. 구체적인 것을 기준으로 미디어 타입을 맞춘다.Accept : 클라이언트가 선호하는 미디어 타입 전달= /, text/, text/plain, text/pain;format=flowed= text/;q=0.3, text/html;q=0.7 . . . Accept-Charset : 클라이언트가 선호하는 문자 인코딩Accept-Encoding : 클라이언트가 선호하는 압축 인코딩Accept-Language : 클라이언트가 선호하는 자연 언어= ko-KR,ko;q=0.9,en-US;q=0.8 협상 헤더는 요청시에만 사용OS와 Local 위치, 브라우저에 의해 어느 정도? 정해지는 것 같다 전송 방식 - -단순 전송 : Content-Length= 기본 데이터 그대로 압축 전송 : Content-Encoding= 실제로 절반 이상 줄어듦분할 전송 : Transfer-Encoding : chunked= chuck마다 Length 정보가 있고 전체 데이터 길이를 예측할 수 없기에Content-Length를 헤더에 넣지 않는다.범위 전송 : Range, Content-Range= 원하는 범위의 데이터만 받을 수 있음 일반 정보 - -From : 유저 에이전트의 이메일 정보= 잘 사용되진 않음. 검색 엔진 같은 곳에서 주로 사용, 요청에서 사용Referer : 이전 웹 페이지 주소 : Referrer의 오타= A -&gt; B 로 이동하는 경우 B를 요청할 때 Referer : A를 포함해서 요청= 주로 유입경로 분석할 때 사용, 요청에서 사용User-Agent : 유저 에이전트 애플리케이션 정보= 보통 웹브라우저 정보로 알면 됨= 특정 브라우저의 문제를 인지할 수 있음= 통계 정보, 요청에서 사용Server : 요청을 처리하는 origin 서버의 소프트웨어 정보 HTTP 요청을 보내면 노드를 거쳐 진짜 마지막인 origin 서버에 도달= Apache, nginx 등의 정보 응답에서 사용Date : 메시지가 생성된 날짜= 응답에서 사용 특별한 정보 - - Host : 요청한 호스트 정보(Domain)= 요청에서 “필수”로 사용= 하나의 서버가 여러 도메인을 처리해야 할 때= 하나의 IP 주소에 여러 도메인이 적용되어 있을 때 domain을 기재한다는 건 현시대에서 자명한 이야기다Location : page redirection= 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면\tLocation 위치로 자동 이동= 201 Location 값은 요청에 의해 생성된 리소스 URI= 3xx Location 값은 자동으로 리디렉션하기 위한 대상 리소스를 가리킴Allow : 허용 가능한 HTTP 메서드= 405 에서 응답에 포함해야함= Allow : GET, HEAD, PUT 아 이런 게 있구나Retry-After : user agent가 다음 요청을 하기까지 기다려야 하는 시간= 503 : 서비스가 언제까지 불능인지 알려줄 수 있음 아 이런 게 있구나 인증 - - Authorization : 클라이언트 인증 정보를 서버에 전달 ? 인증과 관련된 값을 넣어주면 되겠죠?WWW-Authenticate : 리소스 접근시 필요한 인증 방법 정의= 401 응답과 함께 사용 " }, { "title": "HTTP - 5 - cookie", "url": "/posts/http-5-cookie/", "categories": "공부, HTTP", "tags": "HTTP, 자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "## 인프런 김영한님의 강의 내용 기록 ## 쿠키 - - - - Set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답)Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고,\tHTTP 요청시 서버로 전달HTTP는 stateless를 지향, 그래서 Cookie와 Session이 필요하다.쿠키가 없다면 매번 클라이언트 정보가 요청에 담기기에그렇게 개발하는 것도 힘들고 보안에도 취약하다.Cookie는 모든 요청 정보에 쿠키 정보를 자동으로 포함한다(제약 가능)그것도 data를 은닉한 채로.set-cookie : sessionId=””; expires=””; path=””; domain=””; secure=””; 사용처 -사용자 로그인 세션 관리광고 정보 트래킹 쿠키 정보는 항상 서버에 전송됨 -네트워크 트래픽 추가 유발최소한의 정보만 사용(세션 id, 인증 토큰)서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 참고(local-session-Storage) 보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드정보 등) 쿠키의 생명주기 -expires = ~~ GMTmax-age = ~~sec세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시 까지만 유지영속 쿠키 : 만료 날짜를 입력하면 해당 날짜까지 유지 쿠키의 도메인 -생각해보면 아무 사이트에 들어갈 때마다 쿠키를 전송하면 큰일 난다. 명시 : 명시한 문서 기준 도메인 + 서브 도메인 포함생략 : 현재 문서 기준 도메인만 적용ex ) domain = example.org 지정시 dev.example.org 도 쿠키 접근 생략하면 dev.~ 에서는 쿠키 미접근 쿠키의 경로(path) - ex ) “path=/home”이 경로를 포함한 하위 경로로 페이지만 쿠키 접근일반적으로 “path=/” 루트로 지정 쿠키의 보안 -Secure= https인 경우에만 전송HttpOnly= XSS 공격 방지= js에서 접근 불가= HTTP 전송에만 사용SameSite= XSRF 공격 방지= 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송 " }, { "title": "HTTP - 4 - status code", "url": "/posts/http-4-status-code/", "categories": "공부, HTTP", "tags": "HTTP, 자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "## 인프런 김영한님의 강의 내용 기록 ## HTTP 상태코드 - - - -클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능 1xx (Informational) : 요청이 수신되어 처리중= 거의 사용되지 않음2xx (Successful) : 요청 정상 처리3xx (Redirection) : 요청을 완료하려면 추가 행동이 필요4xx (Client Error) : 클라이언트 오류, 잘못된 문법 등으로\t\t서버가 요청을 수행할 수 없음5xx (Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함 2xx -200 OK= 주로 GET201 Created= 주로 POST and Location header가 있을 수 있음202 Accepted= 요청이 접수되었으나 처리가 완료되지 않았음= 배치 처리 같은 곳에서 사용. 잘 사용하진 않음204 No Content= 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음.= 예를 들어 save 버튼 같은 것 거의 200,201을 자주 사용함 3xx - &gt; 요청을 완료하기 위해 유저 에이전트의 추가 조치 필요유저 에이전트란 클라이언트 프로그램. 주로 웹 브라우저3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 이동300 Multiple Choices= 거의 안 씀301 Moved Permanently= Location 영구적 이동, 리소스를 새로 요청= 요청 메서드가 GET으로 변하고, 본문이 제거될 수도 있음302 Found= 요청 메서드가 GET으로 변할 수 있고, 본문이 제거될 수 있음= 실무에서는 302를 아직까지 많이 씀303 See Other= 요청 메소드가 GET으로 변경= 302보단 명확함304 Not Modified307 Temporary Redirect= 요청 메서드와 본문이 유지됨308 Permanent Redirect= 요청 메서드와 본문이 유지됨= 사실 URI가 바뀌면 내부적으로 전달해야하는 데이터도 \t바뀌는 경우가 많아서 301을 자주 사용함 리다이렉션 이해 - 1.영구 리다이렉션 (301, 308)= 특정 리소스의 URI가 영구적으로 이동= 검색 엔진 등에서도 변경 인지2.일시 리다이렉션 (302, 303, 307)= 일시적인 변경= 주문 완료 후 주문 내역 화면으로 이동 PRG패턴 PRG - POST로 주문 후에 웹 브라우저를 새로고침하면? 새로고침은 재요청이므로 중복 주문이 들어갈 수 있음. 원칙적으로는 서버에서 막는 로직이 있어야함. POST로 주문 후에 주문 결과 화면을 GET 메서드로 리다이렉트 새로고침해도 결과 화면을 GET으로 조회 핵심은 주문 요청에대한 응답을 302 Found로 내보내는 것 주문 결과 Location과 함께 보냄 3.중복 주문 대신에 결과 화면만 GET으로 다시 요청특수 리다이렉션 (304)= 결과 대신 캐시를 사용= 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬PC에 저장된 캐시를 재사용한다.\t(캐시로 리다이렉트 한다.)= 304 응답은 응답에 메시지 바디를 포함하면 안된다.\t(로컬 캐시를 사용해야 하므로)= 조건무 GET, HEAD 요청시 사용 4xx - &gt; 오류의 원인이 클라이언트에 있음요청 자체를 잘못함. 동일한 요청을 반복해도 실패함.400 Bad Request= 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음= 서버 개발자가 철저한 validation을 통해 사전에 막아야함401 Unauthorized= 클라이언트가 해당 리소스에 대한 인증이 필요함 참고인증 : 본인이 누구인지 확인인가 : 권한부여 (인증이 있어야 인가가 있음)오류메시지가 Unautorized 이지만 인증되지 않음403 Forbidden= 서버가 요청을 이해했지만 승인을 거부함= 인증 자격 증명은 있지만, 접근 권환이 불충분한 경우= 예를 들어 일반유저가 admin 등급의 resource에 접근404 Not Found= 요청 리소스를 찾을 수 없음= 또는 인가되지 않은 클라이언트가 리소스에 접근할 때나 숨길 떄 5xx - &gt; 오류의 원인이 서버에 있음서버에 문제가 있기 때문에 재시도하면 성공할 수도 있음.500 Internal Server Error= 서버 내부 문제로 오류 발생, 애매하면 500 오류503 Service Unavailable= 서비스 이용 불가= 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청 거절= Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음= 대부분 예측 불가능하게 나오므로 503을 보는 경우는 거의 없다 웬만하면 5xx 에러는 만들면 안됨. 정말 서버에 문제가 생겼을때 터져야함" }, { "title": "HTTP - 3 - method", "url": "/posts/http-3-method/", "categories": "공부, HTTP", "tags": "HTTP, 자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "## 인프런 김영한님의 강의 내용 기록 ##HTTP 메서드최근 Resource -&gt; Representation 으로 스펙상 용어가 변경됨API URI 설계 리소스 식별, URI 계층 구조 활용 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장 URI는 리소스만 식별, 리소스와 행위는 엄격히 분리행위를 어떻게 구분하는가? HTTP 메서드가 대신 해줌 완벽히 분리하긴 어렵다. 어쩔 수 없는 부분은 컨트롤 URI라는 것으로 설계해야한다.HTTP 메서드 종류 GET : 리소스 조회 단순히 query 로 보냄 서버 쪽에선 GET으로 오면 캐싱을 하겠다 POST : 요청 데이터 처리, 주로 등록에 사용 메시지 바디를 통해 서버로 요청 데이터 전달 사실 POST만으로 다 할 수 있긴 하다. PUT : 리소스를 완전히 대체, 해당 리소스가 없으면 생성 포스트와 달리 클라이언트가 정확한 주소를 알고 있다 PATCH : 리소스 부분 변경 PUT과 달리 부분 변경됨 DELETE : 리소스 삭제 기타 메서드특히 CONNECT, TRACE 아예 안쓰는 수준 HEAD : GET과 동일하지만 메시지 부분을 제외 OPTIONS : 대상 리소스에 대한 통신 기능 옵션(메서드)을 설명 CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정 TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 HTTP 메서드의 속성 안전 (Safe Methods) 호출해도 리소스를 변경하지 않는다. 멱등 (Idempotent Methods) f(f(x)) = f(x) 호출 횟수와 상관없이 결과가 같다. 자동 복구 메커니즘 서버가 TImeout 등으로 정상 응답을 못주었을 때 클라이언트가 같은 요청을 다시 해도 되는가? 판단 근거 캐시가능 (Cacheable Methods) 실제로는 GET, HEAD 정도만 캐시로 사용 POST, PATCH는 본문 내용까지 캐시 키로 고려해야 해서 쉽지 않다. HTTP 메서드 활용클라이언트에서 서버로 데이터 전송1. query parameters를 통한 데이터 전송 = GET = 주로 정렬 필터 (검색어) 2. message body를 통한 데이터 전송 = POST, PUT, PATCH = 회원 가입, 상품 주문, 리소스 등록, 리소스 변경 4가지 상황 정적 데이터 조회 = 이미지, 정적 텍스트 문서 일반적으로 query-P 없이 resource path로 단순 조회 가능 동적 데이터 조회 = 주로 검색, 게시판 목록에서 정렬 필터 (검색어) 조회는 GET 사용 및 query-P를 사용 3. HTML Form을 통한 데이터 전송 = 회원 가입, 상품 주문, 데이터 변경 - POST - 웹 브라우저가 summit 버튼을 누르면 form의 data를 읽어서 Content-Type이 application/x-www-form-urlencoded인 key-value 형식의 HTTP message를 생성해준다. 이때 body message 내용은 query-P와 매우 흡사하다. - GET -query-P에 key-value를 담는다. 단 조회에만 사용한다. Resource 변경이 발생하는 곳에 사용하면 안됨- multipart/form-data - 각 data에 대한 boundary가 나눠져 전송됨. 주로 binary data(or file) 전송에 사용됨 HTTP API를 통한 데이터 전송 = 회원 가입, 상품 주문, 데이터 변경 GET, POST, PUT, PATCH 모두 활용 content-Type : application/json을 주로 사용 (사실상 표준) TEXT, XML, JSON 등 예전엔 XML을 주로 썼지만 이젠 JSON이 대세 서버 to 서버 - 백엔드 시스템 통신 앱 클라이언트 - 아이폰, 안드로이드 웹 클라이언트(Ajax) - HTML에서 Form 전송 대신 자바 스크립트를 이용한 통신에 사용 예) React, Vue.js 같은 웹 클라이언트와 API 통신 HTTP API 설계 예시 - - - - -회원 관리 시스템 - -회원 목록 /members -&gt; GET회원 등록 /members -&gt; POST회원 조회 /members/{id} -&gt; GET회원 수정 /members/{id} -&gt; PATCH, PUT, POST (추천순)회원 삭제 /members/{id} -&gt; DELETE 파일 관리 시스템 - -파일 목록 /files -&gt; GET파일 조회 /files/{filename} -&gt; GET파일 등록 /files/{filename} -&gt; PUT파일 삭제 /files/{filename} -&gt; DELETE파일 대량 등록 /files -&gt; POST POST - 신규 자원 등록 특징 = 클라이언트는 등록될 리소스의 URI를 모른다= 서버가 새로 등록된 리소스 URI를 생성해준다.= 컬렉션 : 서버가 관리하는 리소스 디렉토리 /membersPUT - 신규 자원 등록 특징= 클라이언트가 리소스 URI를 알고 있어야 한다.= 클라이언트가 직접 리소스의 URI를 지정한다= 스토어 : 클라이언트가 관리하는 리소스 디렉토리 /files 사실 대부분 POST 사용함HTML Form 사용회원 목록 /members -&gt; GET회원 등록 폼 /members/new -&gt; GET회원 등록 /members/new, /members -&gt; POST회원 조회 /members/{id} -&gt; GET회원 수정 폼 /members/{id}/edit -&gt; GET회원 수정 /members/{id}/edit, /members/{id} -&gt; POST회원 삭제 /members/{id}/delete -&gt; POSTPOST의 new, edit, delete 같은 게 컨트롤 URI (동사로 작성)문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행GET, POST만 지원하므로 제약이 있음참고 : https://restfulapi.net/resource-naming" }, { "title": "HTTP - 2 - basic", "url": "/posts/http-2.basic/", "categories": "공부, HTTP", "tags": "HTTP, 자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "## 인프런 김영한님의 강의 내용 기록 ##HTTPHyperText Transfer Protocol모든 것이 HTTP HTTP 메시지에 모든 것을 전송한다 HTML, TEXT, MEDIA, JSON, XML (API) 거의 모든 형태의 데이터 전송 가능 서버 간 데이터 송수신에도 대부분 HTTP지금은 HTTP 시대 !HTTP/0.9 (1991) : GET 메서드만 지원, HTTP 헤더 x HTTP/1.0 (1996) : 메서드, 헤더 추가 HTTP/1.1 (1997) : 가장 많이 사용. 지금 가장 중요한 버전 현재 스펙은 RFC7230 (2014)~ HTTP/2 (2015) : 성능 개선 HTTP/3 (진행중) : TCP 대신에 UDP 사용, 성능 개선 기반 프로토콜 TCP : 1.1, 2 || UDP : 3 3way handshake와 과한 헤더 정보 때문에 UDP를 선호하는 추세 클라이언트와 서버 구조로 이루어짐 클라이언트가 HTTP 메시지를 통해서 서버로 요청을 보냄 클라이언트는 서버의 응답이 올 때까지 무작정 기다림HTTP 시대의 특징 클라이언트와 서버 구조 클라이언트와 서버 개념이 분리되어 독립적인 개발이 가능하다는 점이다. 클라이언트는 UI만 구성하면 되고 서버에는 데이터처리, 비즈니스 로직을 몰아넣는다. 무상태 프로토콜 지향 (Stateless)서버가 클라이언트의 상태를 보존하지 않는다. 클라이언트 서버 아키텍쳐에서 수평 확장(Scale-out)에 유리 클라이언트는 요청 파라미터에 서버가 필요한 데이터를 모두 넘기면 됨 하지만 예로, 로그인 기능이 있다면 완전한 Stateless에는 한계가 있다. 일반적으로 브라우저 쿠키와 서버 세션등을 사용해 상태를 유지한다. 물론 가능한 stateless하게 비연결성 연결을 유지한다면 서버 자원이 지속적으로 소모된다. TCP/IP 구조를 예로, 응답 후 바로 연결을 끊는다면 이를 극복한다. 이또한 3way-H 시간과 무수한 연결-종료 과정의 한계에 부딪힌다. 지금은 HTTP 지속 연결(Persistent Connections)로 문제를 해결하고상위 버전에선 더 많은 최적화가 이루어지고 있다.HTTP 메시지 메시지 구조 [ start-line | header | empty line | message body ] start-line-request-request-line: method SP(space) request-target(path) SP HTTP-version CRLF(enter)method : GET 등 GET : 리소스 조회, POST : 요청 내역 처리request-target(path) absoulte-path와 query parameter ex) /search?q=hello&amp;hI=ko-response-status-line: HTTP-version SP status-code SP reason-phrase CRLFstatus-code : 200, 400, 500 . . . 요청 성공, 실패를 나타냄reason-phrase : OK . . 사람이 알아볼 수 있는 문자열(status-code에 대한) header - &gt; HTTP 전송에 필요한 모든 부가정보(meta data)를 포함header-field field-name “:” OWS(띄어쓰기 허용) field-value OWS message body - &gt; 실제 전송할 데이터HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송가능" }, { "title": "HTTP - 1 - network", "url": "/posts/http-1-network/", "categories": "공부, HTTP", "tags": "HTTP, 자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "## 인프런 김영한님의 강의 내용 기록 ##IPInternet Protocol지정한 IP주소에 데이터 전달패킷이라는 통신 단위로 데이터 전달패킷에 각 endpoint 정보와 데이터를 함께 전달함IP의 방식의 단점비연결성= 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송비신뢰성= 중간에 패킷이 사라진다면, 패킷이 순서대로 안오면?\t중간 노드에 문제가 생긴다면프로그램 구분= 같은 IP를 사용하는 서버에서 통신하는 app이 둘 이상이면?인터넷 프로토콜 스택의 4계층애플리케이션 계층 - HTTP, FTP (Socket Library)전송 계층 - TCP, UDP인터넷 계층 - IP네트워크 인터페이스 계층 (Ethernet frame)TCPTransmission Control Protocol전송 제어, 순서, 검증 정보와 endpoint의 PORT 정보가 추가됨연결 지향 - TCP 3 way handshake (가상 연결) synchronize와 acknowledge(접속 요청과 수락)를 거쳐 데이터 통신 완전한 1대1 직결은 아님. 논리적으로 연결되었다고 인지만 하자.데이터 전달 보증 데이터 전달이 완료됨을 송신자에게 알려줌순서 보장 IP 단독 방식의 단점을 보완했다신뢰할 수 있는 프로토콜 현재 대부분 TCP 사용 TCP를 IP로 둘러싼 형태를 줄여서 TCP/IP 패킷이라 부름UDPUser Datagram ProtocolIP와 흡사한 방식에 PORT와 체크섬 정도만 추가됨 TCP가 지배하는 상황에서 최적화가 너무 하고 싶다면 UDP를 이용하되 어플리케이션 계층에서 추가 작업을 해준다 HTTP3에선 UDP기반의 통신을 사용한다PortIP는 서버를 찾고 Port는 서버 안의 app을 찾는다고 보면 된다 좀더 정확히, 같은 IP 내에서 프로세스를 구분 클라이언트는 자신의 IP, Port 까지 패킷에 넣어 보내기에 서버도 응답하기 편해진다. 0 ~ 65535 할당 가능 0 ~ 1023 잘 알려진 포트, 사용하지 않는 것이 좋음 FTP - 20, 21 TELNET - 23 HTTP - 80 HTTPS - 443DNSDomain Name System전화번호부 같은 서버를 제공 도메인 명을 등록하고 IP 주소로 바꿀 수 있음URIUniform Resource IdentifierU : 리소스 식별하는 통일된 방식 R : 자원, URI로 식별할 수 있는 모든 것(제한 없음) I : 다른 항목과 구분하는데 필요한 정보 L : 리소스가 있는 위치를 지정 N : 리소스에 이름을 부여URI는 로케이터(L), 이름(N) 또는 둘 다 추가로 분류될 수 있다URI ⊃ { URL , URN }?URN은 이름으로만 지정되긴 하지만 매핑이 어렵다 URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음 URL 위주로 사용한다고 보면 된다URL 분석scheme :// [userinfo@] host [:port] [/path] [?query] [#fragment]https :// www.google.com :443 /search ?q=hello^hI=koscheme : 주로 프로토콜 사용 (http, https, ftp . . . ) 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙 http는 80, https는 443 포트를 주로 사용, 포트는 생략 가능 userinfo : 거의 안 씀. URL에 사용자 정보를 포함 host : 도메인 주소 또는 아이피 주소 port : 접속 포트 path : resource 경로, 계층적 구조 query : json 형태, ?로 시작, &amp;로 추가 ( ≒ query [ parameter, string ] ) fragment : 거의 안 씀. 서버 전송x, html 내부 북마크 등에 사용" }, { "title": "쉽게 배우는 JSP 웹 프로그래밍 - 9 - Others", "url": "/posts/jsp-9-others/", "categories": "공부, JSP", "tags": "자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "폼태그 action 에 적절한 경로를 지정하면 클라이언트에게보이지 않는 과정을 실행할 수 있다request, response는 변환된 servlet의 _jspService 메소드 실행 중에유지될 것 같은데 -&gt; service 종료는 pageContext 유지 시간임일반적으로 새로운 페이지를 반환한다면 종료됐다고 말할 수 있다번역된 경로\\workspace\\jsp\\.metadata \\.plugins\\org.eclipse.wst.server.core\\tmp0 \\work\\Catalina\\localhost \\07_scope\\org\\apache\\jsp응답 HTTP 헤더 메소드에서add set Header는 무슨 차이?MIME?스크립틀릿 태그에서 request 내장 객체를 이용하여폼 페이지에서 전달된 값을 처리하는 ..request와 response가 결국 웹 개발의 핵심인 것 같다Enumeration이 열거 클래스랑 어떤 게 다른건지restful은 http 메소드와 관련된 uri 설계에 대한 이야기?json은 { String = String } 형태다디렉토리 태그의 include는 서블릿 결합으로 변수 공유액션 태그의 include는 독립적인 서블릿 생성 하지만 param 태그로 공유 가능시간 단위를 표현할땐 (606024) 식으로 작성ServletRequest와 HttpServletRequest의 차이.do 확장자는 행위만 수행하는가?로그인은 쿠키로 관리했고세션엔 비즈니스를 관리" }, { "title": "쉽게 배우는 JSP 웹 프로그래밍 - 8 - MVC", "url": "/posts/jsp-8-MVC/", "categories": "공부, JSP", "tags": "자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": " MVC - - - -웹 애플리케이션을 비즈니스 로직= app data 즉 고객, 제품, 제품, 주문 정보의 조작에 사용되는 용어 프레젠테이션 로직= 화면 데이터 (요청 처리 데이터)= 비즈니스 로직과 프레젠테이션 파트를 함께 묶는 것로 분리하는 디자인 패턴 Model = 애플리케이션의 데이터와 비즈니스 로직을 담는 객체View= 사용자에게 모델의 정보를 보여주는 역할= 비즈니스 로직을 포함하지 않으며, 하나의 모델을 다양한 뷰에서 사용함Controller= 모델과 뷰 사이에 어떤 동작이 있을 때 조정하는 역할= 웹으로부터 받은 요청에 가장 적합한 모델을 생성하는 것을 처리하고= 사용자에게 응답하는 적절한 뷰를 선택하여 해당 모델을 전달한다. 유지 보수가 용이하고 확장 및 테스트를 쉽게 할 수 있다.navigation control이 중앙 집중화되어 있다요청 처리가 이루어지는 위치에 따라 MVC 모델은 두 가지가 있다.Web app 에선 JSP(view), javabeans(model), servlet(controller) MVC 모델 1 - - 기존의 JSP로만 구현한 Web appJSP 페이지에 비즈니스 로직과 프레젠테이션 코드를 섞음 구조가 단순해 생산성이 좋지만 분업과 유지보수가 어려움 MVC 모델 2 - -클라이언트의 요청 처리, 응답 처리, 비즈니스 로직 처리부를 모듈화 1. 요청에 대한 로직을 처리할 자바빈즈나 자바 클래스인 모델 2. 요청 결과를 출력하는 JSP 페이지인 뷰 3. 모든 흐름을 제어하는 서블릿인 컨트롤러 모델 2에서는 서블릿이 중요한 역할을 하며웹 브라우저가 요청한 모든 작업을 하나의 서블릿이 처리한다.서블릿은 웹 브라우저의 요청을 알맞게 처리한 후 그 결과를 보여줄 JSP 페이지로 포워딩하고 이를 통해 요청 흐름을 받은 JSp 페이지는 결과 화면을 웹 브라우저에 전송 서블릿이 비즈니스 로직 부분을 처리한다. MVC 패턴 구현 방법 - -web.xml 파일에 서블릿 구성하기web.xml에 서블릿 클래스와 웹 브라우저의 요청 URL 패턴을 등록해야 함.1. 요소로 서블릿 클래스를 등록2. 요소로 요청 URL 패턴 설정 " }, { "title": "쉽게 배우는 JSP 웹 프로그래밍 - 7 - JSTL", "url": "/posts/jsp-7-JSTL/", "categories": "공부, JSP", "tags": "자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": " JSTL - - - -&gt; 사용자 정의 태그의 표준시작 태그와 종료 태그의 쌍으로 이루어져야 함. JSTL이 제공하는 태그의 종류와 사용법 - - 기능에 따라 분류할 수 있고 다양한 하위 태그가 존재한다. Core - &gt; 변수와 관련된 작업, 제어문, direction&lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core”%&gt;&lt;c: [ out, set, remove, catch, if, choose, when, otherwise\timport, forEach, forTokens, param, redirect, url ]&gt;choose + when + otherwise = 조건 분기문ex) Formatting - &gt; 문자열, 컬렉션을 처리, 다국어 관련 Sql - &gt; DBMS 연동 &lt;sql: [setDataSource, query, update, dateParam, param, transaction]/&gt; Functions - &gt; 문자열을 처리하는 함수 제공= String 클래스에 존재하는 다양한 메소드들이 있음" }, { "title": "쉽게 배우는 JSP 웹 프로그래밍 - 6 - 세션 - 쿠키", "url": "/posts/jsp-6-session-cookie/", "categories": "공부, JSP", "tags": "자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "세션 stateful세션은 웹 서버에 존재하는 객체다. 서버에서만 접근이 가능하므로 보안 유지에 유리함. 브라우저마다 하나씩 존재하므로 사용자를 구분하는 단위가 됨get-set-Attribute = 세션 속성 이름이 name인 속성 값을 Object 형으로 반환한다 해당되는 속성 이름이 없을 때는 null을 반환한다 반환 값이 Object이므로 반드시 형 변환해야 한다. getAttributeNames = 세션 속성 이름을 Enumeration 타입으로 반환 getCreationTime = 세션이 생성된 시간 반환 long타입 getId = 세션에 할당된 고유 아이디를 String으로 getLastAccessedTime = 클라이언트가 마지막으로 request를 보낸 시간 get-set-MaxInactiveInterval = 해당 세션을 유지하기위해 세션 유지 시간. default = 1800 isNew = 처음 생성된 세션인지 removeAttribute 단일 삭제 Invalidate 다중 삭제 = 현재 세션에 저장된 모든 세션 속성을 제거한다.Enumeration enum = session.getAttributeNames() while (enum.hasMoreElements()){ \tString name = enum.nextElement().toString(); } Enumeraion은 위와 같이 가져오면 된다.세션 유효 시간이 없는 상태에서 세션을 삭제하지 않으면메모리에 계속 잔류한다.쿠키세션과 마찬가지로 클라이언트와 웹 서버 간의 상태를 지속적으로 유지하는 방법하지만 쿠키는 세션과 달리 상태 정보를 웹 서버가 아닌 클라이언트에 저장한다웹 브라우저가 접속했던 웹 사이트에 관한 정보와 개인정보가 기록되기 때문에 보안상 문제가 있다. 쿠키의 동작 과정 - 쿠키는 주로 웹 서버 측에서 생성한다 생성된 쿠키는 응답 데이터에 함께 저장되어 웹 브라우저에 전송 웹 브라우저는 응답 데이터에 포함된 쿠키를 쿠키 저장소에 보관한다. 쿠키는 종류에 따라 메모리나 파일로 저장된다. 웹 브라우저는 한 번 저장된 쿠키를 요청이 있을 때마다 웹 서버에 전송한다. get-set-Comment get-set-Domain get-set-MaxAge getName get-set-Path get-set-Secure get-set-Value get-set-Version쿠키는 여러 개를 주고 받아도 된다. 비단 아이디 뿐만 아니라.쿠키를 삭제하는 기능은 별도로 제공하지 않고 유효 기간을 만료시켜 삭제시키면 된다. s" }, { "title": "쉽게 배우는 JSP 웹 프로그래밍 - 5 - 예외 처리 - 필터", "url": "/posts/jsp-5-except-filter/", "categories": "공부, JSP", "tags": "자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": " 예외 처리 - - - -“프로그램이 처리되는 동안 특정한 문제가 발생했을 때 처리를 중단하고 다른 처리를 하는 것으로 오류 처리라고도 한다.” page 디렉티브 태그를 이용한 예외 처리= errorPage, isErrorPage web.xml 파일을 이용한 예외 처리= 또는 요소를 이용 try/catch/finally를 이용한 예외 처리 예외 처리 방법의 우선순위 - - 1. JSP try-catch 2. page 디렉티브 태그의 errorPage 출력 3. JSP 예외 유형이 web.xml과 동일할 경우 설정한 오류 페이지 출력 4. JSP 오류 코드가 web.xml과 동일할 경우 설정한 오류 페이지 출력 5. 이 항목에 해당되지 않는 경우 웹서버 제공 기본 오류 페이지 출력 web.xml 파일을 이용한 예외 처리 - - 1. error-code : 오류 코드를 설정 2. exception-type : 자바 예외 유형이 정규화된 클래스 이름을 설정 3. location : 오류 페이지의 URL 설정 주요 오류 코드의 종류 -200 : 요청 정상 처리307 : 임시로 페이지 리다이렉트400 : 클라이언트의 요청이 잘못된 구문으로 구성401 : 접근이 허용되지 않음404 : 지정된 URL을 처리하기 위한 자원이 존재하지 않음(페이지x)405 : 요청된 메소드가 허용되지 않음500 : 서버 내부의 에러 (JSP에서 예외 발생)503 : 서버가 일시적으로 서비스 불능 (서버 과부하, 보수중) try/catch - -RequestDispatcher + forward 이용 서블릿에서의 jsp 호출 -forward()= JSP 페이지를 호출하는 순간 서블릿 프로그램이 실행을 멈추며 JSP 페이지로 넘어가 그곳에서 실행하고 프로그램이 끝남 forward 이후의 문장을 무시하는가? include()= JSP 페이지가 실행된 후 나머지 서블릿 프로그램이 실행됨 include 이후의 문장을 모두 끝마치는가? ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★ 필터 - - - - 클라이언트와 서버 사이에서 request, response 객체를 먼저 받아 사전/사후 작업 등 공통적으로 필요한 부분을 처리 javax.servlet.Filter 의 구현 클래스를 생성해야함 Request filter -인증 (사용자 인증)요청 정보를 로그 파일로 작성암호화 인코딩 작업-Response filter -응답 결과 데이터 압축응답 결과에 내용 추가/수정총 서비스 시간 측정 Filter 인터페이스 메소드의 종류 -init : 필터 인스턴스의 초기화 메소드= JSP 컨테이너가 필터를 초기화할 때 호출doFilter : 필터 기능을 작성하는 메소드destroy : 필터 인스턴스의 종료 전에 호출되는 메소드 init - -init 의 매개변수 중 FilterConfig 타입이 존재한다. F.C = FilterConfigF.C 객체는 JSP 컨테이너가 초기화 중필터에 정보를 전달하는 데 사용하는 필터 구성 객체 F.C 인터페이스의 메소드 - getFilterName : web.xml 파일에 설정된 필터 이름getInitParameter : web.xml 파일에 설정된 매개변수 getInitParameterNames : web.xml 파일에 설정된 매개변수 집합getServletContext : ServletContext 객체 doFilter - &gt; JSP 컨테이너가 필터를 리소스에 적용할 때마다 호출doFilter의 매개변수 중 FilterChain 타입이 존재한다.FilterChain은 다음 필터를 호출하는 데 사용됨 마지막 필터라면 체인의 끝에서 리소스를 호출FilterChain은 동기화를 위해서도 존재하지만 필터의 수행 과정을 연속적으로 하는 방법으로도 사용된다.FilterChain은 doFilter 메소드 내부에서 다시 filterChain.doFilter(request, response)와 같이 작성 ServletRequest 객체는 체인을 따라 전달하는 요청response는 위와 반대 web.xml 파일의 필터 구성 - - - 필터를 사용하려면 어떤 필터가 어떤 리소스에적용되는지 JSP 컨테이너에 알려주어야 한다.web.xml 파일에 필터를 설정할 때 와 요소를 사용하며여러 개의 필터가 설정되어 있으면 선언된 순서대로 실행된다. 요소에 설정된 매개변수와 값에 접근하려면getServletConfig().getInitParameter(\"매개변수\"); 요소는 특정 리소스에 대해어떤 필터를 사용할지 설정한다. 요소에는 리소스가 기입된다. (ex. filter.jsp)- 요청 URL 패턴의 유형 -*.do = .do로 끝나는 모든 URL과 일치하는 파일 확장 패턴/* = 모든 URL과 일치하는 경로 패턴/filter.jsp = 리소스와 일치하는 특정 패턴&gt; 필터를 이용해 로그를 기록할 수 있음" }, { "title": "쉽게 배우는 JSP 웹 프로그래밍 - 4 - 유효성 검사 - 시큐리티", "url": "/posts/jsp-4-valid-secure/", "categories": "공부, JSP", "tags": "자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": " 유효성 검사 (validation) - - - - “사용자가 폼 페이지에서 입력한 데이터 값이 서버로 전송되기 전에 특정 규칙에 맞게 입력되었는지 검증하는 것을 말한다.” “유효성 검사를 위한 핸들러 함수”폼 페이지에서 이벤트가 발생했을 때의 유효성 감사를 위해 매핑하는 메소드. 자바스크립트를 이용하여 코드 작성 onclick 등 이벤트로 다루고 alert 처리하면 됨웹 브라우저에서 유효성 검사를 처리하므로 서버에 영향이 없음 데이터 형식 유효성 검사 - - &gt; 정규 표현식을 이용함 Flag의 종류= i : 대소문자 구별하지 않고 검출= g : 문자열 내 모든 패턴 검출= m : 줄 바꿈 행 검출test : true or falseexec : 정규 표현식에 부합된 문자열 추출 정규 표현식은 필요할 때 퍼오자자주 사용하는 패턴 - ‘쉽게배우는 JSP 웹 프로그래밍 277p’★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★ 시큐리티 - - - - &gt; 허가된 사용자만이 접근할 수 있도록 제한사용자가 웹 페이지에 접근할 때JSP 컨테이너는 요청된 페이지에 보안 제약이 있는지 확인하고 사용자에게 인증(authentication)을 요청한다.이러한 인증은 일반적으로 사용자의 이름과 암호를 확인하여 수행.JSP 컨테이너는 인증 여부를 결정하고 승인하면 이를 권한부여(authorization)이라고 한다. 선언적 시큐리티= web.xml 파일에 보안 구성을 작성하여 사용자가 인증을 수행프로그래밍적 시큐리티= request 내장 객체의 메소드를 통해 권한 부여를 처리톰캣 서버에 인증 정보가 저장되는 장소는 /(tomcat root)/conf/tomcat-users.xml또는 웹 - 톰캣 연동을 위해 생성한 Server 프로젝트 내의 tomcat-users.xml 파일에 사용자와 역할이 구성되어 있다.파일 내의 주석을 해제해야 기존에 설정된 역할과 (role - user)사용자를 사용하거나 새로운 역할과 사용자를 추가할 수 있다. 선언적 시큐리티(declarative security) - - web.xml에 tomcat-users.xml과 동일한 role을 선언 1.사용자 설정2.역할 설정 참고 : 쉽게 배우는 JSP 웹 프로그래밍 332p시큐리티 제약 사항 (security-constratint)= 사용자의 요청 URL에 대한 접근 권한을 정의1.웹 자원에 대한 접근을 설정 1-1 웹 자원의 이름을 설정. 생략 가능 1-2 접근 제한을 요청할 URL 목록을 설정. 생략 가능 1-3 http 메소드를 설정 (GET | POST)2.웹 자원에 접근할 수 있는 인증된 사용자를 설정 2-1 description 권한 부여 제약 사항에 대한 설명을 기술 2-2 role-name3.데이터 전송 시 데이터 보호를 설정 3-1 NONE, INTEGRAL, CONFIDENTIAL 참고 : 쉽게 배우는 JSP 웹 프로그래밍 333p시큐리티 인증= 인증 처리를 위한 페이지 호출하는 데 사용 웹 자원에 대한 인증 처리 방식을 설정 1-1 BASIC, DIGEST, FORM, CLIENT-CERT 1-2 form태그에 j_security 같은걸 작성해야함 이런걸 적고 있을 리가 없다 웹 자원에 접근할 수 있는 인증된 사용자를 설정 2-1 영역 이름을 설정 데이터 전송 시 데이터 보호를 설정 3-1 요청 URL과 에러 페이지 호출을 설정 프로그래밍적 시큐리티 - -request 내장 객체를 이용함 getRemoteuser : 사용자 인증 상태getAuthType : 서블릿을 보호하는 데 사용되는 인증 방식의 이름isUserInRole : 설정된 역할이 있는지 확인getProtocol : 요청 프로토콜isSecure : https 요청으로 request가 들어왔는지 확인getUserPrinciple : 인증한 사용자의 이름을 포함하여 객체 반환" }, { "title": "쉽게 배우는 JSP 웹 프로그래밍 - 3 - 폼 태그", "url": "/posts/jsp-3-form-tag/", "categories": "공부, JSP", "tags": "자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": " form tag - - - - &gt; 사용자가 다양한 정보를 입력하고 서로 전달 action : 폼 데이터를 받아 처리하는 웹 페이지의 URL 설정method : 폼 데이터가 전송되는 HTTP 방식 GET, POST는 보안 유무로 따지면 됨name : 폼을 식별하기 위한 이름target : 처리 결과의 응답을 실행할 프레임enctype : 폼을 전송하는 콘텐츠 MIME 유형을 설정accept-charset : 폼 전송에 사용할 문자 인코딩 설정 input tag - -type : text, radio, checkbox, password, hidden, file, \tbutton, reset, submitname : 입력 양식을 식별하는 이름value : 입력 양식의 초깃값readonly, maxlength, size, disabled, checked HTML5 추가required, autofocus, placeholder, pattern(정규표현식) select tag - -여러 개의 항목이 나타나는 목록 상자에서 항목을 선택하는 태그name, size, multiple 내부 목록은 option tag로 추가value, selected, disabled 동일한 name을 가진다optgroup 태그와 label 속성으로 그룹화도 가능 textarea tag - -name, cols, rows, wrap[off, soft, hard] wrap = hard 캐리지 리턴 문자를 전달“캐리지 리턴(carriage return) 또는 간단히 리턴(return)은 문자의 새 줄을 시작하는 데 쓰이는 제어 문자나 그 구조를 가리킨다. 컴퓨터 환경에서는 간단히 CR로 줄여 쓴다. 원래 캐리지 리턴은 타자기의 구조나 레버를 가리키는 용어였다.” 파일 업로드 - - MultipartRequest, Apache APIcos.jar, commons-fileupload.jar, commons-io.jar위와 같은 라이브러리를 이용해야 서버로 간단히 전송할 수 있음 MultipartRequest -생성자 매개변수 request, saveDirectory, maxPostSize, encoding, policyex)new MultipartRequest(request, “C:\\upload”, 510241024, “utf-8”, new DefaulFileRenamePolicy());getContentTypegetParametergetParameterNamesgetFilegetFileNamesgetFilesystemNamegetOriginalFileName Commons-FileUpload -DiskFileUpload 기본생성자.parseRequest(request)setRepositoryPath : 업로드된 파일 임시로 저장할 디렉토리setSizeMax : 최대 파일 크기 설정setSizeThreshold : 메모리상에 저장할 최대 크기 설정parseRequest : multipart/form-data 유형의 요청파라미터 get파일업로드 인스턴스 생성 후 파싱한 리스트 생성리스트 이터레이터를 통해 FileItem를 생성isFormField : 파일(false)인지 일반데이터(true)인지getFieldName : R.P.K getgetString : 기본 문자 인코딩을 사용하여 R.P.V getgetName : 업로드된 파일의 이름 getgetSize : 업로드된 파일의 크기get : 업로드된 파일을 byte[] isInMemory : 메모리 저장 유무. 임시 디렉토리에 있으면 falsedelete write : 파일과 관련된 자원 저장 getContentType : 콘텐츠 유형 반환 직접 해봐야 쉬움" }, { "title": "쉽게 배우는 JSP 웹 프로그래밍 - 2 - 내장 객체", "url": "/posts/jsp-2-object/", "categories": "공부, JSP", "tags": "자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": " 내장 객체 - - - - &gt; 컨테이너에 미리 정의된 객체서블릿으로 변환될 때 _jspService() 메소드 내부에 자동으로 포함됨 request : 요청 정보response : 요청에 대한 응답 정보out : 출력 스트림session : 세션 정보 저장application : web app context 정보 저장pageContext : JSP 페이지 정보 저장page : JSP 페이지를 구현한 자바 클래스(페이지 자체) 표시config : 페이지 설정 정보 저장exception : 예외 발생 처리? 속성 처리 메소드의 종류 get[set, remove]AttributegetAtrributeNames request - - 폼 페이지로부터 입력된 데이터를 전달폼에서 한글 입력을 정상적으로 처리하려면 문자 인코딩 값을 지정해줘야함getParameterValues : String[]getParameterNames : Enumeration (열거 클래스 아님) hasMoreElements, nextElementgetParameterMap : Map“웹 브라우저는 HTTP 헤더에 부가적인 정보를 담아 서버로 전송합니다”요청 HTTP 헤더 관련 메소드getHeader : String : 인수의 헤더 값getHeaders : Enumeration : 인수의 헤더 목록getHeaderNames : Enumeration : 모든 헤더의 이름getIntHeader : int : 인수의 헤더 값을 정수로getDateHeader : long : 인수의 헤더 값을 시간 값으로getCookies : Cookie : 모든 쿠키 값“웹 브라우저의 요청 및 서버 관련 정보를 얻을 수 있는 메소드를 제공합니다”getRemoteAddr : ipgetContentLength : 요청 파라미터의 길이getCharacterEncoding : 문자 인코딩getContentType : 콘텐츠 유형getProtocol : 요청 프로토콜getMethod : HTTP 요청 메소드getRequestURI : 요청한 URI 경로getContextPath : 현재 JSP 페이지의 app context 경로getServerName : 서버 이름getServerPort : 서버 포트getQueryString : 전체 요청 파라미터 문자열 속성을 공유할 수 있는 유효 범위 - -page - pageContext : 해당 페이지가 서비스를 제공하는 동안request - request : 클라이언트의 요청이 처리되는 동안session - session : 세션이 유지되는 동안 application - application : app이 실행되는 동안 response - - 서버는 응답 헤더와 요청 처리 결과 데이터를 웹 브라우저로 보낸다사용자가 새로운 페이지를 요청할 때와 같이 페이지를 강제로 이동하는 것을 redirection이라고 한다“forward 액션 태그는 url이 브라우저 주소 창에 나타나지 않아클라이언트가 이동 여부를 알 수 없다”sendRedirect 메소드는 페이지를 새로 요청한것 과 같은 방식으로URL이 변경되고 요청 정보가 이동된 URL에서 유효하지 않다. addCookieaddDateHeader addHeaderaddintHeadersetDateHeadersetHeadersetIntHeadercontainsHeadergetHeader 헤더 정보에 어떤 게 있는 지 알아야 메소드가 정리된다.“MIME 유형, 문자 인코딩, 오류 메시지, 상태 코드 등을 설정하고 가져오는 응답 콘텐츠 관련 메소드를 제공합니다”get-setContentType : MIME 유형get-setCharacterEncoding : 문장 ㅣㄴ코딩sendError : 오류 메시지setStatus : HTTP 코드 out - - &gt; 데이터를 전송하는 출력 스트림out 내장 객체는 스크립틀릿 태그에 사용하여 단순히 값을 출력하는 표현문 태그와 같은 결과를 얻음 print-ln : 이스케이프 문자 적용 안됨newLinegetBufferSizegetRemainingclearclearBufferflushisAutoFlush" }, { "title": "쉽게 배우는 JSP 웹 프로그래밍 - 1 - 태그", "url": "/posts/jsp-1-tag/", "categories": "공부, JSP", "tags": "자바, 웹", "date": "2022-06-23 09:11:00 +0900", "snippet": "jsp는 서블릿의 확장판이라고 볼 수 있다자바 기반의 동적 웹 프로그래밍 언어다JSP 컨테이너가 서블릿 파일 생성과 컴파일을 책임진다.?JSP는 다시 컴파일하고 프로젝트를 배포할 필요가 없다.“웹 서버는 정적 웹페이지처럼 *.class의 실행 결과를 웹 브라우저에 응답으로 전달하므로 웹 브라우저는 새로 가공된 HTML 페이지를 동적으로 처리한 결과를 보여줍니다”웹서버에서 클라이언트의 요청 중 웹 서버 자체적으로 처리할 수 없는 것은 컨테이너처럼 처리할 수 있는 곳으로 넘기기도 함 웹서버만으로 구축된 서버는 정적 페이지만을 생성한다.톰캣은 웹 컨테이너가 포함된 웹 애플리케이션 서버(WAS)이다.(웹 서버와 웹 컨테이너를 결합한 서버) JSP LifeSycle - - - - 번역 - TL 참조 태그의 정확성 검증 컴파일 - 자바 코드의 구문 검사(번역된) init - 클래스 로드, 초기화 service - request, response 컨테이너가 추가하기 때문에 service는 override 불가 destroyjsp 요청 시 jsp 수정 여부를 판단하고 번역 단계를 거침JSP 태그의 종류1.스크립트 - 자바 코드를 넣음 2.디렉티브 - 페이지 처리 방식 3.액션 - XML 형태의 태그. 제어와 관련됨 스크립트 태그 - - - - 선언문 &lt;%! . . . %&gt; : 변수 메소드 정의 클래스의 멤버로 들어감 사실상 필드에 속하기에 전역에 해당함스크립틀릿 &lt;% . . . %&gt; : 로직 service 메소드에 포함됨 ‘out.println( . . . )로 표현문처럼 사용할 수도 있음 문자열 형태로 HTML 태그를 적용할 수 있음 print 결과가 HTML로 이루어진 정적 웹페이지를 형성’표현문 &lt;%= . . .%&gt; : 호출 결과를 문자열 형태로 출력 service 메소드에 포함되어 print 메소드에 인수로 전달 인수로 전달되기에 작성할 때 세미콜론을 생략한다 out.print( . . . )에 그냥 들어감 주석 - - - JSP &lt;%-- . . . --%&gt; HTML &lt;!-- . . . --&gt; 서블릿으로 변환될 때 html 주석의 경우 name 변수가 없으면 오류 메시지 표시 JSP 주석은 잘 무시함 디렉티브 태그 - - - - &gt;페이지 관련 정보를 컨테이너에 지시 개별 HTML 응답에 특별한 영향을 미치지 않는다.&lt;%@ { page, include, taglib } %&gt; page - - &gt; 페이지 정보 “현재 JSP 페이지가 ~”language = java사용할 프로그래밍 언어contentType = text/html생성할 문서의 콘텐츠 유형pageEncoding = ISO-8859-1문자 인코딩import = 사용할 자바 클래스session = true세션 사용 여부buffer = 8KB출력 버퍼 크기autoFlush = true출력 버퍼의 동작 제어isThreadSafe = true멀티스레드 허용 여부info = 페이지에 대한 설명errorPage = 오류가 발생했을 때 보여줄 오류 페이지isErrorPage = false오류 페이지인지 여부isELignored = false표현 언어 지원 여부 ${ . . . }isScriptingEnabled스크립트 태그 사용 여부 include - - &gt; 특정 영역에 외부 파일의 내용을 포함함 참조를 적용해 재사용성과 유지보수에 도움&lt;%@ include file=\" . . . \" %&gt; taglib - - &gt; 표현 언어, JSTL, custom tag 등 TL 설정 &lt;%@ taglib uri=”path” prefix=”tag identifier” %&gt; ?아직 필요를 못느끼겠다★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★ 자바빈즈 - - &gt; 로직용 클래스데이터를 담는 멤버 변수인 프로퍼티와데이터 처리를 위한 메소드로 구성Serializable 구현(직렬화), 기본 생성자, private + get-set 액션 태그 - - - - &gt; 서/클 특정 행동을 명령 페이지 간의 제어, 자바빈즈 등XML 형식 &lt;jsp: . . . /&gt;forward : 페이지 이동(흐름 제어) 호출 시 현재 페이지에서의 출력 버퍼를 지우므로 주의include : 외부 페이지 내용을 포함하거나 페이지 모듈화 *디렉티브는 단순 소스 내용이 텍스트로 포함\t주로 조각 코드를 삽입할 때 액션은 페이지의 처리 결과를 포함시킴 페이지를 모듈화할 때useBean : 자바빈즈 설정&lt;jsp:useBean id=\"member\" class=\"com.dto.MemberBean\" \tscope=\"page\" /&gt;와 같이 작성함범위에는 page, request, session, application 중 하나의 값id는 변수명이라 생각해도 됨setProperty : 자바빈즈의 property set&lt;jsp:setProperty name=\"bean.id\" property=\"field type\" value=\"\"/&gt;요청 파라미터의 name 일치 여부에따라 value를 생략할 수 있음getProperty : 자바빈즈의 property getparam : forward, include, plugin에 인자 추가 forward나 include처럼 페이지 제어 관련한 태그와 함께 사용됨\t현재 페이지의 데이터를 전달할 수 있음plugin : 브라우저에서 자바 애플릿 실행, 브라우저별 코드 생성element : XML 요소 설정attribute : XML 요소 속성 설정 body : XML 요소 몸체 설정text : 페이지 및 문서에서 템플릿 텍스트 작성" }, { "title": "Sql, NoSql", "url": "/posts/sql-nosql/", "categories": "공부, 데이터베이스", "tags": "데이터베이스, mysql", "date": "2022-06-23 09:11:00 +0900", "snippet": "SQL은 구조화 된 쿼리 언어(Structured Query Language)의 약자다.관계형 데이터베이스와 상호작용하는 데 사용 하는 쿼리 언어다.관계형 데이터베이스에는 두 가지 주요 특징이 있다.데이터는 정해진 데이터 스키마를 따라 데이터베이스 테이블에 저장된다.데이터는 관계를 통해서 연결된 여러개의 테이블에 분산된다.아래에서 나오는 SQL은 관계형 데이터베이스를 뜻한다.1.엄격한 스키마데이터는 테이블에 레코드로 저장되며, 각 테이블에는 명확하게 정의된 구조가 있다.구조란 어떤 데이터가 테이블에 들어가고 어떤 데이터가 그렇지 않을지를 정의하는 필드 집합을 가르킨다.구조는 필드의 이름과 데이터 유형으로 정의된다.관계형 데이터베이스에서 스키마를 준수하지 않은 레코드는 추가할 수 없다.NoSql(비관계형 데이터베이스)스키마 없음, 관계 없음여기선 SQL의 레코드를 문서라 칭한다.단순히 이름만 다른 것이 아니라 핵심적인 차이점이 있는데,SQL에선 정해진 스키마를 따르지 않는다면 데이터를 추가할 수 없지만,NoSQL에서는 다른 구조의 데이터를 같은 컬렉션(테이블)에 추가할 수 있다.일반적으로 관련 데이터를 동일한 컬렉션에 넣어버리고대신 컬렉션을 통해 데이터를 복제하여 각 컬렉션 일부분에 속하는 데이터를 산출하도록 한다.,데이터가 중복되기 때문에 유지보수면에서 불안정하지만 Join을 사용할 필요가 없어자주 변경되지 않거나 조금이라도 속도를 중시한다는 점은 장점이다.Vetical &amp; Horizontal scaling수직 확장 : DB 서버 성능 향상 | | 수평 확장 : DB 서버 증설, DB 분산(여러 호스트에서 작동)데이터가 저장되는 방식 때문에 SQL은 일반적으로 수직 확장만을 지원한다.수평 확장은 NoSQL에서만 가능하다.SQL에서는 샤딩(Sharding)의 개념을 알고 있지만 특정 제한이 있으며 구현하기 어렵다.NoSQL에서는 이를 기본적으로 지원하므로 여러 서버에서 데이터베이스를 쉽게 분리할 수 있다.-따라서 두 가지 중 하나의 솔루션을 선택해야 되는 문제에서는 어떤 데이터를 다루는 지,.어떤 app에서 사용되는지를 고려해야한다. 무엇이 무조건 옳다는 것은 없다.SQL의 장점 명확하게 정의 된 스키마 - 데이터 무결성 보장 관계는 각 데이터를 중복 없이 한번만 저장된다.SQL의 단점 상대적으로 덜 유연하다. 데이터 스키마는 사전에 계획되고 알려져야한다. 관계를 맺고 있기 때문에, Join문이 많은 매우 복잡한 쿼리가 만들어질 수 있다. 수평 확장이 어렵다 - 어떤 시점에서 성장 한계에 직면하게 된다.NoSQL의 장점 스키마가 없기 때문에 유연하다. 언제든지 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다. 데이터는 app이 필요로 하는 형식으로 저장된다 - 데이터를 읽어오는 속도가 빨라진다. 수직, 수평 확장이 가능하므로 DB가 app에 발생시키는 모든 읽기/쓰기 요청을 처리할 수 있다.NoSQL의 단점 이러한 유연성 때문에 데이터 구조를 결정하지 못하고 미루게 될 수 있다. 데이터 중복은 여러 컬렉션과 문서가 여러 개의 레코드가 변경된 경우 업데이트를 해야 한다. 데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정해야 하는 경우 모든 컬렉션에서 수행함을 의미한다.그럼 언제 사용할까?SQL - 관계를 맺고 수정이 잦은 데이터일 경우, 변경될 여지가 없고 명확한 스키마가 중요한 경우NoSQL - 데이터 구조가 불분명하여 변경/확장 될 수 있는 경우 송수신이 잦지만 데이터 수정이 덜 한 경우, 수평 확장을 요하는 경우." }, { "title": "이것이 MySQL이다", "url": "/posts/mysql/", "categories": "공부, 데이터베이스", "tags": "데이터베이스, mysql", "date": "2022-06-23 09:11:00 +0900", "snippet": "이것이 MySQL 이다.관계형 데이터베이스 (RDBMS)테이블을 부르는 다른 용어로는 relation, entity 등이 있다.테이블 단위의 효율적인 저장 구조로 여러 개의 테이블로 나누어서 저장함으로써불필요한 공간의 낭비를 줄이고 효율성을 보장해준다.이렇게 나뉜 테이블의 관계를 기본 키(primary key), 외래 키(foreign key)를 사용해서 맺어 줌으로써,두 테이블을 부모와 자식 관계로 묶어줄 수 있다.추후에 부모자식 테이블을 조합해서 결과를 얻고자 할 경우 join 기능을 이용하면 된다.RDBMS의 가장 큰 단점은 시스템 자원을 많이 차지해서 시스템이 전반적으로 느려지는 것이다.최근 들어서 하드웨어의 급속한 발전으로 인해 이러한 단점은 많이 보완되고 있다.SQL은 국제 표준화 기관에서 표준화된 내용을 계속 발표해왔는데, 다음과 같은 특징을 갖는다.SQL은 국제 표준화기관에서 표준화된 내용을 계속 발표해왔다.DBMS 회사들은 이 표준 SQL에 맞춰 DBMS를 개발하므로 SQL은 제작회사와 독립적이다.하지만 모든 회사가 표준 SQL을 정확히 따르진 않는다.다양한 DBMS에서 상호 호환성이 뛰어나므로 이식성이 좋다.SQL 표준은 계속 개선되며 컴파일 없이 결과를 바로 얻을 수 있다.분산형 구조인 클라이언트/서버 구조를 지원한다.기본 키는 행을 구분하는, 테이블 내 단 하나만 존재하는 개념이다.서로 중복되지 않고 완전히 구분되는 데이터열을 보통 기본 키로 지정한다.기본키라는 식별자로 외래키를 다른 테이블에 지정해주면외래키의 데이터만으로 기본키가 속한 레코드의 다른 데이터와 관계를 맺을 수 있고이러한 관계를 테이블의 1대다 관계라고 말할 수 있다.기본키의 데이터가 아닌 경우 외래 키에서 사용할 수 없고 기본 키를 삭제하기 위해서외래 키가 속한 레코드부터 삭제해야한다.모델을 활용하여 다이어그램으로 표현할 수 있고기존에 있던 스키마도 REVERSE하여 다이어그램으로 즉시 표현할 수 있다.스키마 목록에서 원하는 테이블 우클릭 후[Send to SQL Editor] » [Create Statement]를선택하면 현재 쿼리 창에 선택한 테이블을 생성하는 SQL 구문이 나온다.Duration SQL문이 실행되는데 걸린 시간, Fetch 데이터를 테이블에서 가져오는데 걸린 시간=ANY, IN, =SOME은 동일한 효과를 낸다.집계 함수는 주로 GROUP BY절과 함께 쓰이며 데이터를 그룹화해준다.DML (Data Manipulation Language) 데이터 조작 언어 DML 구문이 사용되는 대상은 테이블의 행이다. 테이블 정의가 필수.SELECT, INSERT, UPDATE, DELETETransaction: 테이블의 데이터를 변경할 때 실제 테이블에 완전히 적용하지 않고 임시로 적용. DML 소속INSERT [INTO] 테이블[(열1, 열2, . . .)] VALUES (값1, 값2 . . .)AUTO_INCREMENT 적용된 일반 키 필드의 경우 NULL 값을 넣으면 자기 알아서 숫자 넣음.ALTER TABLE 테이블 AUTO_INCREMENT=N; « N번째부터 숫자가 입력됨.증가값 자체를 늘리려면 SET @@auto_increment_increment=N;SELECT LAST_INSERT_ID(); 쿼리를 실행하면 마지막의 숫자를 출력.대량 입력 INSERT INTO 테이블 (열1, 열2 . . .) SELECT문; 다른 테이블의 데이터를 가져와서 입력할 수 있음 CREATE TABLE 테이블 (SELECT문)으로 코드 축약 가능DELETE는 행 삭제를 뜻하고 이 역시 WHERE문 생략시 전체 데이터가 삭제됨.대용량 테이블을 삭제하는 경우 DELETE, DROP, TRUNCATE를 사용할 수 있는데DELETE는 DML 언어이기에 트랜잭션이 적용되어 오래 걸림.테이블의 구조를 남겨두고 싶다면 TRUNCATE, 아니면 DROPWITH 절은 CTE(Common Table Expression)를 표현하기 위한 구문 MySQL(8버전부터)CTE는 기존의 뷰, 파생 테이블, 임시 테이블 등으로 사용되던 것을 대신할 수 있다.비재귀적, 재귀적 CTE가 존재하고 교재에선 비재귀적 CTE에 대해서 학습한다.DDL (Data Definition Language) 데이터 정의 언어데이터베이스, 테이블, 뷰, 인덱스 등의 데이터베이스 개체를 생성/삭제/변경하는 역할을 한다.자주 사용하는 구문은 CREATE, DROP, ALTER 등이 있다. Transaction 발생시키지 않음.DCL (Data Control Language) 데이터 제어 언어사용자에게 어떤 권한을 부여하거나 빼앗을 때 주로 사용하는 구문GRANT, REVOKE, DENY 등이 있다.CHAR, VARCHAR 모두 UTF-8 형식을 지원하고 있지만 내부 할당 크기는 신경쓰지 않아도 된다.MySQL 은 많은 내장 함수를 포함하고 있다.크게 제어 흐름, 문자열, 수학, 날짜/시간, 전체 텍스트 검색, 형 변환, XML, 비트, 보안/압축,정보, 공간 분석, 기타 함수 등으로 나눌 수 있다.전체 함수의 개수는 수백 개가 넘는다.SQL 고급 부턴 쓸 일이 없다.CREATE TABLE 스키마, 테이블(필드 타입 속성 필드명, . . ., PRIMARY KEY(필드, 필드)) COMMENT = 메시지CREATE TABLE 테이블 ( SELECT 필드 FROM 테이블 )ALTER TABLE 테이블 (RENAME, MODIFY,CHANGE) 테이블명,타입,필드명과 속성 변경ALTER TABLE 테이블 ADD [CONSTRAINT] FOREIGN KEY(필드) REFERENCES 테이블(필드)ALTER TABLE 테이블 ALTER COLUMN 필드 SET DEFAULT 데이터INSERT INTO 테이블 VALUES(데이터,데이터),( . . . ),( . . . ) INSERT INTO 테이블 SELECT 필드,필드 FROM 테이블UPDATE 테이블 SET 필드 = 데이터, 필드 = 데이터DELETE FROM 테이블 WHERE 필드 = 데이터집계 함수는 GROUP과 함께 사용되고 집계 함수의 값에 대한 조건을 두고 싶다면 HAVING까지SELECT JSON_OBJECT(필드, 데이터, 필드, 데이터) FROM 테이블 WHERE 조건문 SELECT 필드 FROM 테이블 JOIN 테이블 ON 테이블.KEY = 테이블.KEY – 꼭 KEY 여야 하나? ON은 WHERE처럼 필터기능OUTER JOIN을 할때 ON/WHERE 어디에 조건을 걸어야될지 헷갈릴때가 있다.당연히 A와 B의 조인 KEY값은 ON에 들어가야된다.그리고 ON 절에서는 우측(B)의 추가 제약 조건이 들어가면 되고좌측(A)의 추가 제약조건은 WHERE절에 들어가면 된다.특정 테이블 내의 정보만 필요하다면 JOIN할 필요 없다.COMMIT과 ROLLBACK은 전체 스키마에 적용된다.CONSTRAINT 는 키 이름 지정해줄 때 같이 적는 것 같다.두 개의 열을 함께 기본 키로 지정할 수 있다.기본 키가 적용되면 인덱스 지정도 같이 됨뷰는 기존 테이블의 SELECT 문에 나온 결과에 대한 포인터를 갖는 테이블이다.뷰의 데이터를 수정하면 참조 테이블의 데이터도 변경된다.집계 함수, UNION ALL, JOIN, DISTINCT, GROUP BY로 나타난 데이터 수정불가대용량 테이블은 별도의 테이블스페이스에 따로 저장하는 것이 성능에 효과적이다.클러스터형 인덱스 = 기본 키 형 인덱스 = UNIQUE NOT NULLunique = 보조 인덱스인덱스는 중복된 값을 막기 때문에 현재 중복된 상태가 아니라해서 막 넣으면 안된다.CREATE INDEX 인덱스이름 ON 테이블 (필드)SHOW TABLE STATUS LIKE ‘테이블’SHOW INDEX FROM 테이블ALTER TABLE 테이블 DROP PRIMARY KEYData_length : 데이터 페이지 또는 클러스터형 인덱스의 크기 Index_length : 보조 인덱스의 크기 MySQL은 한 페이지(Heap)가 16KB 이다.보조 인덱스를 사용하면 Index_length가 늘어남 = 페이지가 늘어남 = DB 용량이 늘어남 보조 인덱스 중에서 전체 데이터의 대략 15% 이상을 스캔하는 경우 인덱스를 사용하지 않고 스캔한다. WHERE 문에 인덱스를 사용하도록 유도했지만 연산이 추가되면 사용하지 못할 수가 있다. 연산이 필요하다면 우변으로 넘겨서 해준다. 인덱스는 WHERE를 통해 활용하고, 자주 사용해야 가치있다. 특히 클러스터형 인덱스 사용 중에는 INSERT 작업 성능이 크게 하락한다. 페이지 분할과 동시에 전체 데이터의 이동이 발생할 수 있기 떄문. 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다. 오히려 인덱스 관리 비용만 늘어날 수 있음. 왜래 키를 지정한 열에는 자동으로 외래 키 인덱스가 생성된다. JOIN에 자주 사용되는 열에 인덱스를 생성해주는 거이 좋다. 인덱스는 단지 읽기 성능만 향상시키며 데이터 변경에서는 큰 부담을 준다.회원 ID열을 클러스터형 인덱스로 지정한 상황이라면 아이디란 사용자에 따라 무작위로 등록되는 것이므로 페이지 분할, 데이터 분산이 동시에 일어나므로 예를 들어 할인 행사가 시작했을때 단기간 많은 회원가입이 이루어져 사이트가 마비될 수 있다.스토어드 프로그램에는 스토어드 프로시저, 스토어드 함수, 트리거, 커서 등이 있다. 예외 처리는 프로시저에서 많이 쓴다..테이블 이름을 파마리터로 사용할 수 없다. 동적 SQP(PREPARE)와 CONCATE을 활용하면 파라미터로 테이블 이름을 넘길 수 있다.스토어드 프로시저의 장점 유지보수, 모듈식 프로그래밍, 보안 강화, 성능 향상스토어드 함수 = 사용자 정의 함수 STORED PROCEDURE 와 FUNCTION의 차이점을 FUNCTION 시각에서 관찰하면, IN, OUT의 구분된 매개변수를 사용할 수 없다. 오로지 IN 매개변수만 사용된다. OUT이 없는 대신 RETURN이 존재하여 반환값을 지정할 수 있다. 내부에서 SELECT를 사용할 수 없고 오히려 SELECT 문장 안에서 호출된다.커서 프로시저 내에서 루프문과 함께 데이터를 가져와 다룰 때 사용함 루프 탈출을 위한 예외 처리도 필요하며 데이터를 가져오는 행위를 FETCH라고 정의트리거 트리거는 테이블에 부착되는 프로그램 코드라고 생각할 수 있다. 직접 실행 시킬 수 없고 이벤트 발생에 의해서만 동작된다. DELETE 트리거는 TRUNCATE 동작시엔 적용되지 않는다. 다중 트리거: 하나의 테이블에 동일한 트리거가 여러개 부착 중첩 트리거: 하나의 트리거가 또 다른 트리거를 작동시키는 것파티션도 나눌 수 있다 끗" }, { "title": "자바 팁", "url": "/posts/summary/", "categories": "그 외, deprecated", "tags": "자바, 이펙티브 자바", "date": "2022-06-17 01:36:00 +0900", "snippet": "equals와 hashcode 재정의hash 컬렉션은 hashcode가 다르면 다른 객체로 인식하여equals만 재정의한다면 동일한 객체로 식별되지 않는다.equals를 재정의할 거라면 hashcode도 함께 재정의하자.hashcode는 필드값 연산으로 깔끔하게 재정의메소드 내부가 넘치지 않도록메소드는 단 한가지의 기능만 사용하도록 작성하고 (SRP)웬만하면 10줄 이상으로 넘어가지 않게 만들자도트 연산자는 한 줄에 하나만 쓰도록 하자메소드당 들여쓰기를 한차례만 하자는 말도 있다그렇다면 기능은 자연스레 분리되겠지만 메소드 개수가 넘쳐날 것이다모듈을 명확히 구성인터페이스나 컴포지션으로 기능을 분리(또는 위임)하여 사용자 클래스의 OCP 원칙을 지키자예외도 던지자유효성 부적합 판정을 받았을 때 return이 아닌 비검사 예외를 명시하되 표준 예외를 사용하자상속은 코드 재사용을 위한 게 아니다상속은 is-a 관계를 완벽히 충족할 때만 사용한다소켓은 1대1 통신이다서버 소켓에 클라이언트 소켓이 접근하면 accept 메소드는클라이언트 소켓과 1대1로 연결시킬 서버 측 소켓을 반환한다이 소켓은 서버 소켓과 동일한 포트를 갖는다생성자 매개 변수가 많다면인스턴스 필드의 개수가 많아 초기화할 매개 변수의 양이 많은 경우에빌더 패턴을 사용하자. 계층 구조에서도 활용할 수 있으며현재 필드가 적더라도 늘어날 가능성이 있다면 비용은 뒤로하고 빌더로 설계하자매력덩어리 EnumEnum을 유용하게 다뤄야 한다. 정수형 열거는 구식 방법이다Enum을 이용한 싱글턴, enumMap, enumSet 그리고 방어적 복사를 생략하는강력한 불변객체에 이용할 수 있다.향상된 for문enhanced-for(for-each)문은 iterable 인터페이스를 상속한 클래스만 가능하다for( Iterator&lt;String&gt; str = strings.iterator(); str.hasNext() ){};로 표현할 수 있다.또는 선언은 외부에하고 while문에 hasNext를 넣으면 동일한 표현이다for-each문 내부에서 컬렉션 수정에 대한 실행문은 자제하자문자열 리터럴과 String 인스턴스문자열 리터럴은 자바7부터 heap영역의 String constant pool에 저장되며참조를 잃으면 GC에 의해 제거된다.String 클래스의 hashcode는 재정의하여 문자열이 같다면동일한 해시코드를 반환한다. (equals와 hashcode가 올바르게 재정의됨)(==) 동등 연산자는 System.identityHashCode의 해시코드를 비교한다. (maybe)문자열 리터럴의 경우 동등연산자의 SystemHashcode가 동일하게 나타난다.불변식은 thread-safe를 보증하므로 문자열 리터럴은 스레드 안전하다메소드를 정의할 때 매개 변수 타입은 최대한 인터페이스로 작성한다제네릭은 타입 검사기를 지배한다제네릭이 타입 의존성에서 벗어난다는 건 착각이다컴파일 환경에서 raw 타입과 달리 타입에 대한 제약이 생긴다이 때문에 타입 검사가 엄격히 이루어져 컴파일 단계에서Runtime Exception을 방지할 수 있다. 런타임 환경에서의 제네릭 타입은 호환을 위해 타입 소거가 발생한다.(와일드카드는 런타임 환경에서 타입이 실체화됨)instanceof 를 이용한 분기문보다 재정의와 다형성을 이용하자방어적 복사에 방어적이면 안된다클라이언트로부터 데이터를 보호하기위해 방어적 복사를 지향해야 하며,방어적 복사는 깊은 복사를 사용하거나 아래의Collections.unmodifiableXXX 메소드도 이용할 수 있다.Stack? 이제는 DequeStack 대신 Deque, ArrayDeque를 사용하자 (공식 문서 권장)ArrayDeque는 스레드 안전하지 않기 때문에 멀티 스레드 환경에서는LinkedBlockingDeque, ConcurrentLinkedDeque을 이용하자. 전자는 멀티 스레드 환경의 단일 스레드, 후자는 멀티스레드 권장반복과 공유가 잦은 객체는 정적으로정적 멤버는 클래스 소속으로 인스턴스 없이 사용할 수 있다는관점에서만 바라볼 게 아니라 불필요한 메모리 할당을 방지할 수도 있다물론 이 때문에 오히려 효율이 떨어질 수도 있으므로 적절히 사용한다정적 멤버는 공유되고 반복되는 상황에서 효율적이다VO 관련직렬화나 DB 데이터 송수신때 불필요한 정보를 제외하거나중복된 값이 많은 어떤 묶음의 데이터를 처리할 때 VO(값 객체)는 유용하다동등성을 판별하는 필드로 최적화된 건 Priamary Key 적용 여부에 따를 수 있다컬렉션 프레임워크 시대배열보다 컬렉션 사용을 지향하는 이유는 제네릭 타입과데이터 조작 시에 다양한 api를 사용할 수 있기 때문이다null 방어의 대안 “Optional”런타임 NPE 방어 로직은 가독성과 유지 보수성이 떨어진다null을 다룰 일이 생긴다면 Optional 클래스를 이용해보자인수에 리터럴을 주는 건 좋지 않다소스 코드에 데이터를 직접 입력하는 하드 코딩을 피하자예를 들어 배열 선언 시 길이를 초기화할 때 직접 값을 적기 보단상수를 미리 정의하고 그 상수를 대입해준다데이터가 직접 기입되어 있다면 유지보수에 애로사항이 생긴다재귀라는 게 있긴 있다웬만하면 재귀보단 반복문을 사용한다재귀는 stack overflow 발생 염려가 있다가능한 private하게자바 빈 설계 규약에 따르면 자바 빈 클래스 설계 시클래스의 멤버변수의 접근제어자는 private이며, 모든 멤버변수에 대해 getter, setter가 존재해야 한다. getter는 매개변수가 없어야 하며, setter는 하나 이상의 매개변수가 있어야 한다. 난 빈 이외에도 습관처럼 하고 있다.객체 자신의 본분을 다하도록상태를 가지는 객체를 추가했다면 객체가 제대로 된 역할을 하도록 구현해야 한다.객체가 로직을 구현하도록 해야한다.상태 데이터를 꺼내 로직을 처리하도록 구현하지 말고 객체에 메시지를 보내 일을 하도록 리팩토링한다.데이터베이스는 귀하게 대하기비즈니스 로직은 DB가 아닌 앱에 넣자일반적으로 app 서버 리소스가 DB 서버 리소스보다 확장하기 훨씬 더 쉽기 때문에대용량 데이터 중 소수만 가져오는 류의 로직이 아닌 이상 DB 리소스 사용을 최소화예외를 책임질 자신 있는가try catch 처리를 남발하면 오류가 발생했을 때 제어 흐름이이 중단되지 않아부차적 문제를 발생시킬 수 있고 stack trace를 보존하지 않는 로깅은디버깅을 어렵게 만드는 일이다. 즉, 책임지지 못할 오류는 잡지 않는다.그래야 JVM이나 어딘가에서 로그를 남길 것이기 떄문이다.버킷의 개수를 예측하자Collection Framework를 사용할때 버킷의 개수가 예상된다면생성자의 인자로 넣어 불필요하게 버킷의 개수가 늘어나는 과정을 배제시킨다.모던 api는 기능보단 가독성Optional과 Collection stream은 가독성을 챙기기 좋은 수단이다.Optional의 작동 방식은 stream과 많이 흡사하다.임시함수형 인터페이스는 함수를 1급 객체처럼 다룰 수 있게 한다단 하나의 추상 메서드를 가지는 인터페이스며 이를 이용하면 행위를 값으로 취급할 수 있다.Consumer&lt;Integer&gt; con = System.out::println;필드 선언을 위와 같은 형식으로도 할 수 있게 되었다.임시Arrays.asList의 반환 타입은 update 관련 메소드를 사용할 수 없다수정이 필요하다면 new 연산자를 통한 ArrayList를 이용하면 된다둘다 stream은 이용할 수 있다" }, { "title": "이것이 자바다 - 자바FX - 2", "url": "/posts/javafx-2/", "categories": "그 외, deprecated", "tags": "자바, 자바FX, GUI", "date": "2022-06-05 09:11:00 +0900", "snippet": "++ 이벤트 핸들러 ++FX는 이벤트 발생 컨트롤과 핸들러를 분리하는 위임형 방식 사용button.setOnAction(new EventHandler&lt;ActionEvent&gt;( ){실행문})익명 구현 객체를 이용한다. 함수형 인터페이스이므로 람다 가능stage.setOnCloseReques( e -&gt; { . . . } );FXML 컨트롤러루트 컨테이너 start tag 내부에fx:controller=\"package.Controller\"&gt;와 같이 작성된다. 패키지명과 Initializable 인터페이스의 구현 클래스명이다. 실체 메소드로 initialize가 있는데 컨트롤러 객체가 생성되고 나서 호출된다. 주로 UI 컨트롤의 초기화, 이벤트 핸들러 등록, 속성 감시 등의 코드가 작성된다.컨트롤러는 이벤트 핸들러를 등록하기 위해서, 그리고 이벤트 처리 시 UI를 변경하기 위해서 FXML파일에 포함된 [컨테이너] 및 [컨트롤]의 참조가 필요하다. 이를 위해서 FXML 파일에 포함된 컨트롤들은 fx:id 속성을 가진다.&lt;Button fx:id=\"btn1\" text=\"버튼1\" /&gt;fx:id 속성을 가진 컨트롤들은 컨트롤러의 @FXML 어노테이션이 적용된 필드에 자동 주입된다. (id 속성값과 필드명이 당연히 같아야함)로더가 FXML 파일을 로딩할 때, 태그로 선언된 컨트롤 객체가 생성되고, 아울러 컨트롤러 객체도 함께 생성된다. 이후 어노테이션이 적용된 필드에 컨트롤 객체가 주입된다.EventHandler 등록 컨트롤에서 발생하는 이벤트를 처리하려면 컨트롤러의 intialize 메소드에서 EventHandler를 생성하고 등록해야함 클래스 멤버 메소드로 각 핸들러를 정의하고 내부에서 setter와 람다 사용&lt;Button fx:id=\"btn\" text=\"버튼\" onAction=\"#handleBtnAction\"/&gt; public void handleBtnAction(ActionEvent event){ . . .} 컨트롤 요소 태그에 메소드를 직접 작성함으로써 간단히 매핑할 수 있다.++ 컨트롤의 속성감시 ++ 특정 컨트롤 요소의 value에 대한 리스너를 설정하여 다른 컨트롤러를 호출한다. FX 컨트롤 속성은 세 가지 메소드로 구성된다. Getter, Setter 그리고 Property 객체를 리턴하는 메소드이다.text(컨트롤)의 속성 중 textProperty가 리턴하는 StringProperty에 리스너 설정textPropery().addListener(new ChangeListener&lt;String&gt;() {\t@Override\tvoid changed(ObservableValue&lt;? extends String&gt; observable,\t\t\tString oldValue, String newValue) } );addListener 메소드가 ChangeListener를 Property 객체에 설정하면,text 속성이 변경되었을 때 changed 메소드가 자동으로 실행된다.속성 바인딩Property로 속성을 호출하고 묶는다. 양방향으로 묶고 싶다면 bindBidirectional 메소드를 이용하자. 또는 Bindings.bindBidirectional( P p1, P p2 );, 해제하고 싶다면 unbind 위의 bind 메소드 결과는 전위 객체는 후위객체에게 행위 종속된다. 어떤 ???Property 메소드가 존재하는지, 리스너의 종류를 알아보자. 연산된 속성 바인딩```circle.centerYProperty().bind(Bindings.divde(root.heightProperty(), 2));```원의 Y축 중앙 지점을 컨테이너 높이의 절반 위치에 고정시킨다.- - -++ FX 컨트롤 ++ 버튼 컨트롤: ButtonBase를 상속하는 하위 컨트롤 Button, CheckBox, RadioButton, ToggleButton, Hyperlink ImageView를 매개값으로 setGraphic 메소드 호출하면 아이콘 넣을 수 있음. ```&lt;RadioButton text=\"L\" userData=\"V\" toggleGroup=\"$GN\" selecte=\"true\"/&gt;```입력 컨트롤 TextField(한줄), TextArea(여러줄), PasswordField, ComboBox (제한된항목)DatePicker, ColorPicker, HTMLEditor 뷰 컨트롤 ListView, TableView, ImageView미디어 컨트롤 MediaView, Slider, ProgressBar, ProgressIndicator (Image, Media 둘 다 생성자에 리소스 경로를 인수로 넘기며 인스턴스화)차트 컨트롤- - -++ 메뉴바와 툴바 ++ MenuBar, menus, MenuItem, (Check, Radio, Custom, Separator)+MenuItemaccelerator는 KeyCodeCombination 객체를 이용하여 단축키를 설정한다.툴바는 UI 컨트롤이면서 컨테이너이기도 하다. - - -++ 다이얼로그 ++ 모달과 모달리스로 나뉘고 전자는 owner(Stage)를 중지시킨다. FileChooser, DirectoryChooser, Popup - - - start 메소드에서 컨트롤러로 primaryStage를 전달 FXMLLoader loader = new FXMLLoader(getClasee().getResource(“fxml”));Parent root = loader.load();RootController controller = loader.getController();controller.setPrimaryStage(primaryStage);```RootController 클래스에 위 setter 메소드를 정의해야한다." }, { "title": "이것이 자바다 - 자바FX - 1", "url": "/posts/javafx-1/", "categories": "그 외, deprecated", "tags": "자바, 자바FX, GUI", "date": "2022-06-05 09:11:00 +0900", "snippet": "init을 제외한 fx api는 application 스레드가 관리한다.–ip=192~ 와 같이 main 메소드 인자를 작성하면=을 기준으로 매핑하거나 함께 리스트에 추가한다.윈도우를 무대(Stage)로 표현하며무대는 한 번에 하나의 장면(Scene)을 가진다.메인 윈도우는 start 메소드의 매개 값으로 전달되지만장면은 직접 생성해야 한다.UI의 루트 컨테이너인 Parent 클래스가 필요하다.Scene scene = new Scene(Parent root)Parent는 추상 클래스이기 떄문에주로 layout 패키지의 컨테이너들이 사용된다.장면을 생성한 후 윈도우에 올리기 위해서Stage의 setScene 메소드를 사용한다.컨테이너를 Parent를 상속하는 클래스로 정했을 때마찬가지로 getChildren 메소드로 Label, Button 등의UI 컨트롤 요소를 특정 컨테이너 내부에 삽입한다. (ObservableList 혹은 getChildren 이후 add 메소드)마지막으로 하나의 장면인 Scene을 윈도우에 올려준다.장면에는 다양한 컨트롤이 포함되는데이들을 배치하는 것이 레이아웃이다.레이아웃은 프로그램적, 선언적(FXML) 두 가지로 나뉜다. - - - FXML 작성 요령은컨테이너 내부에 여백과 간격 그리고 Children 태그를수평적으로 구성하고 Children 태그 내부에 컨트롤 요소를 작성마진과 패딩은 Insets 객체를 이용한다.FXML 로딩과 Scene 생성FXML 파일을 작성한 후 읽어들여 선언된 내용을 객체화해야함.동일한 패키지에 있을 경우```Parent root = FXMLLoader.load(getClass().getResource(\"xml\"));```다른 패키지에 있을 경우로더 타입 변수에 참조 후 명시적 형변환을 이용하여Parent 타입 변수에 참조FX의 컨테이너AnchorPane 컨트롤을 좌표로 배치 빌더 이용, 좌표 배치이기에 윈도우 사이즈 조절 불가능하도록BorderPane \"상하좌우중\"에 컨트롤 배치 각 셀에 하나의 컨테이너 또는 컨트롤을 배치FlowPane 행으로 배치, wrapGridPane 그리드로 배치, 크기 유동적 셀 셀 크기 유동적, 병합 가능, 입력 폼에 특화TilePane 그리드로 배치, 크기 고정적 셀 (그리드는 단순히 격자 형태를 의미) FlowPane과 비슷하나 셀 크기 고정적StackPane 컨트롤을 겹칠 수 있음 Z-Index 특성을 가짐HBox 수평 VBox 수직 - - -외부 CSS Type, id, class (Selector) 컨테이너 태그에 ```stylesheets=\"@app.css\"&gt;``` OR```scene.getStylesheets().add(getClass().getResource(\"app.css\".toString))```기능은 CSS 구버전과 같음 문법은 -fx- 추가 - - - FX Application Thread는 싱글 스레드다.시간을 요하는 작업이 진행될 땐 Worker Thread를 생성해야한다.문제는 작업 스레드가 UI를 직접 변경할 수 없기 때문에1.Platform.runLater2.javafx.concurrent API인 Task, Service둘 중 하나를 골라 사용해야 한다.1. ```Platform.runLater(Runnable run);```이벤트 큐에 Runnable을 저장하고 즉시 리턴함. (lazy)2. Task는 비동기 작업. Service는 Task 작동 관련 기능 제공익명 자식 객체로 call을 재정의해서 사용하자.Task가 Runnable 인터페이스를 구현하고 있기 때문에Runnable 매개 변수를 받는 인수에 전달할 수 있다.이럼에도 UI를 직접 다룰 순 없으므로call 메소드 내부에서 updateProgress, updateMessage 메소드를 호출하며컨트롤러에서 바인딩하여 활용할 수 있다.더 복잡한 구성을 원한다면 call 메소드 내부에Platfrom.runLater를 호출하여 UI 변경코드를 작성한다.Service 클래스는 작업 스레드와 JFAT가 올바르게 상호작용할 수 있도록 도움Service 익명 자식 객체 내부에 createTask를 재정의하고그 내부에 Task 생성과 call 재정의가 또 필요함.while ( string a = readline != null) if( not chat 화면일때 )popup 띄우겟다```" }, { "title": "이펙티브 자바 용어", "url": "/posts/EJ-term/", "categories": "그 외, deprecated", "tags": "자바, 이펙티브 자바", "date": "2022-06-01 09:11:00 +0900", "snippet": "익스트림 프로그래밍 (xp)비즈니스 상의 요구가 시시각각 변동이 심한 경우에 적합한 개발 방법정적 팩토리 메소드객체를 생성하는 역할을 분리하는 static 메소드컴포넌트재사용이 가능한 독립된 모듈컴포지션기존 상속의 단점을 보완하기 위하여 새로운 클래스를 정의하여필드에 인스턴스를 선언하고 다룸(상속은 is-a를 완벽히 따를 때 사용)재귀적 타입 한정타입 매개변수가 자신을 포함하는 수식에 의해 한정되는 것ex) &lt;T extends Comparable&lt;T&gt;&gt;열거 타입의 싱글턴원소가 하나인 열거 타입은 싱글턴임을 강하게 보증하지만상속 구조 형성 여부를 따지고 정해야함자기 메모리를 직접 관리하는 클래스메모리를 직접 관리하는 클래스(Stack 등)는 JVM이원소가 참조하는 객체들이 어디까지 활성 영역인지 알수 없다.구체 클래스(Concrete class)자신의 생성자로 인스턴스를 생성할 수 있는 클래스심볼릭 링크일종의 참조캐싱사용 빈도가 높고 변경은 드문 데이터를 정적 메모리에 키를 부여해 보관하여데이터의 물리적 전송 거리를 줄임로깅로그를 생성하는 과정모든 행위와 이벤트 정보를 시간의 경과에 따라 기록한 데이터믹스인상속 계층에 무관한 클래스에서 사용할 수 있는 메소드를 포함하는 클래스(포함관계)구현된 메소드가 포함된 인터페이스로 볼 수 있다(종속성 역전 원칙의 예)공변 반환 타입(Covariant Return Type)오버라이딩에서 반환 타입이 변경됨가변 객체와 불변 객체대표적인 불변객체 = String대부분의 인스턴스는 가변 객체(내부 상태가 일정하지 않음)배열 clone 복사 깊이객체가 낀 순간 깊은 복사 노가다 시작, 얕은 복사는 쓸 일 없을 듯아키텍처프로그램 주요 구조 설계컴포넌트의 집합이라 말할 수 있을까?정적 클래스의 특징중첩 클래스만이 정적 클래스 선언할 수 있음인스턴스를 만들 수 없음정적 임포트클래스 이름 없이 직접 다룰 수 있음구현부와 api의 분리흔히 인터페이스를 이용해 분리함inter-face 상호작용JLS - java language specification동반 클래스자바8 이전의 인터페이스와 관련된 정적 메서드들을 제공한 클래스대표적인 예로 Collection 인터페이스와 Collections 동반 클래스hook 메소드abstaract는 재정의를 강제하나 hook은 선택적으로 할 수 있는 메소드타입 안전 혼성 컨테이너(type safe heterogeneous container pattern)컨테이너 대신 키를 매개변수화 한 다음, 컨테이너에 값을 넣거나 뺄대 매개변수화 한 키를 함께 제공한다.각 타입의 Class 객체를 매개변수화한 키 역할로 사용한다이때 class 리터럴의 타입은 Class이다.코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우리플렉션구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API런타임 환경에서 클래스 정보를 추출할 수 있음검사 비검사 예외Exception은 Checked형 검사 예외 Error (컴파일)RuntimeException은 UnChecked 비검사 예외 (런타임)접근자 메서드 접근 제한된 멤버를 사용할 수 있게 해주는 메소드마이그레이션다른 운영환경으로 옮겨가는 과정reentrant여러 쓰레드가 코드를 동시에 수행할 수 있고 동시성을 보장한다.구식 Thread-safe의 상향버전스택 추적 캡처프로그램 실행 중 특정한 시점에서의 스택 프레임에 대한 리포트런타임 제네릭 타입 소거제네릭의 장점은 컴파일 타임에 타입에 대한 안정성을 보장받을 수 있다.컴파일 타임에만 타입에 대한 제약 조건을 적용하고,런타임에는 타입에 대한 정보를 소거한다." }, { "title": "자바 정리", "url": "/posts/java/", "categories": "그 외, deprecated", "tags": "자바", "date": "2022-05-23 09:11:00 +0900", "snippet": "삼항연산자는 경우가 두 가지일때. if else를 나타내기 싫다면.지역 변수는 선언된 지역을 벗어나면 메모리 공간에서 소멸된다.new 연산자는 정확히, 생성된 인스턴스의 주솟값을 반환하는 것이다.a 참조 변수에 인스턴스 주솟값을 던지고 b = a 로 하나의 인스턴스 주소를 두 참조 변수에 할당시킬 수 있다.환경 변수의 classpath는 특정한 상황이 아니면 되도록 사용하지 말야아 한다?정보 은닉: 자바에서 말하는 ‘정보’는 클래스의 ‘인스턴스 변수’를 의미한다. 따라서 정보를 은닉한다는 것은인스턴스 변수를 숨긴다는 뜻이다. (private 선언)캡슐화: 하나의 목적을 이루기 위해 관련 있는 모든 것을 하나의 클래스에 담아 두는것JVM상에서 클래스 로딩이 완료되어야 인스턴스 생성이 가능한데 클래스 로딩이 되는 시점에 정적 멤버는 이미 메모리 영역에 할당되어있다.참조를 목적으로 정적 멤버를 선언할 때, 특히 필드 멤버에겐 final 선언에 대한 여부를 고민해볼 필요가 있다.main 메소드의 호출이 이뤄지는 영역은 클래스 외부이다. 따라서 public으로 선언하는 것이 타당하다.클래스 로딩과 동시에 정적 멤버를 초기화 시키기 위해서 블록 스코프로 감싸줄 수 있다.패키지 import를 static으로 선언하면 클래스 이름 없이도 정적 멤버를 사용할 수 있다.StringBuilder: 메소드에 따라 불필요한 인스턴스를 계속 생성하여 메모리 낭비를 가하는 String의 일부 기능의 대안.StringBuilder는 인스턴스 내부에 문자열 관리를 위한 메모리 공간이 존재한다.이 메모리 공간은 말 그대로 문자를 얼마나 지정할 수 있느냐이며input된 양에 맞게 직접 조절한다. 하지만 이러한 공간 변화는 소모가 많은 작업이므로애초에 적절한 크기의 공간을 생성자 호출 시에 적용해주면 된다.기본 값: 16개의 문자를 저장, 정수: N개의 문자를 저장할 수 있음, 문자열: 매개값과 16개의 문자를 추가로 저장할 수 있음.주요 메소드 append, delete, insert, replace, reverse, substring, toStringStringBuilder는 기존의 인스턴스를 계속 수정하며 그 주소를 반환하는 것이다.StringBuilder stb1 = new StringBuilder(\"123\");stb1.append(45).append(67) . . .주소를 반환하고 주솟값에 해당하는 인스턴스를 다시 찾아감.StringBuilder 클래스(자바5) 이전에 사용 되던 StringBuffer 클래스둘의 공통점 : 생성자를 포함한 메소드의 수, 메소드의 기능, 메소드의 이름과 매개변수의 선언세 가지가 일치하는 건 사실상 같은 클래스지만 차이가 있다.쓰레드 안정성. 이전에 나온 Buffer는 멀티 스레드 환경에서의 안정성을 갖췄지만Builder는 속도를 우선시하여 싱글 스레드를 위해 새로이 탄생했다.콘솔은 컴퓨터를 대상으로 데이터를 입력 및 출력하는 장치를 총칭.syso에서 참조 변수의 주솟값을 출력해줬던 것도 매개 값의 인스턴스를 대상으로toString 메소드를 호출하여 문자열로 반환된 주소를 출력해주는 것.printf (와 format은 완전 동일한 메소드다?)d 10진수 정수o 8진수 정수x 16진수 정수f 실수 e e표기법 기반의 실수g 출력의 대상에 따라 %e 또는 %fs 문자열c 문자Scanner(자바5)생성자로 전달되는 대상으로부터 데이터를 추출하는 기능을 제공한다.생성자 매개 변수로는 FileSource, StringSource, InputStreamSource 등이 있다배열의 fill 메소드는 배열과 특정 인자를 받아 전달된 값으로 한번에 초기화할 수 있다.enhanced-for = for-each = 향상된 for문상속: 연관된 일련의 클래스들에 대해 공통적인 규약을 정의할 수 있다.상속은 코드 재활용을 위한 문법이 아니다.하위 클래스의 인스턴스 생성시 상위 클래스의 생성자까지 호출되며 상위 클래스 생성자가 먼저 호출된다.?정적 멤버는 상속되지 않는다. 하지만 하위 클래스에서 상위 클래스의 정적 멤버를 선언 없이 다룰 수 있다.?다 상속되어 하위 클래스와 인스턴스로 상위 클래스의 정적 멤버를 사용할 수 있다. (버전에 따른 차이인지 확인해야함)상속 관계에서 필드 선언을 할 땐 동일한 변수를 사용하지 않도록 주의한다.main 메소드에서 타입 변환을 하며 각각의 객체에 동일한 이름을 가진 필드에 접근할 때 혼란을 준다.정적 멤버도 현재의 타입에 알맞는 멤버에만 접근하므로 오버라이딩의 대상이 아니라고 볼 수 있다.메소드 오버라이딩을 통해서 상속 범위를 넓힐 수 있다. (제한할 수는 없음)클래스의 필드를 조회할 필요가 있다면 contains, equals, hashcode 등의 메소드를 오버라이딩하는 경우가 많다.toString 메소드의 경우 자바 공식 문서에서도 오버라이딩하는 것을 권장한다.추상 클래스와 일반적인 Super 클래스는 비슷하지만 생성자를 통한 객체 생성의 여부가 다르다.추상 클래스는 하나의 규격이라 보면 되고 추상적인 것으로 치면 인터페이스가 정점이다.실체 클래스가 공통적으로 가져야할 필드와 메소드들을 정의해놓았으며 멤버를 통일하는 데 목적이 있다.어노테이션: 자바 컴파일러에게 메시지를 전달하는 목적의 메모인터페이스의 디폴트 메소드(자바8) (인터페이스의 이름은 형용사로 지어주자)이미 많은 인터페이스와 구현 클래스들이 존재할때 새로운 인터페이스를 생성해 구조를 수정하기는 힘들다.개발진들도 람다를 추가하기위해 인터페이스 내부에 추상메서드가 아닌 디폴트메서드 기능을 함께 도입했다.디폴트 메서드는 오버라이딩을 하지 않아도 되는 완전한 형태이다.또한 정적 메소드(자바8)도 도입했다. 인터페이스만으로도 메소드 사용이 가능해진 것이다.인터페이스 참조 변수에 타입변환하여 구현 객체를 삽입하지 않더라도구현 클래스를 통해 나온 객체는 (A insanceof B) 를 따졌을 때 참으로 나타난다.자바에서는 하드웨어의 오동작으로 발생한 건 에러이외의 프로그램 자체 오류는 예외라고 부른다자바7부터 catch문에서 (AException | BException e) 이런식으로 두 개의 예외를 받을 수 있다.Exception 클래스를 상속하는 예외 중 RuntimeExceptio을 제외한 예외에 대해서는 예외 처리가 필수적이다.메인 메소드로 예외를 넘기면, 이 예외는 메인을 호출한 가상머신에게 넘어간다. = 프로그램 종료직접 Exception을 상속하여 프로그래머가 Exception을 정의할 수도 있다.종료가 반드시 필요할 경우 try(resource, resource2) 처럼 내부에 그 문장을 try문이 종료될 때 리소스도 함께 종료된다.과도한 예외처리는 성능 저하로 이어진다.자바에서의 API자바 시스템을 제어하기 위해 자바에서 제공하는 명령어들을 의미한다.SE(JDK)를 설치하면 자바 시스템을 제어하기 위한 API를 제공한다.패키지 내의 클래스들도 자바에서 제공하는 API 중의 하나라고 할 수 있다.자바 가상머신의 메모리 모델프로그램의 실행에 필요한 메모리 공간을 가리켜 메인 메모리라 하며, 이는 물리적으로 램을 의미한다.메모리의 효율적인 사용을 위해서 운영체제가 메모리를 관리한다. JVM은 운영체제에서 메모리를 할당 받고 효율적으로 사용한다.JVM의 메모리 공간은 크게 메소드, 스택, 힙 영역으로 나뉜다.메소드 영역: 메소드의 바이트코드(class 확장자), 정적 변수스택 영역: 지역 변수, 매개 변수 CPU가 직접 메모리에 접근하고 관리해서 메모리 누수 문제가 없다.힙 영역: 인스턴스 메모리 크기의 제한이 없으며, Stack에 비해 느리다. 메모리 관리를 직접하며 GC의 활동 영역이다.지역 변수: 중괄호로 구분되는 지역 내에서만 유효한 변수스택 영역 - 중괄호 내에 할당된 이후에 해당 중괄호를 벗어나면 바로 소멸되는 특성의 데이터 저장을 위한 영역인스턴스를 스택 영역이 아닌 힙 영역으로 분리해 보관하는 건 지역 변수와의 생성 소멸 패턴이 달라서이다.스택 영역에 보관되는 참조 변수에 힙 영역의 인스턴스의 주소를 저장하여 교류하는데인스턴스의 소멸은 JVM에서 직접 결정하므로 인스턴스와 연결된 참조 변수에 null을 대입함으로써 소멸 판단에 도움을 줄 수 있다.해당 인스턴스의 주소를 참조하는 변수가 없기 때문이다. 다르게 말하면 해당 인스턴스에 더이상 접근 할 수도 없다.Object 클래스의 equals 메소드는 내용 비교가 이뤄지도록 오버라이딩 하라고 존재하는 메소드이다.clone 메소드를 직접 작성한 클래스에 정의하고 싶다면 Cloneable(마커) 인터페이스를 상속해야 한다.이 메소드는 인스턴스의 복사본을 만들어 참조 값을 반환한다. (얕은 복사)깊은 복사를 위해선 clone 메소드를 오버라이딩하고 인스턴스 내부의 참조 변수에까지 clone 메소드를 사용해준다.이때 String 클래스는 Cloneable 인터페이스를 구현하지 않기 때문에 new 연산자를 이용한다.String은 문자열의 수정이 불가능하므로, 깊은 복사의 대상에서 제외해도 된다. 당연한 말이다.clone 오버라이딩: 메소드 내부에 인스턴스 복사본 생성 -&gt; 필드 복사 -&gt; 인스턴스 반환자바5부터 오버라이딩 과정에서 반환형의 수정을 허용한다. 단 클래스 이름과 관련한 조건이 있다.Wrapper 클래스도 toString이 오버라이딩 되어있기에 출력시 주소가 아닌 값이 나온다.박싱된 객체를 언박싱 (Object).(primitive type)value인자를 해당 자료형으로 변환 (wrapper class).valueOf(Object)자바5부터 자동 박싱, 언박싱이 지원된다.모든 Wrapper 클래스는 Number 클래스를 상속한다.BigInteger: long 범위를 벗어난 정수를 표현BigDecimal: double 범위를 벗어난 실수를 표현인스턴스를 생성할 때 인자를 문자열로 받고 연산을 위한 메소드가 존재함.Random 클래스의 인스턴스를 생성할 때 씨드 값을 주지 않으면인자를 currentTimeMills() 으로 갖는 생성자를 다시 호출한다.StringTokenizer: 특정 기준을 가지고 문자열을 작게 나누어야 할 때 사용토큰: 구분자를 기준으로 나뉜 문자열 조각이 클래스는 생성할 때 추출할 문자열과 구분자에 대한 정보를 인자로 받는다.다수의 구분자가 있을 땐 공백없이 문자열 하나로 작성하여 인자로 준다.hasMoreTokens, nextToken 메소드와 while문을 활용하여 토큰을 받는다.구분자도 토큰으로 받고 싶다면 생성자의 인자를 그대로 주되 true 값을 마지막에 추가로 준다.Arrays 클래스Arrays.copyOf: 배열을 복사하여 새로 생성할 때System.arraycopy: 존재하는 배열에 복사를 하려는 경우Arrays.equals: 배열의 내용 비교 하지만 인스턴스 배열이 전달된다면 참조 값이 비교되기 때문에 해당 인스턴스의 클래스에서 오버라이딩 필요Arrays.sort인스턴스가 저장된 배열은 주소값만이 존재할 것이다.이러한 배열에서 sort 메소드를 호출하면 인스턴스들의 순서를 compareTo 메소드를 이용해 결정한다.compareTo는 인스턴스가 속한 클래스 내부에 오버라이딩하여 기준을 정한 뒤 3가지 값을 반환하면 된다.“ 양의 정수, 음의 정수, 0 “ 이 반환 값을 이용하여 sort 메소드가 순서를 결정해준다.if else로 처리할 수도 있지만 양의 정수, 음의 정수처럼 값이 고정된 것이 아니므로return에 this.age - p.age; 처럼 연산을 바로 작성해도 된다.매개변수는 Object형으로 받으므로 명시적 타입 변환이 필요하다.?제네릭이 도입되면서 Comparable 인터페이스가 제네릭 타입으로 지정되었다. 둘의 차이를 알아야 한다.제네릭(자바5)제네릭 타입이 없다면 Object 객체를 생성하여 이용할 수 있다.이땐 명시적 형 변환이 필요한 상황이 반드시 나타난다. 하지만 반드시 실수하는 경우가 생길 것이다. (RuntimeException)제네릭이 등장하면서 자료형에 의존적이지 않은 클래스를 정의할 수 있게 되었다.인스턴스 생성 시 타입 인자를 통해 자료형을 결정하는 것이 제네릭이다.보편적으로 자주 사용하는 타입 매개변수E(elements), K(key), N(number), T(type), V(value)매개변수화 타입도 타입 인자로 줄 수 있다. (다중 박싱)타입 인자를 제한했을 때 클래스 내부에서 동일한 타입 매개변수로 선언된 필드에 제한의 기준이 되는 클래스의 메소드를 사용하여 접근할 수 있다.하나의 클래스와 하나 이상의 인터페이스에 대해 동시에 제한할 수 있다.정적 메소드의 제네릭은 직접 선언해줘야 한다. (compile err)제네릭 메소드 = 제네릭 정적 메소드제네릭 클래스는 인스턴스 생성 시 자료형이 결정되는 반면제네릭 메소드는 메소드 호출시에 자료형이 결정된다.제네릭 메소드를 이용할 때 컴파일러는 전달되는 인자를 보고타입을 유추할 수 있다. 이러한 자료형의 유추는 오토 박싱까지 감안하여 이뤄진다.제네릭 메소드도 타입 인자의 제한과 메소드 활용이 똑같이 이루어진다.자바7부터 컴파일러의 자료형 유추 범위가 넓어져서 제네릭 메소드의 인자가 없더라도메소드 부분의 제네릭 선언은 생략할 수 있다.제네릭 - 와일드카드제네릭 선언된 정적 메소드의 기본형과선언 없이 인자에 &lt;?&gt;(와일드카드)를 작성하는 것은 상호 대체 가능한 동일한 메소드이다.Box를 매개변수로 작성하면 Box도 받을 수 있지 않을까? 싶지만Object와 Integer가 상속 관계라 할 지 언정 Box와 Box는 상속 관계가 아니다.Box&lt;? extends Number&gt; = Number 클래스와 그를 상속한 클래스만 가능한 와일드 카드의 선언extends: 상한 제한, super: 하한 제한매개변수화 타입에서 (Box box) T의 범위를 제한한다.제한이 없을 때의 안정성을 생각해보면 와일드카드는 어렵지만 절대 필요없지 않다.\"필요한 만큼만 기능을 허용하여, 코드의 오류가 컴파일 과정에서 최대한 발견되도록 한다.\"제네릭 메소드의 매개변수화 타입에 와일드 카드의 상한 제한을 선언하면 매개변수화 타입을 참조하는 변수를 대상으로 저장하는 기능(setter)의 메소드 호출은 불가능하다.Box&lt;? extend Toy&gt; 의 경우 Toy 클래스를 상속하는 다른 클래스의 인스턴스가 형 변환 되어 저장되었을 수도 있다. 그러므로 자바에서는 사전에 setter 메소드를 막아버렸다.컴파일 에러는 자바에서 막아버리는 것반대의 겨우인 하한 제한에서는 getter 후 특정 클래스 타입의 참조 변수에 대입하는 것을 막는다.따라서 와일드 카드에서의 타입 제한은 box가 참조하는 인스턴스를 대상으로 꺼내거나 저장하는 기능의 메소드 호출을 불가능하게 만든다.public static void outBox(Box&lt;? extend Toy&gt; box) {};public static void outBox(Box&lt;? extend Robot&gt; box) {};제네릭 메소드의 정의로 Type Erasure를 피해간다.제네릭 클래스를 상속할 때 슈퍼 클래스의 타입 인자에 대한 지정을 서브 클래스에서 해줘야한다.하지만 extends Class&lt;String&gt; 과 같이 상속과 동시에 지정해주면서브 클래스를 제네릭으로 정의할 필요 없다.인터페이스를 상속할 때도 모든 게 동일하게 적용된다.컬렉션 프레임워크자료구조는 데이터의 저장 관련 학문으로 데이터의 탐색, 삭제 등 다양한 측면을 고려한 데이터의효율적인 저장 방법을 연구하는 학문이다.자료구조에서 정형화하고 있는 데이터의 저장 방식 중 대표적인 몇가지를 정리하면리스트, 스택, 큐, 트리, 해쉬 등이 있다.위 자료구조들을 대상으로 하는 비교적 간단한 알고리즘 몇 가지를 보면버블 정렬, 퀵 정렬, 이진 탐색 등이 있다.컬렉션 클래스들을 기반으로 생성되는 컬렉션 인스턴스들은 인스턴스의 저장을 목적으로 한다.컬렉션 관련 클래스들과 인터페이스들은 대부분 java.util 패키지로 묶여있다.List&lt;String&gt; list = Arrays.asList(\"toy\",\"box\");문자열이 두 개 있는 배열을 list에 담고// public ArrayList(Collection&lt;? extends E&gt; c&gt;)// List는 Collection 인터페이스를 상속하고 타입 제한으로 컬렉션 인스턴스에서는 참조만 가능하다.list = new ArrayList&lt;&gt;(list);생성된 인스턴스에 그대로 복사한다.hashcode와 equals를 오버라이딩하여 Set 인터페이스 중복 판단에 도움이될 수 있다.필드 값이 완전히 동일한 인스턴스라도 본래의 메소드는 주소값을 판별하기 떄문이다.하지만 매번 두 메소드를 오버라이딩하는 것은 귀찮은 일이므로특별한 경우가 아니라면 Objects의 hash 메소드를 이용할 수 있다. (가변 인자로 선언되어 있음)public int hashCode(){ return Objects.hash(model, color);}인스턴스의 주소가 아닌 내부 필드를 인자에 넣어 비교한다.TreeSet은 Tree라는 자료구조를 기반으로 인스턴스를 저장한다. (Red-Black Tree)인스턴스들의 참조 순서는 오름차순으로 정렬된다.하지만 비교군이 명확하지 않을땐 Comparable 인터페이스의유일한 추상메소드인 int CompareTo 메소드의 구현을 통해서 그 기준을 정해주어야 한다.Tree 구조를 알아야 this가 누군지, 어떤 방식으로 정렬되는지 알 수 있다.Comparable을 오버라이딩하여 기준을 정했지만 일시적으로 기준을 변경하고 싶을 때가 있다.Comparator 인터페이스가 이를 해결해준다.사용방법은 Comparable과 비슷하지만 인자를 두 개 받는다.기존의 구조가public int compare(Person p1, Person p2){ return p1.age - p2.age; }라면반환값의 연산 순서를 바꿔주면 된다.이를 이용하기 위해선 TreeSet 인스턴스를 생성할 때 인자 값으로 구현 객체를 대입하면 된다.List의 컬렉션 프레임워크에서 중복된 인스턴스를 제거하고 싶다면Set - HashSet 인자에 대입 후 다시 List로 되돌리면 중복된 인스턴스를 제거할 수 있다.Stack동기화된 클래스로 쓰레드에 안전하지만 그만큼의 성능 저하도 발생함.자바 6에서 스택을 대신할 수 있는 Deque 자료구조가 포함됐음.양방향 구조이므로 Stack과 Queue를 대신할 수 있다.Deque&lt;E&gt; val = new ArrayDeque&lt;&gt;();LinkedList를 기반으로 덱을 구성할 수도 있다.LinkedList는 Deque, List 의 구현 클래스다.Mapkey는 실질적 데이터가 아니라 데이터 Value를 찾는 지표이다.HashMap 클래스는 Iterable 인터페이스를 구현하지 않으니 for-each문을 통해서혹은 반복자를 얻어서 순차적 접근을 진행할 수 없다. 대신 Map에는 Set keySet 메소드가 존재한다.key 묶음을 담아 Set 인터페이스를 구현하여 모든 Key에 대해 순차적으로 접근할 수 있다.Set은 Iterable 인터페이스를 상속하므로 가능한 방식이다.이를 이용하여 value를 출력하려면 HashMap 참조 변수에 get 메소드의 인자로 key 값을 전달하면 된다.TreeMap에서는 key 값을 기준으로 정렬한다.Collections.sort 를 사용하기 위해선 아래 메소드의 문장을 설명할 수 있어야 한다.public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list){};Comparable&lt;Car&gt; 인터페이스를 구현한 Car 클래스를 상속한 SubCar 클래스를 생각해보면List&lt;SubCar&gt;가 대입 됐을때&lt;SubCar extends Comparable&lt;SubCar(or Car or Object)&gt;&gt; void sort(List&lt;SubCar&gt; list){};로 변경되어 Super 클래스가 Comparable을 구현한 상태일 때 SubCar로도 이 메소드를 사용할 수 있다.?Comparator 인터페이스 구현 클래스는 꼭 따로 작성해줘야 되나?Tree는 자체적으로 정렬을 고려하며 인스턴스를 받는다. List의 경우엔 정렬 없이 순차적으로 저장한다.이진 탐색을 하려면 반드시 정렬해줘야하며, 혹 정상적인 결과를 얻는다 해도 우연의 일치일 뿐이다.열거열거형 값은 Enum.ABC 같이 표현하지만 case 문에서는 ABC 같이 열거형 값의 이름만 명시해도 된다.특정 클래스 내에서만 사용하고자 하는 열거형 값이 있다면, 해당 클래스 내에 정의하면 된다.열거형 값엔 private 생성자가 숨어있다. private으로 정의하여 인자를 받을 수도 있는데.인자 값을 전달하려면 enum 필드에 직접 인자를 작성해야된다. 구조가 특이하지만 쓸 일은 없어보인다.다른 참조 변수에 동일한 enum 필드의 주소값을 전달하면 두 참조 변수가 가르키는 주소는 같다.열거 타입은 카테고리가 명확할 때 버그를 줄이며 활용할 수 있어 유용하다.메소드의 가변 인자 선언.가변 인자 선언을 하면 전달되는 인자의 수에 제한을 두지 않을 수 있다.가변 인자는 컴파일러가 배열로 해석한다.터미널 컴파일 시 -Xlint(enable recommended warnings)을 함께 작성하면 경고를 확인할 수 있다.중첩 클래스에서 정적 네스티드 클래스나 이너 클래스에서 아우터 클래스의 필드가 private이어도 참조 가능.멤버 클래스는 클래스의 정의를 감추어야 할 때 유용하게 사용이 된다.컬렉션 프레임워크의 iterator 메소드도 Iterator 인터페이스를 구현한 중첩 클래스를 이용하는 것이다.일반적으로 아우터 클래스 외부에서 네스티드 또는 이너 클래스의 객체를 생성하는 일은 거의 없다.대부분 아우터 클래스 내부에 이들의 객체를 생성하여 사용한다.이너 클래스의 경우 클래스를 감싸는 게 메소드라면, 이 메소드 내에 객체를 생성하고 사용한다.주로 비동기 처리를 위해 스레드 객체를 만들 때 사용된다.중첩 인터페이스의 경우 주로 정적 네스티드 인터페이스로만 선언하여 UI 프로그래밍에서이벤트를 처리할 목적으로 많이 활용되며 네스티드로만 선언할 수 있다.익명 클래스의 가장 단순 형태는 new Printable() { 실체 메소드(){} }; 의 형태이다.인터페이스는 원래 자신이 구현 객체가 될 수 없지만 이러한 방식으로는 가능하다.왜 익명 클래스라 부르는가?new Printable() &lt;&lt;&lt;익명 클래스명&gt;&gt;&gt; { 실체 메소드(){} };이걸 활용해서 익명 Comparator를 실행문 내에 작성할 수 있다. (클래스 파일은 생성됨)자식 클래스 또는 구현 클래스가 재사용되지 않고 오로지 특정 위치에서 사용할 경우라면자식 클래스를 명시적으로 선언하는 것은 귀찮은 작업이므로 익명 클래스를 사용하자.? 익명 자식 객체에 대한 이해 필요람다(자바8)람다와 익명 클래스의 내부적인 동작 원리는 다르다.람다식은 단순히 생각하면 익명 클래스를 좀더 간결하게 표현한다고 말할 수도 있다.매개 변수, 실체 메소드, 반환값, 화살표가 필요하다.추상메소드가 딱 하나만 존재하는 인터페이스를 람다식으로 활용할 때이 인터페이스를 함수형 인터페이스라고 한다.네 가지 대표적인 함수형 인터페이스Predicate&lt;T&gt;, Supplier&lt;T&gt;, Consumer&lt;T&gt;, Function&lt;T, R&gt;?함수형 인터페이스를 사용할만 기능들을 미리 구현해둔 건가?메소드 참조(자바8)메소드 참조는 람다식으로 줄어든 코드의 양을 조금 더 줄일 수 있게 한다.‘::’ 연산자로 나타내며 클래스, 인스턴스로 참조할 수 있다.?메소드가 접근하는 인스턴스가 인자로 들어가는 원리..Optional 클래스(자바8)NPE 대응한 if 방어로직을 대신하여 코드를 축약할 수 있음.?자바 8에 관한 건 무조건 다시 봐야겠다.?축약되는 모든 것이 헷갈린다.Stream(자바8)배열 또는 컬렉션 프레임워크 형식의 데이터를 추상화하고 순차적으로 처리하는데 쓰인다.최종 연산과 관련된 메소드를 호출하지 않으면 filter메소드의 반환이 이루어지지 않는다.이를 지연 처리 방식이라고 한다.스트림의 대략적인 구조배열 및 컬렉션 인스턴스 대상으로 스트림 생성stream stream.of필터링 및 맵핑 관련 연산filter(Predicate) map(Functional) | peek리덕션 관련 연산sum forEach reduce | sum, count, average, min, max참고 - https://sejoung.github.io/2019/01/2019-01-31-java8_stream_tutorial_examples/#%EB%8B%A4%EB%A5%B8-%EC%A2%85%EB%A5%98%EC%9D%98-%EC%8A%A4%ED%8A%B8%EB%A6%BC멀티 코어 CPU가 대중화돼서 자바는 언어 차원에서 병렬 처리를 지원한다.ParallelStream 은 병렬 처리 방식으로 속도 측면에서 장점이 있다.병렬 처리는 연산의 횟수를 줄이는데 있지 않고 연산의 단계를 줄이는데 있다.4개의 데이터를 BinaryOperator를 통해 처리한다면 최초에 기준값과 4개의 데이터를 동시에 비교한다. 물론 CPU의 코어 개수가 그에 맞게 필요하다.stream.of 메소드를 통해 생성된 stream은 문자열을 동시에 3개 넣는다 하더라도배열에 저장된 요소로 이뤄진 하나의 인스턴스만 존재하게 된다.함수형 인터페이스부터 스트림까지 리터럴 타입을 넣어 자동 언박싱 연산이 적용되게 했는데최적화를 위해선 DoubleStream 같은 메소드를 사용해주는 게 좋다.스트림 인스턴스에 parallel 메소드를 사용하면 병렬 스트림으로의 변경도 가능하다.concat 메소드는 문자열 연결처럼 스트림을 연결하는 메소드이다.flatMap은 스트림을 생성하고 이를 반환한다반면 map은 전달할 람다식에서 스트림을 구성할 데이터만 반환하면 된다.루핑스트림을 이루는 모든 데이터 각각을 대상으로 특정 연산을 진행하는 행위대표적인 루핑 연산으로 forEach가 있고 중간 연산에도 루핑을 위한 메소드가 존재한다.예를 들어 Consumer 인터페이스를 인자로 받는 peek 메소드가 있다. 중간 연산이므로 지연 처리 방식이 적용되어 있다.forEach와 peek 둘 다 매개변수로 Consumer를 받기 때문에 거의 동일한 메소드이다.스트림 종료 여부에따라 사용하면 된다.최종 연산에는 sum, count, average, min, max 등이 있는데average , min , max 는 Optional형 인스턴스를 반환하기 때문에 Optional 클래스의 메소드를 사용하여 다음 연산을 진행한다.스트림은 최종 연산을 하는 순간 파이프라인의 마지막을 통과해버린다.이미 흘러가버린 스트림을 대상으로는 그 어떤 연산도 추가로 진행할 수 없다.이러한 스트림의 특성 때문에 실제 코드에서 스트림형 참조변수를 선언할 일은 거의 없다.(all,any,none)Match 최종 연산의 sorted..collect(() -&gt; new ArrayList&lt;&gt;(),\t(c,s) -&gt; c.add(s),\t(lst1,lst2) -&gt; lst1.addAll(lst2));첫 번째 연산은 새로운 데이터 저장소 생성두 번째 연산의 첫 번째 매개변수는 생성된 데이터 저장소 (컬렉션 인스턴스)두 번째 매개변수는 스트림을 이루는 데이터순차 스트림의 경우 세 번째 연산이 의미가 없지만 그렇다고 해서 null을 전달하면 NPE 발생병렬 스트림의 경우 여기서 addAll은 ArrayList의 인스턴스 메소드로써메소드의 호출 결과로 lst2가 저장하고 있는 모든 데이터가 lst1에 담기게 된다.병렬 처리가 능사는 아니다. 병렬 처리를 했을 때 오히려 속도가 느려지는 경우도 의외로 많다.병렬 처리를 결정했을 때는 테스트를 통해서 병렬 처리의 적합성을 판단해야 한다.시각과 날짜 관련 코드의 작성java.util.Date(자바0) 구식 SimpleDateFormat 클래스로 형식 변환 java.util.Calendar(자바1) 구식/* (자바8) + DateTimeFormatter(Instant는 포맷 적용이 까다롭다)java.time.Instant 1970 - 01 - 01 00:00:00 부터 현재까지 흐르는 시간 중 특정 지점을 인스턴스로 생성 (UTC 기준 시간)java.time.Duration 소요 시간을 계산하는 데 이용java.time.LocalDate 시각 정보가 생략된 날짜 정보를 표현java.time.LocalTime 시각 정보를 표현java.time.period 날짜 기간을 계산하는 데 이용java.time.LocalDateTime java.time.ZoneId 협정 세계시에 따른 시각 계산을 위해 지역 지정java.time.ZonedDateTime 지역에 따른 시각을 표현할 수 있음 */LocalDateTime에서 날짜의 차이와 시각의 차이를 각각 구하기 위해선toLocalDate, toLocalTime 메소드를 이용하면 된다.단순히 Duration만 한다면 날짜계산까지 시각의 관점에서 나타낼 수 있다.날짜 시각 관련 인스턴스들은 메소드로 그 인스턴스를 수정하는 게 아니라수정한 정보를 토대로 새로운 인스턴스를 반환한다.한국의 시간대는 UTC+9이다. 협정 세계시보다 9시간이 빠름을 의미한다.Local 또는 Zone의 기본 값은 사용자 컴퓨터에 맞춰져있다.참고 - https://jaimemin.tistory.com/1537I/O 스트림(I/O 스트림은 java.io 소속 / 배열 스트림은 java.util.stream 소속배열, 컬렉션 인스턴스의 데이터를 목적에 맞게 가공하는 앞의 스트림과는 달리데이터를 꺼내는 방법에 대한 것까지도, 어떻게 데이터를 입력하고 출력할 것인가에 대한 내용이다.입출력 대상은 파일, 키보드, 모니터, 그래픽카드, 프린터, 연결된 서버 또는 클라이언트 등 다양하다.입출력 대상이 달라지면 코드상에서의 입출력 방법도 달라지는것이 일반적인데자바에서는 입출력 대상에 상관없이 동일한 방법으로 입출력을 진행할 수 있도록I/O 스트림 모델 이라는 것을 정의하였다.스트림이란 ‘데이터의 흐름’을 의미한다. 이를 ‘데이터의 이동 통로’로 의역하면 표현이 부드러워진다.close 메소드로 생성했던 스트림을 소멸시키면 열려 있던 파일은 닫히고 할당되었던메모리 자원은 다시 사용할 수 있도록 반환된다.try-with-resources문을 이용하면 안정적이고 간결한 코드를 작성할 수 있다.try(InputStream in = new FileInputStream(\"data.dat\") ; . . .){ . . . } catch (IOException e) { . . . }예외 발생시 resource 영역의 스트림의 종료가 보장된다.기본적인 데이터의 입출력 단위는 바이트이다.read 메소드는 1바이트의 유효한 데이터에 3바이트의 0을 채워서4바이트 int형 데이터로 반환한다. 그래서 이 메소드가 반환하는 정상적인 값의 범위는 0~255이다.역으로 write 메소드는 int형 데이터의 첫 번째 바이트만을 파일에 저장한다.이와 같이 파일의 크기에 상관없이 1바이트씩 읽거나 쓰면 크기가 어느정도 되는 파일을복사할 경우 제법 오랜 시간이 걸린다.바이트 스트림이라 하여 1바이트씩만 읽고 써야 하는 것은 아니다.byte 배열을 생성해서 이를 기반으로 많은 양의 데이터를 한 번에 읽고 쓰는 것도 가능하다.read 의 인자로 바이트 배열을 전달하고 메소드는 배열의 길이를 반환한다.write 의 인자로 배열, 시작 인덱스, 길이를 전달하면 값에 맞게 데이터를 이동시킨다.read 는 읽어 들인 바이트의 수를 반환하는데, 스트림의 끝에 도달해서 더 이상 읽어 들일 데이터가 없는 경우 -1을 반환한다.이는 배열의 길이가 초과된 게 아니라 읽어들이는 데이터에 모두 접근했다는 말이다.출력 스트림에서 파일이 존재하지 않다면 경로에 따른 디렉토리가 존재하는 경우 파일을 자동 생성한다.createNewFile 메소드는 필요가 없다.만약 1바이트의 데이터 4개를 모아 int형 데이터를 얻고 싶다면?읽어 들인 1바이트 데이터 4개를 하나의 int형 데이터로 조합하는 과정이 필요하다.필터 스트림을 통해 읽어 들이는 데이터는 합쳐지고 전달하는 데이터는 분해된다.장치를 튜닝한 것과 비슷한 느낌으로, 바이트 단위 스트림을 필터 스트림의 인자로 전달하면 된다.(DataFilter(I/O)Stream) instance::write(read)Int(Double) MethodBuffered(I/O)Stream필터 스트림 중에서 상대적으료 사용 빈도수가 높다. 입출력에 버퍼링 기능을 제공한다.버퍼 : 동작 속도가 크게 다른 두 장치 사이에 접속되어 속도 차를 조정하기 위하여 이용되는 일시적인 저장 장치. 저속의 단말기와 고속의 중앙 처리 장치 사이에 설치된다.즉 버퍼 스트림은 내부에 버퍼(메모리 공간)을 갖는다.입력 스트림을 기준으로 이야기해보자면입력 스트림을 통해 많은 양의 데이터를 가져다 해당 버퍼를 채운다.read 메소드를 호출하면 버퍼에 저장된 데이터를 반환한다. 이것이 성능 향상의 핵심인데, 파일 복사에서메소드 호출의 빈도수보다 더 문제가 되는 것은파일에 빈번히 접근하는 행위이다.파일은 물리적으로 떨어져 있다.파일에서 1바이트를 읽는 것은 메인 메모리에서 1바이트를 읽는 것보다 훨씬 오랜 시간이 걸린다.따라서 파일에서 데이터를 읽어 들일 때는 한 번에 많은 양을 읽어 들여야 파일 접근에 따른 성능의 저하를 최소화할 수 있다.버피의 디폴트 용량은 8192개의 문자를 저장할 수 있는 수준이고readLine을 통해 한 줄씩 읽는다면 아무런 문제 없이 사용할 수 있다.char 자료형은 2바이트로 유니코드를 표현한다.UTF-8은 UTF-16이 7bit로 표현가능한 아스키코드 문자를 16bit로 표현하자,메모리 낭비를 막기 위해 탄생한 인코딩 방식이다.UTF-8은 16bit 유니코드 문자를 지원함에도 아스키 코드 문자들을 7bit로 표현 가능하다.한글은 유니코드에 속하므로 1바이트로 표현할 수 없다.7bit 만으로 아스키코드의 문자를 표현하다보니 유니코드 문자가 들어오면문자를 인식하는 과정에서 오류가 발생할 수 있다.UTF-8은 이러한 오류를 피하고자 헤더가 추가되어 3바이트를 차지하게 되었다.아스키 코드가 주로 사용되는 환경에서는 UTF-8이 유리하지만다양한 문자가 사용되는 공간이라면 메모리 효율과 임의 접근 효율에서 떨어진다.그러므로 JVM은 문자나 문자열을 메모리에 저장할 때 UTF-16 인코딩 방식을 사용하여 저장한다.(JVM 외부와 데이터를 주고 받을때 영어 말고도 다양한 언어를 접하므로 합리적인 방법이다)그러면 txt파일의 한글로된 문자는 언제 3바이트로 변하게 되는 걸까?JVM이 txt 파일에 접근하고 문자를 가져온 뒤 UTF-16(2byte) 인코딩을 끝내고이클립스 설정이 charset이 UTF-8로 되어있다면 아스키코드를 제외한 문자는 헤더까지 부착되어 3바이트 상태로 스트림 최종 연산에 순차적으로 나타난다.즉 JVM 내부에서 파일에 접근할 때, 해당 파일의 문자셋이 UTF-8로 되어있다면일반적으로 아스키코드를 제외한 유니코드는 UTF-16 -&gt; UTF-8 로 전환될 때아래의 이진수 x 자리에 순차적으로 입력된다.1110 xxxx, 10xx xxxx, 10xx xxxx버퍼링 기능에 대한 대책버퍼링은 성능 향상에 도움을 주지만 저장된 데이터가 파일에 저장되지 않은 상태에서컴퓨터가 다운 된다면 실제 파일로 데이터를 보낼 수 없는 상황이 발생할 수 있다.flush 메소드 호출을 통해 명시적으로 버퍼를 비우라고 명령할 수 있다.이 메소드를 번번히 호출하는 것은 또 바람직하지 않다.스트림이 종료되면 버퍼는 자동으로 비워지기 때문에 상황에 맞게 사용해야 한다.버퍼링 기능과 기본 자료형 데이터 저장을 동시에 사용하려면Data(I/O)Stream의 인자로 Buffered(I/O)Stream 인스턴스를 전달하면 된다.Data 스트림은 내부에서 바이트 형태로 변환하고Buffered 스트림은 1바이트를 모아서 보내기 때문이다.문자 I/O 스트림은 파일에 저장된 데이터를 입출력할 때 자바의 문자 표현 방식과상대측 문자 표현 방식을 비교해서 문자의 인코딩을 변경하는 스트림이다.Q. 문자만 저장되어 있는 파일을 복사하려고 한다. 이때 필요한 스트림은?문자 스트림을 통해서도 복사를 진행할 수 있다. 그러나 기본적으로 파일 복사는파일의 내용에 상관없이 있는 그대로의 바이트 정보가 저장된 파일을 하나 더 만드는 일이다.따라서 바이트 스트림을 생성해서 복사를 진행하는 것이 원칙이다.Q. 자바 프로그램에서 문자 하나를 파일에 저장했다가 다시 읽어 들이려 한다. 이때 필요한 스트림은?이 경우 파일에 문자를 저장하는 주체도, 저장된 문자를 읽는 주체도 자바 프로그램이다.따라서 문자를 유니코드로 저장하고 읽어 들이면 충분하므로 바이트 스트림을 생성하는 것이 옳다.물론 문자 스트림을 생성해서 이 일을 처리할 수도 있다. 그러나 그 과정에서 불필요하게문자의 인코딩을 변경하는 일만 생기게 된다.Q. 운영체제상에서 만든 텍스트 파일의 내용을 자바 프로그램에서 읽어서 출력할때 필요한 스트림은?메모장과 같은 텍스트 파일에 저장된 문자들은 해당 운영체제의 기본 문자 인코딩 방식을 따른다.운영체제상에서 만든 텍스트 파일은 메모장과 같은 프로그램을 실행해서 원하는 내용을담은 파일을 의미한다. 이렇게 만들어진 파일에 저장된 문자들은 해당 운영체제의기본 문자 인코딩 방식을 따른다. 메모장의 인코딩 방식은 UTF-8이다.교재의 내용과 달리 요즘은 UTF-8 인코딩 방식으로 통일되어있다. 질문에 스스로 답하는 시간을 갖자.문자 기반 스트림에는 BufferedReader(Writer) 가 있다. 문자열을 한 번에 쓰고 일는 일은 버퍼를 필요로 한다.newLine 메소드는 줄바꿈 기능을 한다.버퍼 리더는 readLine 메소드로 한 문장씩 읽어 들일 수 있다.IO 스트림 기반의 인스턴스 저장바이트 스트림을 통해서 인스턴스를 통째로 저장하고 꺼내는 것도 가능하다.이렇듯 인스턴스를 통째로 저장하는 것을 가리켜 객체 직렬화라 하고 (Object Serialization)역으로 저장된 인스턴스를 꺼내는 것을 객체 역 직렬화라고 한다. (Object Deserialization)Object(I/O)Stream은 필터 스트림과 유사하지만 기존에 알던 필터스트림은Filter(I/O)Stream 을 상속하지만 Object Stream은 저들을 상속하지 않는다.입출력의 대상이 되는 인스턴스의 클래스는 java.io.Serializable을 구현해야한다. (마커 인터페이스)출력의 대상은 Object.bin 파일에 함께 보관된다.writeObject 메소드로 저장하고, readObject와 명시적 타입 변환으로 인스턴스를 복원한다.인스턴스를 저장하면 인스턴스 변수가 참조하는 인스턴스까지 함께 저장이 된다.하지만 이 과정이 진행되려면 참조하는 인스턴스의 클래스도 마커 인터페이스가 적용되어야 한다.만약 참조 변수가 참조하는 인스턴스의 저장을 원치 않는다면 transient 선언을 추가하면 된다.이는 인스턴스가 아닌 기본 자료형 변수에도 해당 된다.꺼내올 때 참조 변수들을 null로 하고자한다면 사용하자.Java는 String 을 처리할 때 내부(메모리 상에서)에서는 UTF-16 BE 인코딩으로 문자열을 저장하고, 송수신에서는 직렬화가 필요한 경우 변형된 UTF-8 (modified UTF-8) 을 사용하며 문자열을 입/출력할 때에만 사용자가 지정한 인코딩 값 또는 운영체제의 기본 인코딩 값으로 문자열을 인코딩한다.인코딩에 대한 자세한 내용 https://st-lab.tistory.com/41nio 패키지는 new io 라 말할 수 있으며 기존 io 패키지의 보강을 위해자바 4에서 NIO API가 java.nio 패키지로, 자바7에서 NIO.2 API는 java.nio.file 패키지로 추가되었다.java.nio.file.path는 기존 File 클래스의 결함 대체를 위해 정의된 인터페이스이다.Path는 File이 하는 간단한 일들을 대체할 수 있다. (아예 대체가능한 지는 모름)Path a = Path.get(URI); 로 경로에 관한 인스턴스를 만들고Files 클래스의 정적 메소드, StandardOpenOption Enum을 활용하여디렉토리, 파일 생성 및 제거, 바이트 단위의 read, write이 스트림 생성 없이 가능하다.문자열 단위 송수신도 가능하다. readAllLines 와 write(path, collection, …)가 있다.쓰레드 하나에 CPU의 코어 하나가 할당된다.Runnable 인터페이스에 람다식으로 작성하고 쓰레드 인스턴스에 인자를 넣어 사용동기화가 필요한 메소드 내의 실행문만 따로 동기화 처리 하려면 synchronized(this){ . . . } 블록으로 감싸준다.쓰레드의 생성과 소멸은 그 자체로 시스템에 부담을 주는 일이다.이러한 성능 저하를 피하기 위해 미리 제한된 수의 쓰레드를 생성해두고이를 재활용하는, 쓰레드 풀을 구성하여 사용한다.ExecutorService exr = Executors.newSingleThreadExecutor();ExecutorService 인터페이스에 Executors의 쓰레드풀을 이용한다.submit 메소드와 shutdown 메소드로 스레드 작업을 추가하고 종료할 수 있다.submit 인자로 Runnable 구현 객체를 넣으면 반환 값을 얻을 수 없지만Callable 구현 객체를 넣으면 반환 값을 얻을 수 있다.Callable은 반환값이 있는 함수형 인터페이스인데 쓰레드풀에서의 장치다.반환값을 저장할 때는 Future 인터페이스를 사용하여 Callable과 Future을 특수한 경우의 세트로 사용한다.shutdown 메소드는 쓰레드 풀에 전달된 작업이 마무리되면 풀을 폐쇄하라고 명령할 뿐 기다려주지 않는다.그래서 쓰레드 풀에 전달된 작업의 최종 결과를 확인하기 위해서 awaitTermination 메소드가 필요하다.쓰레드 풀 전달된 모든 작업이 완료되거나 인자로 정한 시간이 지난 경우 쓰레드 풀을 폐쇄한다.자바5에서는 ReentrantLock 클래스를 제공한다. 기존의 Synchronized를 대신할 수 있다.객체를 생성하고 동기화가 필요한 메소드내에 lock 메소드, try-finally 블록, unlock 메소드를 장석해주면 된다.컬렉션 프레임워크의 Vector 클래스는 기본적으로 동기화가 되어있다.따라서 동기화가 불필요한 상황에서 사용하면 아무런 의미 없이 성능만 저하 된다.그래서 이를 대신하기 위해 자바2에서는 동기화 처리가 되어 있지 않은 ArrayList와 LinkedList를 추가하였다.운영체제에서는 실행중인 하나의 애플리케이션을 프로세스라고 부른다.사용자가 애플리케이션을 실행하면 운영체제로부터 실행에 필요한 메모리를 할당받아애플리케이션의 코드를 실행하는데 이것이 프로세스이다.하나의 애플리케이션은 멀티 프로세스를 만들기도 한다.예를 들어 메모장 애플리케이션을 2개 실행했다면 2개의 메모장 프로세스가 생성된 것이다.운영체제는 두 가지 이상의 작업을 동시에 처리하는 멀티태스킹을 할 수 있도록CPU 및 메모리 자원을 프로세스마다 적절히 할당해주고, 병렬로 실행시킨다.예를 들어, 워드로 문서 작업을 하면서 동시에 카톡도 할 수 있다.멀티 태스킹은 꼭 멀티 프로세스를 뜻하는 것은 아니다.한 프로세스 내에서 멀티 태스킹을 할 수 있도록 만들어진 애플리케이션도 있다.대표적인 것이 미디어 플레이어와 메신저이다.미디어 플레이어의 경우 동영상 재생과 음악 재생이라는 두 가지 작업을 동시에 처리한다.멀티 프로세스는 자신의 메모리를 가지고 실행하므로 서로 독립적이지만,멀티 스레드는 하나의 프로세스 내부에 생성되므로 스레드 하나가 예외를 발생시키면다른 스레드도 영향을 받는다.어떻게 하나의 프로세스가 두 가지 이상의 작업을 처리할까? –&gt; 멀티 스레드.멀티 스레도로 동작하는 메신저의 경우 파일을 전송하는 스레드에서예외가 발생하면 메신저 프로세스 자체가 종료되므로채팅 스레드도 같이 종료된다.그렇기 때문에 멀티 스레드에서는 예외 처리에 만전을 기해야 한다.자바의 모든 애플리케이션은 메인 스레드가 메인 메소드를 실행하면서 시작한다.이때 메인 스레드는 필요에 따라 작업 스레드들을 만들어서 병렬로 코드를 실행할 수 있다.즉 멀티 스레드를 생성해서 멀티 태스킹을 수행한다.멀티 스레드 애플레키에션에서는 실행중인 스레드가 하나라도 있다면,메인 스레드가 종료되더라도 프로세스가 종료되지 않는다.자바에서는 작업 스레드도 객체로 생성되기 떄문에 클래스가 필요하다.java.lang.Thread 클래스를 직접 객체화해서 생성해도 되지만,Thread 클래스를 상속해서 하위 클래스를 만들어 생성할 수도 있다.멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역을 임계 영역이라고 한다.자바는 임계 영역을 지정하기 위해 동기화 메소드를 제공한다. –&gt; synchronizedstop 메소드는 스레드를 비정상적으로 종료시켜 안에 있던 자원들이 불안정한 상태로 남게 된다.interrupted 메소드로 예외를 발생시켜 루프에서 빠져나오게 만들 수 있다.interrupted 메소드는 타겟 스레드가 미래에 일시 정지 상태가 됐을때 예외를 발생시킨다.예로, Thead.sleep() 혹은 공유 객체 동기화 메소드로 인한 일시 정지 상태.혹은 조건문을 이용하여 interrupted 메소드가 true를 리턴했는가. 를 확인하여 break를 걸 수도 있다.주 스레드의 작업을 돕는 보조적인 역할을 수행하는 데몬 스레드도 있다.예로, 워드프로세서의 자동 저장, 미디어 플레이어의 동영상 및 음악 재생,쓰레기 수집기 등이 있다. 주 스레드가 종료되면 함께 종료된다.컬렉션 프레임워크의 contain 메소드는 indexOf에 의한 boolean 값을 제공하고indexOf 내부는 오버라이딩되지 않은 equals의 동등 연산자에 의한 주소 비교가 정의되어 있다.API는 동작 원리에 대한 이해만 하고 비교군들을 정리하다 보면 자연스레 외워진다.메소드에서 반환값 없이 기존 참조 변수에 새로운 참조값을 할당할 수 없다.새로운 참조값을 return문에 작성하고 대입 연산자를 거쳐야 한다.객체의 해시 코드는 알고리즘과 데이터 구조가 객체를 구획에 넣을 수 있도록 한다.이 간단한 시스템을 사용하면 분류되지 않은 서랍에서 검색하는 것보다 훨씬 빠르게 유형을 찾을 수 있다.해시코드 계약. “동일한 객체는 실행 중인 프로세스 내에서 동일한 해시 코드를 가져야 합니다.”아래와 같은 일반적인 오해를 의미하진 않는다.“동일하지 않은 객체는 다른 해시 코드를 가져야 한다” &lt;= false“동일한 해시 코드를 가진 객체는 동일해야 한다” &lt;= false계약에서는 동일하지 않은 객체가 동일한 해시코드를 공유하는 것을 허용한다.이것은 가능한 구별 객체의 수가 일반적으로 가능한 해시코드의 수(4byte)보다 많기 때문에 명백하다.equals를 구현할 때마다 hashCode도 구현해야 한다.그렇게 하지 않으면 깨진 물건으로 끝날 것이다.equals 메소드를 재정의하여 일부 객체를 다른 객체와 동일하게 선언하지만원래 hashCode 메소드는 모든 객체를 다른 것으로 취급한다.따라서 해시코드가 다른 동일한 객체를 갖게 된다.두 개의 서로 다른 객체가 동일한 해시코드를 가질 때마다 이를 충돌이라고 한다.충돌은 중요하지 않으며, 단일 버킷에 둘 이상의 객체가 있음을 의미하므로 HashMap 조회는올바른 객체를 찾기 위해 다시 찾아야한다. 충돌은 시스템 성능을 저하시키지만 잘못된 결과로 이어지지 않는다.해시코드를 객체에 대한 고유 핸들로 착각하면, 예를 들어 이를 Map에서 Key로 사용하면 땔때로 잘못된 객체를 얻게 된다. 충돌은 드물지만 피할 수 없기 때문이다.(System 클래스의 해시코드 메소드를 사용하여 얻은 정수를 16진수로 표현한 게 Object 클래스의 메소드)parsing이 필요하고 짧은 입력 값이면 Scanner단순히 한 줄씩 읽거나 입력 값이 많다면 BufferReaderSystem.arraycopy(arr1, 0, arr2, 0, 3(arr1.length))arr1[0]부터 시작해서 순서대로 3개의 인덱스를arr2[0]에서부터 순서대로 삽입한다.클래스 내 생성자는 메소드와 비슷하게 생겼지만 엄연히 다르다.객체 생성시 초기화 역할을 담당하며 클래스 이름으로 되어있고 리턴 타입이 없다.필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다.refactor -&gt; export 실행문 간단히 method 화상수는 static final하지만 정적 필드로 정의하지 않았을 땐 생성자를 통해 값이 변경될 수 있으므로상수라 부를 수 없다.프로젝트가 다르면 외부 클래스를 호출할 수 없다.하려면 프로젝트를 외부 라이브러리 형태로 넣어줘야 한다.웬만하면 대부분 변수에 할당하는 게 좋다. 뭐가 뭔지 다른 사람도 알아야하니깐.매개 변수와 로컬 변수를 로컬 클래스 내부에서 사용할 때 매개 변수와 로컬 변수가 상수특성을 가지게 된다.“주로 정적 멤버 인터페이스를 많이 사용하는데 UI 프로그래밍에서 이벤트를 처리할 목적으로 많이 활용됩니다.”다행인 건 중첩 인터페이스는 클래스의 멤버로만 선언한다.배열의 길이가 길어질수록 향상된 for 문이 유리함정적 메소드는 재정의할 수 없다.Comparable과 Comparator의 차이.두 개 모두 인터페이스이므로 추상 메소드의 실체화가 필요하며,리터럴에 포함되지 않는 자료형인 객체를 비교할 수 있는 수단이다.Comparable : compareTo (T o) : 자신과 매개 변수 객체를 비교 : 익명 구현 객체 의미없음. : 구현 클래스 오버라이딩Comparator : compare(T o1, T o2) : 두 매개 변수 객체를 비교 : main문에 람다식 정의 가능Comparable은 lang 패키지에 존재하기에 import 해줄 필요가 없지만Comparator는 util 패키지에 존재한다.정렬을 구현해보면 알겠지만 Counting Sort 같은 특수한 경우를 제외하고 Insertion, Quick, Merge 등 다양한 정렬 알고리즘은 ‘두 데이터(요소)의 비교’를 통해 두 원소를 교환할지 말지를 정하게 된다.Comparable 은 구현 클래스에 직접 오버라이딩.Comparator 는 람다식을 이용한 익명 구현 객체 생성 후 정렬 메소드의 인자로 전달.이러한 특성으로 Comparator는 다중 생성 가능하지만 Comparable의 경우 단 하나의 방식 밖에 못 쓴다.flow를 주의하여 사용하자.필드는 필드 답게, 객체의 속성과 관련 없는 변수는 최대한 로컬로" }, { "title": "자바 - 1 - 자료형", "url": "/posts/java-copy/", "categories": "그 외, deprecated", "tags": "자바", "date": "2022-05-23 00:00:00 +0900", "snippet": "변수: 데이터의 저장과 참조를 위해 ‘할당된 메모리 공간’에 붙인 이름0001 의 음수는 1001이 아니다.1의보수화를 시킨 뒤 1을 더해줘야한다.1의 보수화는 0과 1을 교환하는 것이다.1111이 0001의 음수다. 올림 수는 버리므로 값은 0이다.자바는 정수형 연산을 4바이트 int형으로 진행한다.연산을 동반하는 상황에서는 변수를 byte, short로 선언해도 생각만큼 메모리가 절약되지 않고오히려 데이터의 변환 과정만 추가될 뿐이다.서로 다른 타입의 피연산자가 산술 연산식에 존재한다면, 더 큰 메모리를 할당하는 피연산자의타입이 연산식의 결과에 부여된다.(소수점) float은 6자리, double은 15자리의 정밀도를 갖는다.하나만 보면 그렇지만 실수를 연산한다면 소수점 이하 셋째 자리에서 오차가 발견될 수도 있다.실수의 계산은 기본적으로 오차가 존재한다고 가정해야 한다.비교 연산자에서 실수 비교는 자제한다.char: 하드웨어는 숫자밖에 인식할 수 없어 문자 하나하나에 숫자를 부여하는 수밖에 없다.“문자 A는 숫자 65로 표시하기로 약속한다.”이러한 ‘문자의 표현에 대한 약속’을 가리켜 ‘문자 셋’이라고 한다.유니코드는 모든 나라의 문자를 수용하여 전 세계적으로 사용하는 문자 셋이다.자바가 유니코드를 지원하더라도 문자의 출력은 운영체제에 의존적이다.출력하고자 하는 언어의 폰트가 운영체제에 설치되어 있어야 한다.String 변수를 선언할 때 문자열 대입과 new 연산자를 통한 인스턴스 생성 두 가지가 있다.new 연산자를 거치지 않은 문자열은 String Constant Pool에 저장된다.동일한 문자열이라면 ‘==’ 동등 연산자로 비교할 수 있다.new 연산자로 생성한 인스턴스는 문자열이 동일하더라도 독립된 heap 영역에 존재하므로.equals 메소드로 두 인자를 비교해야한다.new 연산자로 생성자는 그렇다면, 문자열이 갖는 불변성이란 장점을 누리지 못한다고 볼 수 있고메모리를 효율적으로 사용하기 위해 웬만하면 new 연산자를 거치지 않고 생성하는 것이 좋다.상수(final)는 값을 딱 한번만 할당할 수 있으며 이후 변경이 불가하다.상수의 이름은 모두 대문자로 짓는다.2진수 리터럴 표기 0B111 처럼 0B 삽입8진수 리터럴 표기 011 022 등 숫자 앞에 0 삽입16진수 리터럴 표기 0x11 처럼 0x 또는 0X 삽입long형 정수를 표현할 땐 리터럴에 L표기. 연산에도 마찬가지.제곱수는 3.4e3 =&gt; 3.4 x 10^3 처럼en을 10의 n승으로 대하면 된다.숫자 리터럴 사이의 언더바는 컴파일 과정에서 제거 된다.자동 형변환: 자료형의 크기가 큰 방향으로 형 변환이 일어난다. 자료형의 크기에 상관없이 정수 자료형보다 실수 자료형이 우선한다.정수형 데이터를 실수형으로 변환하면 오차는 존재하겠지만 데이터의 손실은 발생하지 않는다.복합 대입 연산자는 명시적 형변환을 줄여줄 수 있다. (별 필요없음)+, - 같은 단항 연산자로 인해서 디폴트 타입이 아닌 자료형에 명시적 형변환을 해줘야할 때가 있다.비트 연산은 byte 자료형의 연산에서 and, or, xor, ~ 등이 있다.모든 건 비트 단위로 연산한다.쉬프트 연산자int num = A « Z;위의 문장은 “A의 비트 열을 Z만큼 왼쪽으로 이동시켰을 때의 값을 변수 num에 저장”00000001 의 경우 왼쪽으로 밀 때마다 오른쪽에선 0이 생성되고 2씩 곱해진다.오른쪽으로 밀 때마다 왼쪽에선 첫번째 비트와 같은 값이 생성되고 2씩 나눠진다." }, { "title": "자바스크립트", "url": "/posts/javascript/", "categories": "공부, 프론트엔드", "tags": "자바스크립트, 프론트엔드", "date": "2022-05-22 09:11:00 +0900", "snippet": "정수만 입력받고 싶다면 불필요한 조건을 만들지 말고 isNaN부터 활용해주자.선언은 사용하는 위치 가까운 곳에 둔다.자바스크립트에서는 하이픈(-)을 사용할 수 없다.Number()=숫자로만 구성된 문자열을 실수화javascript에서 문자열 + 숫자는 문자열이다.숫자끼리 먼저 더하도록 하고 싶으면 괄호 결합inline tag 내 event 속성값은 순수 javascript code이다.?함수 내에서 arguments[]를 이용하여 저장된 인자를 확인할 수 있다.익명 함수는 function (s1,s2)가 아닌 (s1,s2) =&gt; {}; 로도 나타낼 수 있다.(중괄호도 생략)함수 내에서 var 선언을 또 하면 블록 스코프 내 새로운 지역변수가된다.var는 변수 중복 선언 가능, let,const는 불가능최근에는 많은 개발자가 안전 등의 이유로 익명 함수를 선호하는 편.익명 함수는 함수 뒤에서 호출 불가 절차따라 코드가 해당 줄을 읽을 때 생성선언적 함수는 함수 코드 이전에도 호출 가능 코드 실행전에 생성됨 (호이스팅)내장 함수에는 isNaN isFinite Number parseInt parseFloat String eval 등이 있다.prototype: 메서드를 외부에서 추가하고 호출할 수 있다string.prototype.trim() 내장 객체에서 trim() 도 메서드 중 하나이다.한 계층에 여러 형제 요소가 존재할 때last-child 선택자는 기준 점을 상대적으로 잡기 때문에 적용이 안 될 때가 있다.first-child의 경우 h1:first-child 시 h1중 첫 번째를 사용하지만last-child를 바로 적용한다면 예를 들어, 이 상황에서 h1:last-child는 h2를 선택하게 된다.last-child 대신 last-of-type 를 이용하면 해결할 수 있다.array.forEach(function(value, index, array)){};forEach를 이용하면 배열의 값, index, 배열 자체를 읽을 수 있다.map method를 이용해서 기존의 배열로 새로운 배열을 만들 수 있다.filter method를 이용해서 기존의 배열에서 원하는 type만 뽑아서 새로운 배열을 만들 수 있다.Math도 객체이다.속성: PI, E, LN2, LN10, LOG2E, LOG10E, SQRT1_2, SQRT1_2method: abs, max, min, round, ceil, floor, random, sin, tan, sqrtabs:절대값 | max,min:수치 비교 | round:반올림 | ceil,floor:올림,내림 | random:0~1사이의 난수Date 객체엔 현재 시각, 시각 지정, 국제 시각 등 종류가 많다.Event event &lt;=&gt; function 연결 시 ( )붙이면 1회 즉시 실행됨. inline 내 event=””, node.event = function, node.addEventListener addEventListener는 하나의 event에 다양한 행동 가능 &lt; 가장 현대적인 모델event model의 parameters는 event object를 의미. 주요 property: target, type, clientX,Y , screenX,Y , buttonpreventDefault() = return falsestopPropagation = 버블링 방지(하위 요소에 event 효과 전파)캡처링이 먼저 실행되고 버블링 실행흔히 아는 pop-up window 는 open()으로 만들 수 있음.Interval method 는 일정 시간마다 지정한 함수를 반복적으로 실행시킬 수 있음.setInterval(fucntion(){},ms);Timeout은 설정한 시간이 흐른 뒤에 지정한 함수를 한 번만 실행함.clearInterval, clearTimeout은 set method를 변수에 저장시킨 뒤 사용.배열이 있을 때 반복문을 사용할 수 있고반복문에서 배열을 사용할 때 of,in 등의 문법을 사용할 수 있다.항상 중복되는 문장을 어떻게 축약할 지 고민해야한다..each() method는 배열의 반복처리를 간단하게 해결 가능.애니메이션이 복잡할수록 JS가 유리하다.attribute 는 HTML 요소의 추가적인 정보를 전달하고“name = value” 쌍의 형식이다.?구조체 함수.*클래스:구조체에 구조체를 항상 인자로 가지는 함수클래스를 통해 만들어진 결과물을 값과 동작을 함께 가지고 있는 것이주위 사물과 유사하다고 하여 object라 부른다객체의일부분만 재사용 하는 걸 상속받는다고 하고 extend를 통해상속받은 걸 새로운 class명을 통해 활용하는 것을 추상화라고 한다.?값을 변경할때 변수가 선언된 위치에서 부터 3~7줄 범위내에서 수정되며 선언된 함수의 scope를 벗어나지 않는 값이라면 복사해서 값을 옮기는 행위는 리소스 낭비입니다.let 보다 const를 쓰려 해라함수형 프로그래밍은 불변성의 유지로 부터 시작된다.Do Not This:let foo = 100…foo = somthing(foo, “bar”)Do This:const foo = 100…const new_foo = somthing(foo, “bar”)Array,Date의 Mutation Method을 가급적 사용하지 마라.push, pop, shift, sort, reverse 등 객체를 변화시키는 method를 가급적 spread operator로 대체하거나값을 복사해서 사용.Do Not This:const example = (arr:number[], date:Date) =&gt; { arr.push(4) arr.sort() date.setMonth(10)}Do This:const example = (arr:number[], date:Date) =&gt; { const new_arr = […arr, 4] const sorted_new_arr = […new_arr].sort() const new_date = new Date(date).setMonth(10) return [new_arr, new_date]}가급적 object의 필드에 대입연산자를 쓰지 마라.Do Not This:const example = (obj:Object) =&gt; { obj.foo = 200}Do This:const example = (obj:Object) =&gt; { return {…obj, foo: 200}}" }, { "title": "자바스크립트 오브젝트 모델", "url": "/posts/javascript-object-model/", "categories": "공부, 프론트엔드", "tags": "자바스크립트, DOM", "date": "2022-05-22 09:11:00 +0900", "snippet": "DOM(Document Object Model)HTML은 사람이 편리하게 다룰 수 있는 문자열이지 컴퓨터가 알아듣고 사용하기에 좋은 언어는 아닙니다HTML을 동적으로 보다 효율적으로 변경하기 위해서 HTML 문서(Docuemnt) 를 자바스크립트가 이해할 수 있는 객체(Object) 의 형태로 모델(Model)링 하여 자바스크립트에서 조작을 할 수 있도록 만든 ⭐️ interface가 바로 이 DOM(Document Object Model)인 것입니다.이후 DOM API를 최대한 편하게 쓰기 위해서 노력했고 jQuery라는 선구자가 있어서 DX를 개선을 했기에 document.querySelectorAll과 같은 API가 표준 API가 될 수 있었죠. 하지만 DOM API를 그냥 쓰는 것은 좋은 방법은 아닙니다.지금도 마찬가지입니다. 가급적 DOM API를 사용하지 않고 다른 방식으로 개발을 하려고 하고 있죠. HTML은 사람이 읽기 편하고 생성하기 편한 문자열로 되어 있으나 DOM은 컴퓨터가 이해할 수 있도록 하나씩 조작을 해야하도록 만들어졌습니다.그러니 현대의 프레임워크에서는 HTML을 조작하는 감각으로 DX를 제공하고 내부에서는 VirtualDOM과 같은 방식을 이용해서 DOM API 사용을 최적화 하려고 하고 있죠.그렇기에 현재는 DOM API의 기본적인 선택과 조작, 이벤트 연동, 노드의 추가 삭제등에 대해서 DOM를 다룰 일은 별로 없습니다.프레임워크를 쓰고 있다면 주로 .getBoundingClientRect와 같이 UI를 고도화하기 위한 UI속성들을 조회하거나 .scrollIntoView나 animate와 같은 UI를 다루는 방법들을 알아야 합니다.프레임워크를 떠나 모두에게 배포를 하는 UI 컴포넌트를 만들어야 한다면 DOM API를 깊게 알아야 할 수도 있습니다. 특정 프레임워크에 종속이 되면 안될테니까요.아니면 직접 프레임워크나 라이브러리를 만들어야 한다면 DOM API에 대한 깊은 이해가 필요하겠죠.리액트는 가상 돔을 채용하여 대중화시켰다.DOM 위에 BOM이 있다.DOM인 window.document 외에도navigator, screen, history, loaction, console 등이 있다.alert =&gt; window.alert , document.write =&gt; window.document.write 처럼최상위에 있는 window 객체를 편의를 위해 숨겼을 뿐이다DOM을 이용해 javascript에서 node를 제어하기 위해서 선택자를 불러와야 한다.단일 선택자와 다중 선택자로 나뉘고 다중 선택자는 배열에 저장된다.배열에 저장되므로 반복문 등으로 활용할 수 있다.Node By~를 제외하면 선택자 입력이 css와 같고 선택자를 따옴표로 감싸준다.getElementByIdquerySelectorgetElementsByClassNamegetElementsByNamegetElementsByTagNamequerySelectAllcontent가 존재하는 요소를 불러왔을 때 몇 가지의 경우가 존재한다.console.log(node); =&gt; 요소 전체가 출력됨.console.log(node.innerHTML); =&gt; 해당 요소 계층 자식들의 값이 tag를 포함에 출력됨console.log(node.textContent); =&gt; tag값을 제외한 text가 출력됨console.log(node.innerText); =&gt; textContent와 같지만 trim()이 적용된 값이 출력됨DOM X javascript를 이용해 요소의 style 값도 조정가능함. inline tag로 적용됨.css는 콜론만 있으면 되지만 javascript는 equal에 속성값을 문자열로 적어야함.(변수와의 구분)css : javascript : node.style.color = “white”;해당 요소의 속성 값을 얻고, 추가할 수 있음.getAttribute(“att-name”), setAttribute(“attribute-name”,”attribute-value”)javascript로 HTML 문서 내 DOM을 활용할 때 tag 요소 뿐만 아니라 content값도 작성할 수 있다.ele = document.createElement(“any”);ele.innerHTML = “”;같은 방식으로, 생성된 ele 요소에는 여태까지 다뤘던 요소의 모든 것들이 적용된다.비슷한 것으로,document.createTextNode(); 는 text 정보가 저장된 객체를 생성한다.?element를 생성한 것과 달리 style 속성은 따로 적용되지 않는 것 같다.text를 생성할 일이 있을 때 append, pretend method로 위치 지정create가 된다면 remove도 된다.removeChild로 기준이되는 요소를 정한 뒤 순차적으로 제거할 수 있다.기준이 되는 요소를 정한 뒤 부모, 자식 요소를 찾을 수 있음.node.(childNodes, firstChild, lastChild, parentNode, nextSibling, previousSibling)child, parent, sibling 정도만 기억하면 됨.form filter selectorinput:type 형식으로 선택 가능property는 attribute에 대한 DOM 안에서의 표현이다.DOM 안에 존재하고 동적이다." }, { "title": "HTML", "url": "/posts/html/", "categories": "공부, 프론트엔드", "tags": "html", "date": "2022-05-22 09:11:00 +0900", "snippet": "HTMLlang: screen reader, 특정 부분에도 적용 가능ol 보단 ul을 많이 쓴다.시맨틱 태그header, section, footer, nav, article, aside#inline, blockinline &gt; block (X)block &gt; inline (O)image tag에 alt=”” 필요하지만 값은 비워도 됨.image tag에 map tag를 이용해 부분적으로 다른 경로 지정 가능#tableborder-collapse vs cell-spacing행 단위 style은 tr을 이용, 열 단위는 column group으로 묶기caption tag: table 제목, scope tag: 행 또는 열 카테고리의 제목cell 내부 content 정렬은 table 요소에 text-align#formform은 일반적으로 input 요소들과 함께 다님submit, image, button 등 사용자 데이터를 form을 통해 가져옴action: 경로, method: 방식tabindex tag를 이용해 tab key 입력 시 이동 방향을 지정가능input tag - autocomplete로 자동완성기능pattern - 정규식multiple - 여러개 전송다중 생성 예제table&gt;(tr&gt;td[conlspan=”5”])5+tr&gt;td{$th}3" }, { "title": "CSS", "url": "/posts/css/", "categories": "공부, 프론트엔드", "tags": "css", "date": "2022-05-22 09:11:00 +0900", "snippet": "CSStextpx-해상도에 따라 상대적으로 달라짐%-부모 요소의 글자 크기를 기준em-부모 요소의 글자 크기를 기준특별한 설정이 없을 시16px = 1em해상도와 웹브라우저 크기를 헷갈리면 안됨글자 간의 간격 letter-spacing 단어 간의 간격 word-spacing 음수 값도 가능line-height : 줄간격text-transform 단어 첫자를 대문자로text-indent 문단 첫째줄 들여쓰기column 속성으로 하나의 긴 텍스트를 신문기사처럼 나타낼 수 있다.box태그 전체의 크기 구하기width + 2*(M,B,P)상하 margin 은 겹치는 박스 둘 중 더 큰 margin 값으로 결정된다.box-sizing padding, border 값을 width가 삼킴box-shadow inset 값으로 action 을 이쁘게 표현 가능box 내부에 가상 content를 생성해서 block화 시키는 방법 :after {content:””; display:block; clear:both}:displayinline: 수평 정렬, 너비 지정 불가, margin, padding 적용block: width: 100%, height: content. size 지정가능inline-block: 지정시 수평 정렬되나 size 지정 가능 (몇몇 input 요소의 default)blbackground:배경 레이어링을 하려면 이미지 한 요소에 연속 등록background-position (%)으로 좌표계 설정가능back~-attachment:fixedpostitionstatic 상대 위치 좌표 설정relative 초기 위치에서 상하좌우absolute 절대 위치 좌표 설정. 부모 요소에 relative를 정의해야 초기 위치 정해짐. 부유 객체는 inline 요소처럼 content의 크기가 block의 크기, 부모 요소에 다른 컨텐츠가 없을 경우 부모 요소의 높이 값이 0이 된다.fixed 화면을 기준으로 절대 위치 좌표 설정z index 설정하지 않을 시더 뒤에 적힐수록 더 앞에 나타난다.table tag는 layout 용도로 사용하지 말자container 내부에서 두 개의 block을 나란히 배치할 때 세로 길이가 더 긴 것에 relative를 부여해야 container가 전체를 감싸줌.이때 좌측이 absolute라면 우측 block에 left:(좌측 content의 width)를 해주면 깔끔하다.margin-left와 둘 중 하나를 사용하면 됨.class?class name 작성 시 띄어쓰기를 이용해 여러 class로 구분 가능class name 숫자로 시작할 수 없다.시맨틱 태그는 div와 같은 블록 요소지만 의미를 가짐.? 상속은 바로 아래의 자식한테만 물려주는가?selector불필요하게 전체 선택자를 사용하는 것은 속도 저하의 원인형제 선택자: “A ~ B” A와 같은 계층에 있는B 요소들만 지정인접 선택자: “A + B” A 바로 뒤의 B 요소속성 선택자: [name=””]!important: 선택자 순서를 무시하고 최우선 순위:align?전체 mar,pad:0;을 해야하는지 margin:0 auto로 중앙 정렬이 맞는 건지.vertical-align은 image, form, table 요소에 작동절대위치에서의 수직정렬: top:50%, transform:translateY(-50%)inline 요소는 컨텐츠 만큼의 영역만 차지하므로 text-align이 의미없다.여러 개체를 나열할 때 절대 위치보다 margin 주는 게 효율적임.형제 요소를 다룰 때 nth-child 등의 선택자 활용대부분의 선언은 해당 요소의 자식요소에게만 적용된다.후손 요소에게도 선언하려면 자식 요소에게도 적용시켜야 한다.radius = 반지름 border-R 하면 설정된 값을 반지름으로 가진 원을 모서리에 만든다고 생각하면 됨resize 는 overflow와 세트다.구형 브라우저에서 사용해야할 때 속성 앞에 브라우저를 알려주기 위해 vender-prefix 작성flexfloat 보다 flex를 더 많이 활용해야한다.flex layout은 container에 flex 선언 후 내부 요소들을 유연하게 배치하는 속성align-items 는 자식요소들을 정렬" }, { "title": "인터페이스와 추상클래스", "url": "/posts/abstract-Interface/", "categories": "그 외, deprecated", "tags": "자바, 인터페이스, 추상클래스", "date": "2022-05-16 09:11:00 +0900", "snippet": "인터페이스와 추상 클래스의 가장 큰 차이는 결합의 정도이다.추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다.자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데 제약이 있다.인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.추상 클래스보다 인터페이스를 우선시 해야 하는 이유기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다. (다중 구현)믹스인(mix-in)에 안성맞춤이다. (추상 클래스는 정의할 수 없음) 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 주된 타입 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.계층 구조가 없는 타입 프레임워크를 만들 수 있다.래퍼 클래스 관용구(아이템 18)와 함께 사용하면 기능을 향상시키는 안전하고 강력한 수단이 된다./추상 클래스의 주 목적은, 상속받은 자식 클래스가 부모인 추상 클래스의 기능을확장하는 ‘확장성’에 주 목적을 두고 있다.하지만 인터페이스는 구현하는 구현 클래스들의 동일한 동작을 보장하지만,이들 구현체가 동일한 목적을 가지고 있을 필요는 없다.인터페이스클래스간 관련성은 없지만, 동일한 동작을 보장하고 싶을 때 (높은 응집도, 낮은 결합도)다중 상속이 필요한 경우특정한 데이터 혹은 객체의 동작을 명시하고자 하는데 목적과 구현 위치는 상관 없을 때추상 클래스관련성이 존재하는 클래스 간에 동작을 공유하고 싶을 때(확장)메소드를 사용하여, 객체의 상태 변화가 가능하게 하고 싶을 때//일련의 하위 클래스에서 사용할 틀을 정의하고 싶다면, 그리고 모든 하위클래스에서 사용할 구현 코드가 조금이라도 있다면 추상클래스를 사용합니다. 그리고 그유형의 객체를 절대 만들 수 없게 하고 싶다면 그 클래스를 추상 클래스도 만듭니다.상속트리에서의 위치에 상관없이 어떤 클래스의 역할을 정의하고 싶다면 인터페이스를 사용하면 됩니다.///하지만 모든 Class가 Interface를 이용한다면, 공통적으로 필요한 기능도 implements하는 모든 Class에서 Overriding해 재정의해야 하는 번거로움이 존재한다.‘is a kind of(~의 한 종류) 추상 클래스’와 ‘be able to(~할 수 있는) 인터페이스’////또 다른 관점에서는 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜놓은 것으로 상속 관계를 타고 올라갔을 때, 같은 부모 클래스를 상속하며, 부모 클래스가 가진 기능들을 구현해야 하는 경우에 사용합니다.반면 인터페이스는 상속 관계를 타고 올라갔을 때, 다른 부모 클래스를 상속하더라도 같은 기능이 필요한 경우에 사용됩니다./////상속은 같은 종류의 하위 클래스를 만드는 기술인터페이스는 사용 방법이 동일한 클래스를 만드는 기술-인터페이스에서 추상메소드는 기본적으로 public과 abstract가 적용되어있다.추상클래스는 다양한 클래스들로부터 일반화된 항목을 추려 공통된 규약을 맺는 것인터페이스는자신보다는 구체화된 상태인 클래스들에게 특정 행위를 구현하도록 약속" }, { "title": "컬렉션 프레임워크", "url": "/posts/collectionFramework/", "categories": "그 외, deprecated", "tags": "자바, 컬렉션 프레임워크", "date": "2022-05-13 09:11:00 +0900", "snippet": " = - = - = - = - = - = 자료 구조 (Data Structure) = - = - = - = - = - = - List ArrayList: 동적 가변 배열비동기 방식이기 때문에 스레드에 안전하지 못하다.그렇기 때문에 멀티 스레드 환경에서는 Collection.synchronizedList()를 사용한다.동기화된 컬렉션은 멀티 스레드 환경에서 하나의 스레드가 요소를 안전하게 처리하도록도와주지만, 전체 요소를 빠르게 처리하지는 못한다.왜냐하면 스레드가 작업을 할 때 락이 발생하기 때문이다. (병렬 처리 불가)자바에서는 멀티 스레드 환경에서 안전하면서도 스레드가 병렬적으로 작업을 처리할 수 있도록java.util.concurrent 패키지에서 ConcurrentHashMap, ConcurrentLinkedQueue 를 제공한다.이 구현체들은 부분(segment) 잠금을 사용하기 때문에 병렬적으로 작업 수행이 가능하다.ArrayList는 특정 인덱스에 객체를 삽입하면 전체가 요동치므로 삽입, 삭제가 빈번하면 LinkedList로LinkedLIst: 이중 링크드 리스트각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있다.데이터를 담고 있는 노드들이 연결되어 있고, 노드의 포인터가 이전 노드와 다음 노드와의 연결 담당.Vector: (ArrayList와 비슷함)오래된 자료구조, 호환성을 위해 남겨놓은 레거시 클래스이다.동기화를 사용하지만 스레드가 안전하지 못하므로 사용하지 않는 것이 좋다.Collection.synchronizedList() 메소드와 함께 ArrayList를 사용하자.Stack: (LIFO)Vector 를 상속하여 사용하는 LIFO 방식의 클래스Stack 대신 Deque 를 사용하여 구현할 것을 권장함. QueueQueue interface: (FIFO) (주로 LinkedList를 이용하여 구현한다)Deque 또는 Queue를 LinkedList처럼 노드 객체로 연결해서 관리하길 원한다면LinkedList를 쓰면 되고, 오브젝트 배열로 사용하고 싶으면 ArrayDeque를 사용한다.자바에서 지원하는 컬렉션에서 ‘일반적인 큐’를 사용하고자 한다면 LinkedList를 생성하여 Queue 선언.Priority Queue: (우선 순위 큐)FIFO가 아닌 특정 우선 순위에 따라 우선 순위가 높은 요소가 먼저 삭제되는 자료구조.디폴트로 낮은 숫자가 높은 우선 순위를 가진다.(단, 참조 타입일 경우 Compartor 또는 Comparable을 통해 정렬 방식을 구현해야함)null을 허용하지 않습니다.Deque interface:Queue가 삽입과 삭제가 한 쪽에서만 가능하다면, Deque는 양쪽에서 삽입, 삭제가 가능한 자료구조사용 방식에 따라 Stack이 될 수 있고 Queue가 될 수도 있다.ArrayDeque: 사이즈 제한이 없는 가변 배열이며 null 비허용, 비동기 원형 큐 방식Stack 목적으로 구현했을 때 기존의 Stack보다 빠르고, Queue 목적으로 구현했을 때 LinkedList보다 빠르다.Array는 LinkedList보다 cache-locality에 조금 더 친숙하다고 한다.(LinkedList는 다음 노드가 있는 곳으로 가려고 다른 간접적인 경로를 거쳐감)또한 ArrayDeque는 다음 노드에 대한 추가 참조를 유지할 필요가 없으므로 LinkedList보다 메모리 효율적이라고 한다.쉽게 말해서, Queue는 FIFO의 특성을 가지고 있다.즉, 삽입은 큐의 맨 처음에, 삭제는 큐의 맨 마지막에 일어나기 때문에 중간에 삽입되거나 삭제되지 않습니다.결국 삽입 삭제의 시간복잡도는 O(1)이므로 리스트와 별반 차이가 없기에 최적화가 잘되있는 배열이 좀더 빠릅니다. SetSet: 말 그대로 집합을 뜻한다.특징은 “데이터를 중복해서 저장할 수 없음”과 “입력 순서대로의 저장 순서를 보장하지 않는다LinkedHashSet은 입력순서대로의 저장순서를 보장합니다. 하지만 데이터를 중복해서 저장할 수 없는 것은 같습니다. equals()메서드를 사용하여 들어온 값이 있는지 없는지 확인합니다.LinkedHashSet:앞에서 말했듯이 중복은 허용하지 않으면서 순서를 보장받고 싶을 경우 사용합니다.LinkedHashMap을 동해 구현되어 있습니다.HashSet:가장 기본적인 Set 컬렉션의 클래스.해시 알고리즘을 사용하여 검색 속도가 빠르다는 장점좀더 상세히 말하면 hash에 의해 데이터의 위치를 특정시켜 해당 데이터를 빠르게 색인 할 수 있다즉, Hash 기능과 Set 컬렉션이 합쳐진 것이 HashSet입니다. 그렇기 때문에 삽입, 삭제, 색인이 매우 빠른 컬렉션 중 하나이다.HashMap을 통해 구현되어 있습니다.TreeSet:HashSet과 마찬가지로 입력 순서대로의 저장 순서를 보장하지 않으며 중복 데이터 또한 넣지 못합니다. 다만 TreeSet은 중복되지 않으면서 특정 규칙에 의해 정렬된 형태의 집합을 쓰고 싶을 때 사용합니다. 정렬된 형태로 있다보니 특정 구간의 집합요소들을 탐색할 때 매우 유용합니다.(Tree 라는 자료구조 자체가 데이터를 일정 순서에 의해 정렬하는 구조입니다. 거기에 더해진 것이 바로 Set인 중복값 방지 자료구조인 것입니다.)TreeMap을 통해 구현되어 있습니다. MapMap은 값을 키에 매핑하는 객체입니다.특징으로는. 데이터의 순서를 보장하지 않습니다.중복된 Key 값을 가질 수 없습니다.최대 하나의 Key에 매핑될 수 있습니다.Key를 통해 Value에 바로 접근이 가능하므로 탐색이 빠릅니다.equals()메서드를 사용하여 두 키가 동일한지 다른지 확인합니다. HashTableMap 인터페이스의 구현 클래스이며, 자바 초기 버전에 나온 레거시 클래스입니다.Key와 Value가 null이면 안되고, Vector처럼 대부분의 메소드가 동기화처리 되어있다는 특징이 있습니다.Key를 특정 해시 함수를 통해 해싱한 후 나온 결과를 배열의 인텍스로 사용하여 Value를 찾는 방식으로 동작합니다. HashMap정렬되지 않은 Map을 제공합니다.하나의 null key와 다수의 null 값을 허용합니다.순서에 신경쓰지 않는경우 다른 Map보다 빠르다는 장점이 있습니다.hashCode()를 구현하면 접근 성능이 더 좋아집니다.동기화 되지 않고 null을 허용한다는 점을 제외하면 HashTable과 거의 동일합니다. (보완했다 생각하면됨)(싱글 스레드 환경에서 성능이 더 좋음 → 멀티 스레드 환경에선 ConcurrentHashMap을 사용) LinkedHashMapLinkedHashSet과 같이 입력순서대로의 저장순서를 보장합니다. → 순서를 보장하는 LinkedList의 구조를 이용함삽입 삭제는 HashMap보다 느리지만, 더 빠른 조회를 할 수 있습니다. TreeMap정렬된 Map을 제공합니다.Key를 기준으로 원하는 방식으로 정렬을 할 수 있따는 특징이 있습니다.레드 블랙 트리로 구현이 되이있습니다.디폴트로 낮은 숫자가 높은 우선순위를 가집니다.(단, 래퍼런스 타입일 경우 Compartor 또는 Comparable을 통해 정렬 방식을 구현해야함) " }, { "title": "JAVA 객체 지향 디자인 패턴 - 5 - 행동", "url": "/posts/design-patten-5-behavioral/", "categories": "공부, 디자인패턴", "tags": "디자인패턴, 자바", "date": "2022-05-09 05:00:00 +0900", "snippet": " BehavioralChain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer State, Strategy, Template Method, Visitor 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴으로, 가령 한 객체가혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도객체 사이의 결합도를 최소화하는 것에 중점을 둔다.Strategy스트래티지 패턴은 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴이다.여기에서 전략이란 어떤 목적을 달성하기 위해 일을 수행하는 방식,비즈니스 규칙, 문제를 해결하는 알고리즘 등으로 이해할 수 있다.프로그램에서 전략을 실행할 때는 쉽게 전략을 바꿔야 할 필요가 있는 경우가 많이 발생한다.특히 게임 프로그래밍에서 게임 캐릭터가 자신이 처한 상황에따라 공격이나 행동하는 방식을바꾸고 싶을 때 스트래티지 패턴은 매우 유용하다State실세계의 많은 개체는 자신이 처한 상태에 따라 일을 다르게 수행한다.비가 오거나 눈이 오거나 사람이 많이 붐비는 장소에 있거나에 따라걷는 방식과 말하는 방식이 달라지는 것과 마찬가지 이치다.이를 표현하는 가장 직접적이고 직관적인 방법은 일을 수행할 때의상태에 따라 상태 하나하나가 어떤 상태인지 검사해 일을 다르게 수행하게끔 하는 것이다.이는 분명 복잡한 조건식이 있는 코드를 산추랗ㄹ 것이고, 결과적으로 코드를 이해하거나수정하기 어렵게 만든다.이런 방식과는 달리 스테이트 패턴은 어떤 행위를 수행할 때 상태에 행위를 수행하도록 위임한다.이를 위해 스테이트 패턴에서는 시스템의 각 상태를 클래스로 분리해 표현하고,각 클래스에서 수행하는 행위들을 메서드로 구현한다.그리고 이러한 상태들을 외부로부터 캡슐화하기 위해 인터페이스를 만들어 시스템의 각 상태를 나타내는 클래스로 하여금 실체화하게 한다.Command커맨드 패턴은 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 유요하다.예를 들어 ‘file open’ 이라는 메뉴 항목이 선택되었을 때 실행될 기능과‘file close’ 라는 메뉴 항목이 선택되었을 때 실행되는 기능은 다를 것이다.이런 경우 메뉴아이템 클래스에서 직접 구체적인 기능을 구현한다면파일오픈 메뉴 항목을 위한 메뉴아이템 클래스와파일 클로스 메뉴 항목을 위한 메뉴아이템 클래스를 각각 구현해야한다.메뉴아이템 클래스는 하나이므로 파일 오픈과 파일 클로즈 메뉴 항목을 재사용하기 어려울 수 있기 때문이다.이런 경우에는 커맨드 패턴을 활용하면 메뉴아이템 클래스를 재사용할 수 있다.먼저 파일오픈 메뉴의 기능과 파일클로즈 메뉴의 기능을 담당하는 클래스가커맨드라는 인터페이스를 구현하도 한다.그리고 메뉴아이템 클래스가 커맨드 인터페이스를 사용하도록 설계하면메뉴아이템 클래스는 파일오픈 메뉴 항목과 파일클로즈 메뉴 항목에서 그대로 재사용할 수 있게 된다.Observer옵저버 패턴은 데이터의 변경이 발생했을 경우 상대 클래스나 객체에 의존하지 않으면서데이터 변경을 통보하고자 할 때 유용하다.예를 들어 새로운 파일이 추가되거나 기존 파일이 삭제되었을 때 탐색기는 이를 즉시 표시할 필요가 있다.탐색기를 복수 개 실행하는 상황이나 하나의 탐색기에서 파일 시스템을 변경했을 때는 다른 탐색기에게즉각적으로 이 변경을 통보해야한다.다른 예로 차량의 연료가 소진될 때까지의 주행 가능 거리를 출력하는 클래스,연료량이 부족하면 경고 메시지를 보내는 클래스, 연료량이 부족하면 자동으로근처 주유소를 표시하는 클래스 등에 연료량의 변화를 통보하는 경우가 있다.이런 경우에 연료량 클래스는 연료량에 관심을 가지는 구체적인 클래스(주행 가능 거리 출력, 연료량 부족 경고, 근처 주유소 검색)위의 것들에 직접 의존하지 않는 방식으로 설계하는 것이 바람직하다.Template Method템플릿 메소드 패턴은 전체적으로는 동일하면서 부분적으로는다른 구문으로 구성된 메서드의 코드 중복을 최소화할 때 유용하다.다른 관점에서 보면 동일한 기능을 상위 클래스에서 정의하면서확장/변화가 필요한 부분만 서브 클래스에서 구현할 수 있도록 한다.앞선 예제처럼 모터 클래스의 무브 메소드는 현대모터와 엘지모터에서 동일한 기능을 구현하면서 각 하위 클래스에서 구체적으로 정의할 필요가 있는 부분,즉 무브모터 메소드부분만 각 하위 클래스에서 오버라이드되도록 한다.이러한 경우 모터 클래스의 무브 메소드를 템플릿 메소드라고 부르고,무브 메소드에서 호출되면서 하위 클래스에서오버라이드될 필요가 있는 무브모터 메소드를 프리미티브 또는 훅 메서드라 부른다." }, { "title": "JAVA 객체 지향 디자인 패턴 - 4 - 구조", "url": "/posts/design-patten-4-structural/", "categories": "공부, 디자인패턴", "tags": "디자인패턴, 자바", "date": "2022-05-09 04:00:00 +0900", "snippet": " StructuralAdapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy클래스나 객체를 조합해 더 큰 구조를 만드는 패턴으로, 서로 다른 인터페이스를 지닌2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴Decorator데코레이터 패턴은 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에각 추가 기능을 데코레이터 클래스로 정의한 후 필요한 데코레이터 객체를조합함으로써 추가 기능의 조합을 설계하는 방식이다.예를 들어 기본 도로 표시 기능에 차선 표시, 교통량 표시, 교차로 표시,단속 카메라표시의 4가지 추가 기능이 있을 때 추가 기능의 모든 조합은 15가지다 된다.데코레이터 패턴을 사용하면 개별 추가 기능에 해당하는 데코레이터 클래스 4개만 구현하고개별 추가 기능을 객체의 형태로 조합함으로써 추가 기능의 조합을 구현할 수 있다.또한 프로그램을 실행하는 중에도 데코레이터 객체의 조합이 가능하므로필요한 추가 기능의 조합을 동적으로 생성하는 것도 가능하다.Composite컴퍼지트 패턴은 부분-전체의 고나계를 갖는 객체를 정의할 때 유용하다.지금까지 설명한 컴퓨터 예제에서 알 수 있듯이 모니터, 바디 등의 객체가 컴퓨터 클래스전체 객체의 일부분으로 정의되었다.이런 경우 부분 객체의 추가나 삭제등이 있어도 전체 객체의클래스 코드를 변경하지 않으면 컴퍼지트 패턴은 유용하다." }, { "title": "JAVA 객체 지향 디자인 패턴 - 3 - 생성", "url": "/posts/design-patten-3-creational/", "categories": "공부, 디자인패턴", "tags": "디자인패턴, 자바", "date": "2022-05-09 03:00:00 +0900", "snippet": "Gang Of Four Design Pattern List CreationalAbstract Factory, Builder, Factory Method, Prototype, Singleton객체 생성에 관련된 패턴으로, 객체의 생성과 조합을 캡슐화해 특정 객체가생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.Singleton싱글턴 패턴은 인스턴스가 오직 하나만 생성되는 것을 보장하고어디에서든 이 인스턴스에 접근할 수 있도록 하는 디자인 패턴이다원래 싱글턴이라는 단어는 ‘단 하나의 원소만을 가진 집합’이라는 수학 이론에서 유래되었다. 굳이 싱글턴 패턴을 사용하지 않고 정적 메서드로만 이루어진정적 클래스를 사용해도 동일한 효과를 얻을 수 있다.Factory Method팩토리 메소드 패턴은 객체의 생성 코드를 별도의 클래스/메소드로 분리함으로써 객체 생성의 변화에 대비하는 데 유용하다.지금까지 설명한 엘리베이터 스케줄링의 예에서 볼 수 있듯이프로그램이 제공하는 기능은 상황에 따라 변경될 수 있다.그리고 특정 기능의 구현은 개별 클래스를 통해 제공되 것이 바람직한 설계다.그러므로 기능의 변경이나 상황에 따른 기능의 선택은 바로 해당 객체를새엇앟는 코드의 변경을 초래한다. 게다가 상황에 따라 적절한 객체를 생성하는 코드는 자주 중복될 수 있다.이런 경우 객체 생성 방식의 변화는 해당 되는 모든 코드 부분을 변경해야 하는 문제를 일으킨다.바로 이러한 경우에 객체 생성 코드를 별도의 클래스/메소드로 분리해 이용한다면이 클래스/메소드만 변경함으로써 객체 생성 방식의 변화에 효과적으로 대응할 수 있다.Abstract Factory추상 팩토리 패턴은 관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유리하다.지금까지 설명한 엘리베이터 예제에서 볼 수 있듯이 엘지 부품을 위한 코드는엘지의 모터와 문을 이용할 것이다. 만약 현대 부품을 지원하도록 코드를 수정해야 한다면모터와 문이 일관성 있게 엘지에서 현대로 변경되어야 한다.바로 이러한 경우에 부품별로 팩토리를 정의하는 대신관련 객체들을 일관성 있게 생성할 수 있도록 팩토리 클래스를 정의하는 것이 효과적이다.예를 들어 모터 클래스를 위한 모터팩토리 클래스의 도어 클래스를 위한 도어팩토리 클래스를정의하는 대신 엘지 부품들을 위한 엘지 팩토리 클래스와 현대 부품들을 위한 현대팩토리 클래스를정의하는 것이 바람직하다." }, { "title": "JAVA 객체 지향 디자인 패턴 - 2", "url": "/posts/design-patten-2-summmary/", "categories": "공부, 디자인패턴", "tags": "디자인패턴, 자바", "date": "2022-05-09 02:00:00 +0900", "snippet": "Gang Of Four Design Pattern List CreationalAbstract Factory, Builder, Factory Method, Prototype, Singleton객체 생성에 관련된 패턴으로, 객체의 생성과 조합을 캡슐화해 특정 객체가생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다. StructuralAdapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy클래스나 객체를 조합해 더 큰 구조를 만드는 패턴으로, 서로 다른 인터페이스를 지닌2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴 BehavioralChain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer State, Strategy, Template Method, Visitor 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴으로, 가령 한 객체가혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도객체 사이의 결합도를 최소화하는 것에 중점을 둔다. 객체지향 디자인패턴(책)에서는 이 중에서 다음 10가지 GoF 디자인 패턴을 다룬다.Abstract Factory, 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공Factory Method, 객체 생성 처리를 서브 클래스로 분리해 처리하도록 캡슐화Singleton전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조Composite,여러 개의 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 함Decorator객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해줌Observer, 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성State, 객체의 상태에 따라 객체의 행위 내용을 변경Strategy, 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해Template Method, 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꿈Command실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계" }, { "title": "JAVA 객체 지향 디자인 패턴 - 1", "url": "/posts/design-pattern-1/", "categories": "공부, 디자인패턴", "tags": "디자인패턴, 자바", "date": "2022-05-09 00:01:00 +0900", "snippet": "UML 다이어 그램의 종류연관 관계일 때 매개 변수 타입을 상대 클래스에 맞게 선언하고내부에서 상대 클래스의 메소드를 작성하고 . 중간에 새로운 클래스를 정의해서 두 클래스 사이에서 상호 교류를 시킬 수도 있다.-구조 다이어그램-1.클래스 다이어그램 : 시스템을 구성하는 클래스들 사이의 관계를 표현한다.2.객체 다이어그램 : 객체 정보를 보여준다.3.복합체 구조 다이어그램 : 복합 구조의 클래스의 컴포넌트 내부 구조를 표현한다.4.배치 다이어그램 : 소프트웨어, 하드웨어, 네트워크를 포함한 실행 시스템의 물리 구조를 표현한다.5.컴포넌트 다이어그램 : 컴포넌트 구조 사이의 관계를 표현한다.6.패키지 다이어그램 : 클래스나 유즈 케이스 등을 포함한 여러 모델 요소들을 그룹화해 패키지를 구성하고 패키지들 사이의 관계를 표현한다.-행위 다이어그램-7.활동 다이어그램 : 업무 처리 과정이나 연산이 수행되는 과정을 표현한다.8.상태 머신 다이어그램 : 객체의 생명주기를 표현한다.9.유즈 케이스 다이어그램 : 사용자 관점에서 시스템 행위를 표현한다.10.행위 다이어그램 - 상호작용 다이어그램 11.순차 다이어그램 : 시간 흐름에 따른 객체 사이의 상호작용을 표현한다. 12.상호작용 개요 다이어그램 : 여러 상호작용 다이어그램 사이의 제어 흐름을 표현한다. 13.통신 다이어그램 : 객체 사이의 관계를 중심으로 상호작용을 표현한다. 14.타이밍 다이어그램 : 객체 상태 변화와 시간 제약을 명시적으로 표현한다.어느 관점에서 보냐, 어떤 내용을 다루냐에 따라 도면이 다양하듯 소프트웨어 개발에서의 모델링도 많은 것이 존재한다. 클래스 다이어그램클래스란 동일한 속성과 행위를 수행하는 객체의 집합 또는 객체를 생성하는 설계도제목 학생 내용 특징부[이름,전공,학번,과목] 행위부[수강하다 등]의 테이블 식 표현public: +, private: -, protected: #, package ~ : -이름 +수강하다 이런식으로 접근 제한도 가시화한다.나아가 설계 단계 전까지 타입도 최대한 작성해준다.연관 관계: 클래스들이 개념상 서로 연결되었음을 나타냄 화살표로 표시하며 한 클래스가 다른 클래스에서 제공하는 기능을 사용하는 상황일 때일반화 관계: 상속 관계. 속이 빈 화살표를 사용해 표시.(머리 쪽이 부모 클래스)집합 관계: 집약, 합성 관계가 존재함. 클래스들 사이의 전체 또는 부분 같은 관계를 나타냄.의존 관계: 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때 차이점은 두 클래스의 관계가 한 메서드를 실행하는 동안 매우 짧은시간만 유지. 점선 화살표실체화 관계: 인터페이스 구현. 속 빈 삼각형 머리가 점선.(추상 클래스는 이탤릭체로 표기됨)일반화(상속)는 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종이다.자식의 수가 많아질수록 일반 클래스 상속이 편리해보인다.기능을 재사용할 때는 위임을 이용하라.무작정 상속받아 기능을 이용한다면 쓸데없는 빚이 생긴다.객체 간의 일반화가 필요할 때엔 서브 클래스에 슈퍼 클래스의 객체를 생성하여메소드 내에 슈퍼 클래스의 메소드를 끌어다 사용한다.이것도 캡슐화의 일종일까?실행 클래스에서 서브 클래스의 객체를 이용한다면객체 내의 인스턴스 필드에 선언된 슈퍼 클래스의 객체가 모든 행위를 담당하고 있다.일반화 관계에서 제약 조건자식 클래스 객체가 동시에 두 클래스에 속할 수 없다는 disjoint부모-자식간의 서로의 클래스에 상대 객체가 단 하나만 존재해야된다는 complete집합론적인 관점에서 일반화는 상호 배타적인 부분 집합으로 나누는 과정.다중 분류가 필요한 상황일 때 UML에서 변별자를 사용한다하나의 인스턴스는 여러 자식 클래스에 속하게 될 수 있다.예를 들어 VIP와 일반 멤버가 멤버 클래스를 상속할때지역민과 비지역민 클래스를 생성해 추가로 멤버 클래스를 상속한다면완전하게 독립적이라면 상관없지만, 일반 멤버지만 지역 주민에게는 경품을 제공하도록시스템에 새로운 요구사항을 추가하면 난처한 일이 생길 수 있다.그래서 상호 배타적으로 존재할 수 있게VIP의 지역, 비지역민 , 일반 멤버의 지역,비지역민을 따로 서브클래스로 만들어서 사용한다정적 메서드에서 다형성은 메소드 재정의를 무시한다.피터 코드의 상속 규칙 자식 클래스와 부모 클래스 사이는 “역할 수행”관계가 아니어야 한다. 한 클래스의 인스턴스는 다른 서브 클래스의 객체로 변환할 필요가 절대 없어야 한다. 자식 클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다. 자식 클래스가 단지 일부 기능을 재사용할 목적으로 유틸리티 역할을 수행하는 클래스를 상속하지 않아야 한다. 자식 클래스가 “역할, 트랜잭션, 디바이스”등을 특수화해야 한다.기존 코드에 전혀 영향을 주지 않고, 독립적인 자식클래스를 추가할 수 있다면개방-폐쇄의 원칙(OCP)을 따른다고 말할 수 있다.한 클래스에 너무 많은 책임을 할당하진 말자.혹여나 많아졌다면 책임을 분리해주자.횡단 관심 문제를 해결하기 위한 관심지향 프로그래밍(AOP)AOP는 횡단 관심을 수행하는 코드를 Aspect라는 특별한 객체로모듈화하고 위빙 작업을 통해 모듈화한 코드를 핵심 기능에 끼워넣을 수 있다.이를 통해 기존의 코드를 전혀 변경하지 않고도 시스템 핵심 기능에서 필요한 부가 기능을효과적으로 이용할 수 있다. 횡단 관심에 변경이 생긴다면 해당 Aspect만 수정하면 된다.joinpoint app 실행 중의 특정한 지점. (메서드 호출 등) 어떤 지점에서 AOP를 사용해 추가적인 로직을 삽입할지를 정의한다.advice 특정 joinpoint 에 실행하는 코드pointcut 여러 조인포인트의 집합체, 어드바이스를 언제 실행할지를 정의할 때 사용aspect advice와 pointcut을 조합한 조합물. app이 가져야 할 로직과 그것을 실행해야 하는 지점을 정의한 것 weabing app 코드의 해당 지점에 aspect를 실제로 주입하는 과정컴팩트가 복잡한 복합기가 있다.클래스에 다양한 기능이 작성되어있지만클라이언트는 모든 것을 이용하지 않는다.ISP는 이러한 범용 인터페이스보단 클라이언트에 특화되도록 인터페이스를 분리시켜라는 원칙이다.클래스가 분리될 때 조건문 내부에 있던 메서드는 리턴값을 boolean으로 지정해보자변경될 가능성이 큰 내용의 경우 분리할 수 있다면 분리해주는 것이 좋다.테스트를 위해서 인터페이스를 분리하여 사용" }, { "title": "SOLID 5원칙", "url": "/posts/SOLID/", "categories": "공부, 디자인패턴", "tags": "디자인패턴, SOLID", "date": "2022-05-09 00:00:00 +0900", "snippet": " *객체 지향 설계의 5원칙 (SOLID) * - * - * * - * * - _ *“응집도를 높이고, 결합도를 낮춰라 (High Cohesion, Loose Coupling) SRP (단일 책임 원칙)“어떤 클래스를 변경해야 하는 이유는 하나 뿐이다.” 클래스/속성/메서드/패키지/모듈/프레임워크 등에도 적용된다. 장점: 재사용성이 좋아진다. A,B 기능으로 나누어져 있으면, 다른 클래스에서 A기능만 필요한 경우에는 A만 가져다 쓸 수 있는 모듈이 된다.객체는 단 하나의 책임만 가져야 한다.이 객체가 가장 잘 수행할 수 있는 책임을 할당해야 하며수반되는 모든 일을 자신만이 수행 할 수 있으면 좋다.OCP“확장은 열려있고, 변경은 닫혀있다” 유지보수성이 좋아진다. JDBC에서 DB를 mysql 에서 oracle 로 바꾸어도 connection 설정 부분만 바꾸면 된다. 자바 app은 JDBC 인터페이스로 인해 변화에 영향을 받지 않는다. 변하는 것과 변하지 않는 것을 구분해야 한다.LSP (리스코프 치환 원칙)“서브 타입은 기반 타입으로 변경할 수 있어야 한다.(상속)” 고래 -&gt; 포유류ISP (인터페이스 분리 원칙)“자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다. 인터페이스는 최소한의 메서드만 제공해야 한다.DIP (의존 역전 원칙)“자신보다 변경되기 쉬운 것들에 의존하지 않는다.” 변하기 어려운 상위 클래스/인터페이스/ 추상클래스에 의존하라." }, { "title": "TEMP 스프링 시큐리티", "url": "/posts/security/", "categories": "공부, 스프링", "tags": "자바, 스프링, 웹", "date": "2021-09-27 09:01:00 +0900", "snippet": "http.addFilterAt(jwt 발급 필터, 베이직 필터)addFilterAfter(jwt 검증 필터, 베이직 필터)jwt 발금 필터 : header 에서 id/pw 를 가져와서 DB에서 찾고,있으면 매니저에서 Auth 진행 후 (Provider) 에서 처리response 에 jwt token 넘기기.jwt 검증 필터 : header 에서 jwt 가져와서 검증한 뒤,권한 부여한 Auth token 넘기기.\t매니저에게 넘기는 게 아닌, doFilter 로 req,res 에 넘김Auth 필터 -&gt; 요청 Auth manager 에 준다.매니저는 Provider 로 인증 처리provider는 user detail 과 pw encoder 를 사용해서 보안 컨텍스트가 인증 데이터유지 및인증 논리를 구현하고UserDetailService 객체는 자격 증명이 있는 사용자의 집합을 관리하고,사용자의 추가/패스워드 관리 등을 진행한다.provider userDetailService 와 passwordEncoder 에 작업을 위임한다.(인증 논리만 구현하고 사용자 관리/ 암호 관리만, 필요 없도록 재정의도 가능)userDetailService 에서 user 를 찾고, passEncoder 로 암호 검증(provider 가 위임한 작업)provider 는 인증 논리를 구현하고 토근을 반환한다.userDetailService 와 userDetails사용자 기술 : userDetails사용자 권한 : GrantedAuthority사용자 만들기 등의 user 관리는 userDetailsManager(JdbcUserDetailsManager 중요)Service와 Manager 분리는 인터페이스 분리 원칙사용자 검색/관리를 위해 사용자 객체 생성 필요userDetails 객체 필요이거는 Granted Authority 객체 집합을 가진다.Jdbc 를 이용할 때는 user entity 를 만들고entity 를 저장할 userDetails 를 구현한다.userDetailsService 는 loadUserByUsername 메소드를 재정의하여userDetails 를 반환하여 사용자 검색을 완료한다userManager 는 createUser updateUser deleteUser changePassword userExists위 메소드를 구현해야하고, JdbcUserManager 도 있다.JdbcUserManager 의 쿼리 재지정 후 빈으로 사용하면userDetailsService 가 인식해서 사용한다.configure 에서 auth userDetailsService(내가 만든 manager 사용 service) 해서 사용가능암호화 방식은 BCrypt 사용provider 는 요청 허용 결정Manager 는 요청 수신 provider 에 전달.인증 이벤트는 Authentication 인터페이스가 나타낸다.Authentication -&gt; manager에게 이벤트 발생 -&gt; provider 는 event 를 받음 -&gt; 인증 진행 -&gt; Authentication (Authenticate 메소드 인스턴스 반환 or exception)지원하는지 알아내는 provider 메소드는 supports 이다.authentication 의 구현 인스턴스의 예시 : UsernamePaswwordAuthenticationToken반환된 authentication 인스턴스를 secure context 가 보관한다.요청을 A가 하면 A를 가진 보안 컨텍스트가 응답즉, Authentication a 를 넣으면 된다.엘리게이팅(?)은 나중에 공부하자필터가 getHeader 해서 name/pass 가져오고,Authentication a 를 만들어서 각 프로바이더가 받아서 인증 진행한 뒤 매니저에게 넘긴다.인증이 끝나면 jwt 를 발급하고, response 에 authorization header 에 jwt 를 넘긴다.jwt 를 만들 때 class 에 권한도 넣자.클라이언트는 jwt 를 요청마다 모든 컨트롤러에 넘기고요청 필터가 jwt 취득 후 검증,username 을 얻고, 권한을 찾을 후 토큰을 만들어 컨텍스트에 넣는다.단, 이 작업은 요청당 단 한 번만 진행해야 하기 떄문에,OncePerRequestFilter 를 확장해서 만든다.로그인도 인증이고 jwt 검증도 인증이다." }, { "title": "TEMP JPA - 인프런", "url": "/posts/inflearn-jpa/", "categories": "공부, 스프링", "tags": "자바, 스프링, 웹", "date": "2021-09-27 09:01:00 +0900", "snippet": "https://docs.spring.io/spring-framework/docs/5.3.22/reference/html/data-access.html#orm스프링 프레임워크는 JPA 와의 통합을 지원한다.리소스 관리를 위한 native hibernate,dao 구현체, 트랜잭션 전략 을 지원한다.ORM 툴에 관한 것들을 의존성 주입을 통해 설정할 수 있다.ORM 을 사용할 떄의 이점 간단한 테스트 공통 데이터 접근 예외 general resouce management 트랜잭션 관리JPA 를 사용하기 위해서는 org.springframework.orm.jpa 의존성 추가JPA 구현체인hibernate-entitymanager 추가스프링 환경에서 JPA 세팅을 위한 세 가지 방법LocalEntityManagerFactoryBean이 객체는 JPA 만 사용하는 환경에서 EntityManagerFactory 객체를 생성하고,PersistenceProvider 를 자동으로 찾아 사용한다.Obtaining an EntityManagerFactory from JNDILocalContainerEntityManagerFactoryBeanspring-orm, hibernate-entitymanager, hikariCP 만 있을 때,빈이 정상적으로 생성되었다." }, { "title": "TEMP JPA - 스프링 공식 문서", "url": "/posts/docs-jpa/", "categories": "공부, 스프링", "tags": "자바, 스프링, 웹", "date": "2021-09-27 09:01:00 +0900", "snippet": "https://docs.spring.io/spring-framework/docs/5.3.22/reference/html/data-access.html#orm스프링 프레임워크는 JPA 와의 통합을 지원한다.리소스 관리를 위한 native hibernate,dao 구현체, 트랜잭션 전략 을 지원한다.ORM 툴에 관한 것들을 의존성 주입을 통해 설정할 수 있다.ORM 을 사용할 떄의 이점 간단한 테스트 공통 데이터 접근 예외 general resouce management 트랜잭션 관리JPA 를 사용하기 위해서는 org.springframework.orm.jpa 의존성 추가JPA 구현체인hibernate-entitymanager 추가스프링 환경에서 JPA 세팅을 위한 세 가지 방법LocalEntityManagerFactoryBean이 객체는 JPA 만 사용하는 환경에서 EntityManagerFactory 객체를 생성하고,PersistenceProvider 를 자동으로 찾아 사용한다.Obtaining an EntityManagerFactory from JNDILocalContainerEntityManagerFactoryBeanspring-orm, hibernate-entitymanager, hikariCP 만 있을 때,빈이 정상적으로 생성되었다." }, { "title": "TEMP 스프링 시큐리티 - 코.스.웹", "url": "/posts/csw-security/", "categories": "공부, 스프링", "tags": "자바, 스프링, 웹", "date": "2021-09-27 09:01:00 +0900", "snippet": "코드로 배우는 스프링 웹 프로젝트 - 시큐리티편“권한이나 등급에 기반을 두는 요청”Spring Web Security 를 이용하여인터셉터 등을 대신해서 위 요청을 처리한다.ex) 로그인 처리와 CSRF 토큰 처리 암호화 처리 자동 로그인 JSP 에서의 로그인 처리스프링 시큐리티의 기본 동작 방식은서블릿의 여러 종류의 필터와 인터셉터를 이용해서 처리된다.하나의 스프링 MVC 프로젝트에 스프링 시큐리티가 적용된다면,다음과 같은 구조가 생성된다.ServletContext{ filter SpringContext{ Interceptor WebApplicationContext RootContext SecurityContext{ AuthenticationManager AccessDecisionManager } }}필터의 경우 스프링 컨텍스트와 실질적으로 무관하고,인터셉터의 경우 스프링의 내부에서 컨트롤러를 호출할 때 관여하기 때문에,스프링 컨텐스트 내에 있는 모든 자원을 활용할 수 있다." } ]
